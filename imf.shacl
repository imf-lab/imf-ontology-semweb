@prefix sh: <http://www.w3.org/ns/shacl#>.
@prefix imf: <http://example.com/imf#>.
@prefix rdfs: 	<http://www.w3.org/2000/01/rdf-schema#>.
@prefix lis: <http://standards.iso.org/iso/15926/part14/>.

imf:AspectObjectTree
    a sh:NodeShape ;
    sh:targetClass imf:AspectObject ;
    sh:property [
        sh:path rdfs:label;
        sh:minCount 1;
        sh:name "Object Name";
        sh:message "An aspect object must have exactly one name";
    ] ;
    sh:property [
        sh:path ( [ sh:zeroOrMorePath [ sh:alternativePath ( imf:hasParent [sh:inversePath imf:hasTerminal] ) ] ] imf:isAspectOf ) ;
        sh:minCount 1;
        sh:class imf:IntegratedObject ;
        sh:name "nodeintree";
        sh:message "Every aspect object must have a path to the project node" ;
    ] ;
    sh:property [
        sh:path imf:hasChild ;
        sh:class imf:AspectObject;
    ] ;
    sh:property [
        sh:path imf:hasAspect ;
        sh:maxCount 1;
        sh:name "ObjectAspect";
        sh:message "Each aspectobject has at most one aspect";
    ] ;
    sh:property [
        sh:path ([sh:zeroOrMorePath [sh:alternativePath (imf:hasParent [sh:inversePath imf:hasTerminal])]] imf:hasAspect) ;
        sh:minCount 1;
        sh:name "ObjectAspect";
        sh:message "Each aspectobject has at least one parent with defined aspect";
    ].

imf:FunctionFulfilled
    a sh:NodeShape ;
    sh:targetClass imf:FunctionAspectObject ;
    sh:property [
        sh:path imf:fulfilledBy;
        sh:maxCount 1;
        sh:class imf:ProductAspectObject ;
        sh:name "FulfilledByProduct" ;
        sh:message "A function aspect object can have at most one inter-aspect relation to a product object. If there are more, you need a product group.";
    ];
    sh:property [
        sh:path imf:hasLocation;
        sh:class imf:LocationAspectObject ;
        sh:name "FunctionLocation" ;
        sh:message "A function aspect object can have any number of locations";
    ] .

imf:ProductLocation
    a sh:NodeShape ;
    sh:targetClass imf:ProductAspectObject ;
    sh:property [
        sh:path imf:hasLocation;
        sh:class imf:LocationAspectObject ;
        sh:name "productlocation" ;
        sh:message "A product aspect object can have any number of locations";
    ] ;
    sh:property [
        sh:path [ sh:inversePath imf:fulfilledBy ];
        sh:maxCount 1;
        sh:class imf:FunctionAspectObject ;
        sh:name "FulfilledByProduct" ;
        sh:message "A product aspect object can be inter-aspect related to at most one function object. If there are more, you need to split up the function objects.";
    ];
    sh:property [
        sh:path imf:installedAs;
        sh:class imf:InstalledAspectObject ;
        sh:name "InstalledProduct" ;
        sh:message "A product aspect object can be installed as any number of actual things.";
    ].

imf:InstalledInterAspect
    a sh:NodeShape ;
    sh:targetClass imf:InstalledAspectObject ;
    sh:property [
        sh:path [ sh:inversePath imf:installedAs ];
        sh:class imf:ProductAspectObject ;
        sh:name "installedproduct" ;
        sh:message "An installed object can be related to any number of product objects";
    ] .


imf:SystemBlockTree
    a sh:NodeShape ;
    sh:targetClass imf:SystemBlock ;
    sh:property [
        sh:path ([ sh:oneOrMorePath imf:hasParent]  imf:isAspectOf) ;
        sh:minCount 1;
        sh:maxCount 1;
        sh:class imf:IntegratedObject ;
        sh:name "nodeintree";
        sh:message "Every node must have a path to the project node" ;
    ] ;
    sh:property [
        sh:path imf:isAspectOf ;
        sh:maxCount 0;
        sh:name "AspectTopNotBlock";
        sh:message "The top node in an aspect is not a SystemBlock, just a dummy representing the context";
    ].


imf:TransportFunctional
    a sh:NodeShape ;
    sh:targetClass imf:Transport ;
    sh:property [
        sh:path imf:hasOutTerminal ;
        sh:class imf:OutTerminal ;
        sh:class imf:StreamTerminal ;
        sh:minCount 1;
        sh:maxCount 1;
        sh:name "transportout";
        sh:message "A Transport has exactly one out terminal.";
    ] ;
    sh:property [
        sh:path imf:hasInTerminal ;
        sh:class imf:InTerminal ;
        sh:class imf:StreamTerminal ;
        sh:minCount 1;
        sh:maxCount 1;
        sh:name "transportin";
        sh:message "A Transport has exactly one in terminal.";
    ];
    sh:property [
        sh:path imf:hasTerminal ;
        sh:minCount 2;
        sh:maxCount 2;
        sh:name "transportin";
        sh:message "A Transport has exactly two terminals.";
    ] .

imf:InterfaceFunctional
    a sh:NodeShape ;
    sh:targetClass imf:Interface ;
    sh:property [
        sh:path imf:hasTerminal ;
        sh:class imf:OutTerminal ;
        sh:minCount 1;
        sh:maxCount 1;
        sh:name "transportout";
        sh:message "An interface has exactly one out terminal.";
    ] ;
    sh:property [
        sh:path imf:hasTerminal ;
        sh:class imf:InTerminal ;
        sh:minCount 1;
        sh:maxCount 1;
        sh:name "transportin";
        sh:message "An interface has exactly one in terminal.";
    ] .


imf:TerminalTree
    a sh:NodeShape ;
    sh:targetClass imf:SystemBlockTerminal ;
    sh:property [
        sh:path ([ sh:zeroOrMorePath imf:hasParent]  [ sh:inversePath imf:hasTerminal]) ;
        sh:minCount 1;
        sh:class imf:SystemBlock ;
        sh:name "blockterminalintree";
        sh:message "Every block terminal must have at least one parent block" ;
    ]  .



imf:StreamTerminalTree
    a sh:NodeShape ;
    sh:targetClass imf:StreamTerminal ;
    sh:property [
        sh:path ([ sh:zeroOrMorePath imf:hasParent]  [ sh:inversePath imf:hasTerminal]) ;
        sh:minCount 1;
        sh:maxCount 1;
        sh:class imf:Transport ;
        sh:name "streamterminalintree";
        sh:message "Every stream terminal must have a single parent transport" ;
    ] ;
    sh:property [
        sh:path imf:isConnectedTo ;
        sh:minCount 1;
        sh:maxCount 1;
        #sh:class imf:SystemBlockTerminal ;
        sh:name "streamterminalconnected";
        sh:message "Every stream terminal must be connected to exactly one block terminal" ;
    ] .

imf:TerminalConnected
    a sh:NodeShape ;
    sh:targetClass imf:Terminal ;
    sh:property [
        sh:path imf:isConnectedTo ;
        sh:maxCount 1;
        sh:class imf:Terminal ;
        sh:name "connectedtofunctional";
        sh:message "Every terminal can be connected zero or 1 terminals" ;
    ] ;
    sh:property [
        sh:path lis:hasPhysicalQuantity ;
        sh:class lis:PhysicalQuantity;
        sh:name "physicalQUantity";
        sh:message "Terminals can have physical quantities";
    ] ;
    sh:property [
        sh:path imf:hasAspect;
        sh:class imf:Aspect ;
        sh:maxCount 1;
        sh:name "maxoneasapect";
        sh:message "A terminal can have at most one aspect";
    ] ;
    sh:property [
        sh:path rdfs:label ;
        sh:minCount 1;
        sh:name "terminalLabel";
        sh:message "A terminal must have at least one label";
    ];
    sh:property [
        sh:path imf:hasChild ;
        sh:class imf:Terminal ;
        sh:name "terminalChild";
        sh:message "A product terminal can have any number of child terminals";
    ];
    sh:property [
        sh:path imf:hasParent ;
        sh:class imf:Terminal ;
        sh:maxCount 1;
        sh:name "terminalParent";
        sh:message "A product terminal can have at most one parent";
    ];
    sh:ignoredProperties (rdf:type owl:sameAs imf:hasLocation imf:fulfilledBy imf:installedAs owl:topObjectProperty) ;
    sh:closed false .


imf:ProjectNode
    a sh:NodeShape ;
    sh:targetClass imf:IntegratedObject;
    sh:property [ 
        sh:path rdfs:label ;
        sh:name "project name";
        sh:message "A project must have exactly one name" ;
        sh:minCount 1 ;
        sh:maxCount 1;
    ] ;
    sh:property [ 
        sh:path owl:versionInfo ;
        sh:name "project version";
        sh:message "A project must have exactly one version" ;
        sh:minCount 1 ;
        sh:maxCount 1;
    ] ;
    sh:ignoredProperties (rdf:type owl:sameAs) ;
    sh:closed false .

imf:physicalQuantity
    a sh:NodeShape ;
    sh:targetClass lis:PhysicalQuantity;
    sh:property [
        sh:path lis:qualityQuantifiedAs;
        sh:class lis:ScalarQuantityDatum;
        sh:minCount 1;
        sh:name "qualityHasDatum";
        sh:message "Physical Qualities can be related to at least one datums";
    ];
    sh:closed false;
    sh:ignoredProperties (rdf:type rdfs:label owl:saneAs).


imf:physicalQuantityDatum
    a sh:NodeShape ;
    sh:targetClass lis:ScalarQuantityDatum;
    sh:property [
        sh:path   lis:quantifiesQuality ;
        sh:class lis:PhysicalQuantity;
        sh:minCount 0;
        sh:maxCount 1;
        sh:name "datumHasQuality";
        sh:message "Physical Data are of exactly one quality";
    ];
    sh:property [
        sh:path lis:datumValue;
        sh:maxCount 1;
        sh:name "datumvalue";
        sh:message "A datum has exactly one value and it is a float";
    ];
    sh:property [
        sh:path lis:datumUOM;
        sh:class lis:Scale;
        sh:maxCount 1;
        sh:name "datumvalue";
        sh:message "A datum has exactly one unit";
    ];
    sh:property [
        sh:path rdfs:label;
        sh:name "datumlabel";
        sh:message "A datum can have label(s)";
    ];
    sh:closed false;
    sh:ignoredProperties (rdf:type owl:sameAs).

#Below are constraints that check for members of "Invalid" classes generated by datalog rules in validator.dlog
imf:CheckInvalidTerminals
    a sh:NodeShape ;
    sh:targetClass imf:AspectObject;
    sh:property [
        sh:path imf:errorMessage;
        sh:maxCount 0;
        sh:name "invalidObject";
        sh:message "This aspect object is part of an invalid design pattern";
    ].


#Below are constraints in the SHACL-SPARQL language. These have not been checked, as I dont have access to an implementation
    
imf:HasLocationCross 
    a sh:NodeShape;
    sh:targetClass imf:SystemBlock;
    sh:sparql[
        a sh:SPARQLConstraint ;
        sh:prefixes imf: ;
        sh:select """
            SELECT $this (imf:hasLocation AS ?path) ($this AS ?value)
            WHERE {
                $this imf:hasLocation/imf:hasChild+/^imf:hasLocation/imf:hasChild+ $this.
            }
            """;
        sh:name "invalidHasLocationCross";
        sh:message "Inter aspect relations must respect the tree structures in each tree: Detected a cycle using hasChild and hasLocation relations.";
    ].

imf:FulfilledByCross 
    a sh:NodeShape;
    sh:targetClass imf:FunctionAspectObject;
    sh:sparql[
        a sh:SPARQLConstraint ;
        sh:prefixes imf: ;
        sh:select """
            SELECT $this (imf:fulfilledBy AS ?path) ($this AS ?value)
            WHERE {
                $this imf:fulfilledBy/imf:hasChild+/^imf:fulfilledBy/imf:hasChild+ $this.
            }
            """;
        sh:name "invalidFulfilledByCross";
        sh:message "Inter aspect relations must respect the tree structures in each tree";
    ] .

imf:InstalledAsCross 
    a sh:NodeShape;
    sh:targetClass imf:ProductAspectObject;
    sh:sparql[
        a sh:SPARQLConstraint ;
        sh:prefixes imf: ;
        sh:select """
            SELECT $this (imf:installedAs AS ?path) ($this AS ?value)
            WHERE {
                $this imf:installedAs/imf:hasChild+/^imf:installedAs/imf:hasChild+ $this.
            }
            """;
        sh:name "invalidInstalledAsCross";
        sh:message "Inter aspect relations must respect the tree structures in each tree";
    ] .


imf:OutTerminalIncreaseAttributes
    a sh:NodeShape;
    sh:targetClass imf:Terminal;
    sh:sparql[
        a sh:SPARQLConstraint ;
        sh:prefixes imf: ;
        sh:select """
            SELECT $this (imf:isConnectedTo AS ?path) (?v1 AS ?value)
            WHERE {
                $this lis:hasPhysicalQuantity ?q1;
                        imf:hasParent*/imf:isConnectedTo/lis:hasPhysicalQuantity ?q2.
                ?q1 a ?qt; lis:qualityQuantifiedAs ?datum1.
                ?datum1 lis:datumUOM ?unit; lis:datumValue ?v1.
                #?q2 a ?qt; lis:qualityQuantifiedAs ?datum2.
                #?datum2 lis:datumUOM ?unit; lis:datumValue ?v2.
                #FILTER(?v1 = ?v2).
            }
            """;
        sh:name "outTerminalAttribute";
        sh:message "Out Terminals must connect to a terminal with equal attributes";
    ] .
