#+TITLE: IMF Language Specification
#+DATE: Editor: Martin G. Skjæveland
#+AUTHOR:
#+EMAIL:

#+OPTIONS: ':nil *:t -:t ::t <:t H:4 \n:nil ^:t arch:headline
#+OPTIONS: author:t broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:t todo:t |:t
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport QA update old
#+EXPORT_FILE_NAME: index.html

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [12pt]
#+LATEX_HEADER: \usepackage{fullpage,parskip,times}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \usepackage[zerostyle=d]{newtxtt} %% Various versions of zeros available. See documentation for details

* IMF Ontology (OWL)
** Ontology header

#+NAME: owl-imf-ontology
#+BEGIN_SRC ttl :noweb strip-export :tangle out/owl/imf-ontology.owl.wottr.ttl :mkdirp yes
<<prefixes-imf>>
<<prefixes-ottr>>

imf:IMFOntology a owl:Ontology ;
    owl:versionIRI <http://ns.imfid.org/20230630/imf-ontology.owl.ttl> ;
    owl:versionInfo "0.2.1--SNAPSHOT" ;
    owl:priorVersion <https://ns.imfid.org/20221118/imf-vocabulary.owl.ttl> ;
    skos:prefLabel "IMF Ontology -- OWL" ;
    vann:preferredNamespacePrefix "imf" ;
    vann:preferredNamespaceUri imf: ;
    pav:createdOn "2023-06-30T00:00:00"^^xsd:dateTime ;
    pav:createdBy _:mgs ;
    pav:contributedBy _:mgs, _:aw, _:ef ;
    foaf:depiction <http://ns.imfid.org/20230630/img/imf-ontology.png> ;
    dc:description """
The IMF Ontology defines the vocabulary for creating IMF models, and contains classes such as [Block], [Terminal], [Aspect] and [Attribute]; and properties such as [part of] and [connected to].

The ontology is designed to meet the following functional requirements:

 - The users of IMF should be subject matter experts (SME). This means that the IMF language and ontology must be easy to learn and simple to use, hence it must contain a limited set of vocabulary terms and grammar rules.
 - The language must provide incremental value, and hence must support modelling in an incremental manner.
 - The language must be scalable across disciplines, work processes, and the value chain. This means that the IMF language must:
    - Enable SMEs from a range of disciplines to fully express their design using the same modelling principles.
    - Enable SMEs to express different levels of precision as part of iterations of their design.
    - Enable use in different phases of a project (concept, detail engineering, manufacturing, etc.).
 - The language must have the precision of machine interpretation to allow automated verification. This means that the IMF language must be precise and unambiguous, and allow translation into other ontology languages and be able to exploit semantic descriptions in external ontologies and reference data libraries.
    """ ;
    skos:changeNote
      """0.2.0 :: Change summary:

 - Change: minor naming adjustments to some IRIs.
 - Added metadata descriptions, including definitions and statuses.

Generated list of all change notes for this version's entities:
<<py_run_sparql(query="SELECT DISTINCT ?element (STRAFTER(?changeNote, ?versionNo) AS ?note) { ?ont a owl:Ontology ; owl:versionInfo ?versionNo . ?element a ?elementType ; skos:changeNote ?changeNote . FILTER (?elementType != owl:Ontology) FILTER(STRSTARTS(?changeNote, ?versionNo))} ORDER BY ?element", formatting="list1")>>

Generated diff of IRIs in the IMF namespace between this and the previous version of the ontology:

<<py_iri_rdf_diff(v2="out/owl/imf-ontology.owl.ttl", v1="https://ns.imfid.org/20221118/imf-vocabulary.owl.ttl")>>


""" ;
    # cc:licence
    # skos:scopeNote ## add description of ontology

    skos:scopeNote
      """
The use of this ontology may be validated against the following SHACL shape specifications:

  - [IMF Terms](http://ns.imfid.org/20230630/imf-terms-grammar.shacl.ttl), specifies all the IRIs in the IMF namespace that is defined by the IMF Ontology. Use this to ensure that you are using the correct IRIs for the terms in the IMF Ontology.
  - [IMF Model Grammar](http://ns.imfid.org/20230630/imf-model-grammar.shacl.ttl), specifies constraints on the use of the IMF Ontology. Use this to ensure that you are using the IMF Ontology grammatically correctly.


Terms in the ontology are created following these principles:

  - All terms should validate against the SHACL shape description: <http://ns.imfid.org/20230630/imf-ontology-grammar.shacl.ttl>

  - All terms in the ontology are given a status using the `vs:term_status` property from the ['Term-centric Semantic Web Vocabulary Annotations' vocabulary](https://www.w3.org/2003/06/sw-vocab-status/note.html) to indicate their level of maturity using one of the values 'unstable', 'testing', 'stable' and 'archaic'. In this version of the ontology the highest status is 'testing'. Some terms are 'unstable'; these terms also contain the word 'unstable' in their label to make this clear.

  - All IRIs in the ontology are placed in the namespace `http://ns.imfid.org/imf`. The localnames of IRIs follow these naming conventions:

    - Classes use `UpperCamelCase`;
    - Properties use `lowerCamelCase`, with additional rules:
       - object properties between IMF Classes usually start with a verb, e.g., `has`,
       - object properties for reified properties start with `the`,
       - object properties to external libraries, datatype properties, and annotation properties do not start with a verb;
    - Individuals use `lowerCamelCase`.

  - When referring to a term in the ontology, the following format is used: [prefLabel], where prefLabel is set by the property `skos:prefLabel`, e.g., we will write [Block] to refer to the class `imf:Block`.


The ontology makes use of these vocabularies for its definition:

 - [SKOS](https://www.w3.org/TR/skos-primer/)
 - [PAV](https://pav-ontology.github.io/pav/)
 - [VANN](https://vocab.org/vann/)
 - [Term-centric Semantic Web Vocabulary Annotations](https://www.w3.org/2003/06/sw-vocab-status/note.html)


Versions of this ontology and other semantic web resources for IMF are published at an URL following this schema: `http://ns.imfid.org/[yyyy-mm-dd]/[resource-name]`.
""" ;

    sh:suggestedShapesGraph <http://ns.imfid.org/20230630/imf-model-grammar.shacl.ttl> ;
    sh:shapesGraph
      <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl> ,
      <http://ns.imfid.org/20230630/imf-ontology-grammar.shacl.ttl> ,
      <http://ns.imfid.org/20230630/imf-terms-grammar.shacl.ttl> ;

    skos:editorialNote """Result of validation against specified sh:shapesGraph:
<<sh_jena_shacl_validate(data="out/owl/imf-ontology.owl.ttl", shapes="http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl")>>

<<sh_jena_shacl_validate(data="out/owl/imf-ontology.owl.ttl", shapes="http://ns.imfid.org/20230630/imf-terms-grammar.shacl.ttl")>>

<<sh_jena_shacl_validate(data="out/owl/imf-ontology.owl.ttl", shapes="http://ns.imfid.org/20230630/imf-ontology-grammar.shacl.ttl")>>
    """
    .

_:mgs foaf:name "Martin G. Skjæveland" .
_:aw  foaf:name "Arild Waaler" .
_:ef  foaf:name "Erlend Fjøsna" .

<<owl-imf-ontology-all-includes>>
#+END_SRC

*** _includes                                                      :noexport:
#+NAME: owl-imf-ontology-all-includes
#+BEGIN_SRC ttl :noweb yes

<<owl-model-model>>

<<owl-main-genericrelations>>

<<owl-elements-element>>

<<owl-elements-block>>

<<owl-elements-terminal>>

<<owl-elements-direction>>

<<owl-elements-inputoutputTerminal>>

<<owl-elements-annotations>>

<<owl-elements-relations-partof>>

<<owl-elements-relations-connectedTo>>

<<owl-elements-relations-classifier>>

<<owl-elements-relations-hasmedium>>

<<owl-elements-reifieds-breakdownpoint>>

<<owl-elements-reifieds-connectionpoint>>

<<owl-aspects-aspectelement>>

<<owl-aspects-aspect>>

<<py_aspect_ottr_instances_aspects()>>

<<owl-aspects-relations>>

<<owl-attributes-value>>

#<<owl-attributes-group>>

<<owl-attributes-qualifier>>

<<py_aspect_ottr_qualifiers()>>

<<owl-types-type>>

#+END_SRC

** Model

#+NAME: plantuml-model
#+BEGIN_SRC plantuml :noweb yes :file out/owl/imf-ontology-model.png
<<plantuml-style>>

class Model
abstract class Element

Model o--> "*" Element
#+END_SRC

#+NAME: owl-model-model
#+BEGIN_SRC ttl
imf:Model a owl:Class ;
  skos:prefLabel "Model (unstable)" ;
  vs:term_status "unstable" ;
  skos:definition "A [Model] is a collection of [Element]s. " ;
  skos:scopeNote """A [Model] is a construct for organising [Element]s into an identified collection which is useful for, e.g., provenance, exchange and integration.

The set of [Element]s of a [Model] is expressed using the property [has Element]. A [Model] can contain any number of [Element]s.

[Model] has the status 'unstable'; more detailed use cases and experience is required to work out its details.""" ;
  skos:editorialNote "TODOs: Can an [Element] belong to multiple [Model]s, if so, should it have one 'owner'?" ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "model" ;
  foaf:depiction <http://ns.imfid.org/20230630/img/imf-ontology-model.png> ;
.

imf:hasElement a owl:ObjectProperty ;
  skos:prefLabel "has element (unstable)" ;
  vs:term_status "unstable" ;
  skos:definition "[has element] is a relation from a [Model] *M* to an [Element] *E* to specify that *M* contains *E*." ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "model" ;
  rdfs:domain imf:Model ;
  rdfs:range imf:Element .
#+END_SRC

#+NAME: shacl-model-model
#+BEGIN_SRC ttl
imf:ModelShape a sh:NodeShape ;
  sh:targetClass imf:Model ;
  sh:targetSubjectsOf imf:hasElement ;
  sh:property
    [ sh:path imf:hasElement ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "The Model contains no Elements." ] ;
  skos:changeNote
    "0.2.0 :: Added",
    "O.2.1 :: Changed: Set nodeKind"
.
#+END_SRC

** Structural relations

The following scope note is put on all following top-level relations:
#+NAME: owl-genericrelation-scope-note
#+BEGIN_SRC ttl
    skos:scopeNote "This is a generic property that is not intended to be used directly, rather use one of its subproperties. Generic properties like this are introduced to add structure to the properties of the ontology, and to be able to express generic class constraints." ;
#+END_SRC

#+NAME: owl-main-genericrelations
#+BEGIN_SRC ttl :noweb yes

imf:externalReference a owl:ObjectProperty ;
    skos:prefLabel "external reference" ;
    vs:term_status "testing" ;
    skos:definition "[external reference] is a generic relation that relates a resource *X* to a resource in an external ontology or reference data library to describe *X*." ;
<<owl-genericrelation-scope-note>>
    skos:changeNote
      "0.2.0 :: Added" ;
    vann:termGroup "generic relations" ;
.

imf:hierarchicalRelation a owl:ObjectProperty ;
    skos:prefLabel "hierarchical relation";
    vs:term_status "testing" ;
    skos:definition "[hierarchical relation] is a generic relation that relates resources in a hierarchical or tree-shaped structure." ;
    rdfs:seeAlso <https://en.wikipedia.org/wiki/Tree_(data_structure)> ;
<<owl-genericrelation-scope-note>>
    skos:changeNote
      "0.1.0 :: Added" ;
    vann:termGroup "generic relations" ;
    a owl:IrreflexiveProperty ;
    rdfs:subPropertyOf skos:semanticRelation ;
    .

imf:associativeRelation a owl:ObjectProperty ;
    skos:prefLabel "associative relation";
    vs:term_status "testing" ;
    skos:definition "[associative relation] is a generic relation that relates resources in an associative (or non-hierarchical) structure." ;
<<owl-genericrelation-scope-note>>
    skos:changeNote
      "0.1.0 :: Added" ;
    vann:termGroup "generic relations" ;
    rdfs:subPropertyOf skos:related ;
    owl:propertyDisjointWith imf:hierarchicalRelation ;
    .
#+END_SRC

** Elements

#+NAME: plantuml-elements
#+BEGIN_SRC plantuml :noweb yes :file out/owl/imf-ontology-elements.png
<<plantuml-style>>

abstract class Element {
  notation : 0..1
  symbol : 0..1
}

class Block
class Terminal

class RDLItem << RDL >>
class Medium << RDL >>

enum TerminalQualifier {
 inputFlow
 outputFlow
}

Element "*" --> "*" RDLItem : classifier

' subclasses
Element <|-- Block
Element <|-- Terminal

' relations
Block "1" --> "*" Terminal : hasTerminal
Terminal "*" --> "0..1" Medium : medium
Terminal "*" --> "0..*" TerminalQualifier : hasTerminalQualifier

Element "1" <-- "*" Element : partOf
Terminal "1" --> "1" Terminal : connectedTo
#+END_SRC

#+ATTR_LATEX: :width 8cm
#+RESULTS: overview-instances
[[file:out/owl/imf-ontology-elements.png]]

*** ~Element~

#+NAME: owl-elements-element
#+BEGIN_SRC ttl
imf:Element a owl:Class ;
  skos:prefLabel "Element" ;
  vs:term_status "testing" ;
  skos:definition "An [Element] is a generic entity for modelling systems and system elements. An [Element] is described by its relations to other [Element]s, e.g., [part of] and [connected to], and by its [Attribute]s (through the property [has attribute])." ;
  skos:scopeNote "[Element] is a very generic concept and direct instantiation of [Element] is probably a mistake. A better option is to use a subclass of [Element] that specifies whether the [Element] is either a [Block] or [Terminal], and its [Aspect], e.g., [Function Block]." ;
  skos:note """An [Element] should be expressed with the following metadata:

 - a preferred label (using `skos:prefLabel`);
 - optionally additional alternative labels (using `skos:altLabel`);
 - a (textual) description (using `dc:description`);
 - optionally a source of origin from which information about the element is taken (using `dc:source`);
 - a version number (using `pav:version`);
 - a created timestamp (using `pav:createdOn`);
 - its creator, i.e., a person (using `createdBy`);
 - optionally contributors to its creation (using `pav:contributedBy`);
 - optionally the time of latest update (using `pav:lastUpdateOn`).""" ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  foaf:depiction <http://ns.imfid.org/20230630/img/imf-ontology-elements.png> ;
.
#+END_SRC

#+NAME: shacl-elements-annotations
#+BEGIN_SRC ttl
_:MetadataShape a sh:NodeShape ;
  sh:name "Metadata" ;
  sh:description "Suggested list of metadata properties for central classes." ;
  sh:deactivated true ;
  sh:targetClass imf:Element , imf:Type ;
  sh:property
    [ sh:path skos:prefLabel ; sh:minCount 1 ; sh:nodeKind sh:Literal ; sh:severity sh:Warning ; sh:message "Missing prefLabel." ] ,
    [ sh:path dc:description ; sh:minCount 1 ; sh:nodeKind sh:Literal ; sh:severity sh:Warning ; sh:message "Missing description." ] ,
    [ sh:path pav:version    ; sh:minCount 1 ; sh:nodeKind sh:Literal ; sh:severity sh:Warning ; sh:message "Missing version number." ] ,
    [ sh:path pav:createdOn  ; sh:minCount 1 ; sh:nodeKind sh:Literal ; sh:severity sh:Warning ; sh:message "Missing created timestamp." ] ,
    [ sh:path pav:createdBy  ; sh:minCount 1 ; sh:nodeKind sh:Literal ; sh:severity sh:Warning ; sh:message "Missing creator." ] ;
  skos:changeNote
    "0.2.0 :: Added" ,
    "0.2.1 :: Changed: set nodeKind"
.

imf:ElementShape a sh:NodeShape ;
  sh:targetClass imf:Element ;
  sh:property
    [ sh:path imf:partOf ; sh:maxCount 1 ; sh:message "The Element has more than one parent."  ] ,
    [ sh:deactivated true ; sh:path [ sh:inversePath imf:hasElement ] ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "The Element is not contained in a Model." ] ;
  skos:changeNote
    "0.2.0 :: Added" ,
    "0.2.1 :: Changed: set nodeKind; moved requirement on imf:purpose to Block."
.
#+END_SRC

*** Metadata properties

#+NAME: owl-elements-annotations
#+BEGIN_SRC ttl
skos:notation a owl:DatatypeProperty ;
  skos:scopeNote "From the SKOS reference: 'A notation is a string of characters such as \"T58.5\" or \"303.4833\" used to uniquely identify a concept within the scope of a given concept scheme.' Use skos:notation to set a RDS string."
  .

imf:symbol a owl:ObjectProperty ;
  skos:prefLabel "symbol" ;
  vs:term_status "testing" ;
  skos:definition "[symbol] is an [external reference] that associates a resource *X* with a typical graphical representation of *X*." ;
  skos:changeNote "0.2.0 :: Added" ;
  vann:termGroup "aspects" ;
  rdfs:subPropertyOf imf:externalReference ;
  .
#+END_SRC

*** ~partOf~ / ~hasPart~

#+NAME: owl-elements-relations-partof
#+BEGIN_SRC ttl
imf:partOf a owl:ObjectProperty;
  skos:prefLabel "part of" ;
  skos:altLabel "has parent" ;
  vs:term_status "testing" ;
  skos:definition "[part of] is a [hierarchical relation] and an [intra-aspect relation] that relates an [Element] *E1* and an [Element] *E2* to specify that *E1* is part of *E2*, or equivalently that *E2* has *E1* as a part. [part of] is used to specify a breakdown hierarchy of [Element]s." ;
  skos:scopeNote """[part of]/[has part] is used for describing an [Element] *E* by splitting *E* into parts *Es*, which again can be broken down into parts, to form a tree-shaped breakdown structure.

Formally this is expressed by specifying [part of] as a functional and irreflexive property. This means that any [Element] may only be part of one other [Element], that is: an [Element] may not be part of multiple [Element]s and it may not be part of itself.

[part of] is visualised with an arrow pointing from the child (the part) to the parent (the whole).""" ;
  foaf:depiction <http://ns.imfid.org/20230630/img/visualisation-partOf.jpg> ;
  skos:changeNote
    "0.1.0 :: Added" ,
    "0.2.0 :: Changed: IRI from imf:isPartOf to imf:partOf." ;
  vann:termGroup "elements" ;
  a owl:FunctionalProperty ;
  a owl:IrreflexiveProperty ;
  rdfs:subPropertyOf imf:intraAspectRelation, imf:hierarchicalRelation, skos:broader ;
  rdfs:domain imf:Element ;
  rdfs:range imf:Element ;
  .

imf:hasPart a owl:ObjectProperty ;
  skos:prefLabel "has part";
  skos:altLabel "has child";
  vs:term_status "testing" ;
  skos:definition "[has part] is a [hierarchical relation] and an [intra-aspect relation] that is the inverse relation of [part of]. See also [part of]." ;
  skos:scopeNote "Use [has part] when you want to specify the [Element]s that are part of an [Element] *E* \"on *E*\", rather than using the inverse property [part of] to state that the [part of] relationship to *E* for every [Element] that is part of *E*." ;
  skos:changeNote
    "0.1.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subPropertyOf imf:intraAspectRelation, imf:hierarchicalRelation, skos:narrower ;
  owl:inverseOf imf:partOf ;
  .
#+END_SRC

*** ~classifier~, ~purpose~

#+NAME: owl-elements-relations-classifier
#+BEGIN_SRC ttl
imf:classifier a owl:ObjectProperty ;
  skos:prefLabel "classifier" ;
  vs:term_status "testing" ;
  skos:definition "[classifier] is an [external reference] that relates an [Element] *E* to a resource *X* in an external ontology or reference data library such that *X* classifies *E* -- or equivalently, *E* is an instance of *X*." ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subPropertyOf imf:externalReference ;
  .

imf:purpose a owl:ObjectProperty ;
  skos:prefLabel "purpose" ;
  vs:term_status "testing" ;
  skos:definition "[purpose] is a [classifier] that relates an [Element] *E* to a resource *X* in an external ontology or reference data library such that *E* has the purpose *X*." ;
  skos:scopeNote "[purpose] should be used to state the main purpose of an [Element]. Any additional purposes can be stated using [classifier]." ;
  skos:example """Use [purpose] to state that the main activity of a [Function Block] is to perform pumping, by relating the [Function Block] to, e.g., the external resource PUMPING <https://data.posccaesar.org/rdl/RDS9657917>:

    ex:myFunctionBlock imf:purpose <https://data.posccaesar.org/rdl/RDS9657917> .

We then say that the [Function Block] has the purpose PUMPING.
In the case that the [Block] also performs, e.g,. a mixing activity, this can be stated by relating the [Block] to an external resource that represents this activity using the property [classifier].""" ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subPropertyOf imf:classifier ;
  .
#+END_SRC

*** ~Block~

#+NAME: owl-elements-block
#+BEGIN_SRC ttl
imf:Block a owl:Class ;
  skos:prefLabel "Block" ;
  vs:term_status "testing" ;
  skos:definition "A [Block] represents an abstraction over a system or a system element as per ISO/IEC/IEEE 15288." ;
  skos:scopeNote """A [Block] is a basic building block of the IMF language. A [Block] can represent anything which is of interest and which is deemed convenient to treat as a system or system element. A [Block] sets the boundaries of what it abstracts over---at any granularity level. This could be a whole industry plant, a pump system, a measuring function, or a location of interest.

A [Block] interfaces with other [Block]s via its [Terminal]s (expressed with the property [has terminal]). A [Block] can have any number of [Terminal]s.

A [Block] is visualised as a rectangular box.""" ;
  foaf:depiction <http://ns.imfid.org/20230630/img/visualisation-block.png> ;
  skos:changeNote
    "0.1.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subClassOf imf:Element ;
  .

[] ottr:of o-owl-ax:SubObjectAllValuesFrom ;
   ottr:values (imf:Block imf:partOf imf:Block) .
#+END_SRC

#+NAME: shacl-elements-block
#+BEGIN_SRC ttl
imf:BlockShape a sh:NodeShape ;
  sh:targetClass imf:Block ;
  sh:targetSubjectsOf imf:hasTerminal, imf:hasInputTerminal, imf:hasOutputTerminal ;
  sh:property
    [ sh:path imf:hasTerminal ; sh:class imf:Terminal ; sh:message "The Block has a Terminal which is not a Terminal." ] ,
    [ sh:path [ sh:alternativePath ( imf:hasTerminal imf:hasInputTerminal imf:hasOutputTerminal ) ] ;
	sh:minCount 1 ; sh:severity sh:Warning ; sh:message "The Block has no Terminals." ] ,
    [ sh:path imf:purpose ; sh:minCount 1 ; sh:nodeKind sh:IRI ; sh:severity sh:Warning ; sh:message "The Block has no purpose." ] ,
    [ sh:path imf:partOf  ; sh:class imf:Block ; sh:message "The Block has a part which is not a Block." ] ,
    [ sh:path imf:hasPart ; sh:class imf:Block ; sh:message "The Block is part of a non-Block." ] ,
    [ sh:path rdf:type ; sh:minCount 1 ; sh:class imf:BlockType; sh:severity sh:Warning ; sh:message "The Block has no BlockType." ] ;
  skos:changeNote
    "0.2.0 :: Added" ,
  """0.2.1 :: Changed: 
 - Moved requirement on imf:purpose from Element to Block
 - Adding warning on missing BlockType"""
.
#+END_SRC

*** ~Terminal~

#+NAME: owl-elements-terminal
#+BEGIN_SRC ttl
imf:Terminal a owl:Class ;
  skos:prefLabel "Terminal" ;
  skos:altLabel "Port", "Channel", "Input/Output" ;
  vs:term_status "testing" ;
  skos:definition """A [Terminal] is an [Element] that represents a point of interaction or communication for exactly one [Block] (through the relation [has terminal]), and hence specifies an input and/or output that the [Block] produces and/or receives. A [Terminal] may be qualified by [Terminal Qualifier]s.

A [Terminal] is visualised as a square with rounded corners containing a plus sign, attached to its [Block]. An [Input Terminal] is placed to the left of its [Block], while an [Output Terminal] is placed to the right of its [Block].""" ;
  foaf:depiction <http://ns.imfid.org/20230630/img/visualisation-terminal.jpg> ;
  skos:changeNote
    "0.1.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subClassOf imf:Element ;
  .

[] ottr:of o-owl-ax:SubObjectAllValuesFrom ;
   ottr:values (imf:Terminal imf:partOf imf:Terminal) .

imf:hasTerminal a owl:ObjectProperty ;
  skos:prefLabel "has terminal" ;
  vs:term_status "testing" ;
  skos:definition "[has terminal] is an [associative relation] and an [intra-aspect relation] that relates a [Block] *B* to a [Terminal] *T* to specify that *T* is a terminal of, or belongs to, *B*. [has terminal] is an inverse functional property which means that a [Terminal] may only belong to one [Block]." ;
  skos:changeNote
    "0.1.0 :: Added" ;
  vann:termGroup "elements" ;
  a owl:InverseFunctionalProperty ;
  rdfs:subPropertyOf imf:intraAspectRelation , imf:associativeRelation ;
  rdfs:domain imf:Block ;
  rdfs:range imf:Terminal ;
  .

[] ottr:of o-owl-ax:SubObjectSomeValuesFrom ;
   ottr:values (imf:Terminal [ owl:inverseOf imf:hasTerminal ] imf:Block ) .
#+END_SRC

#+NAME: shacl-elements-terminal
#+BEGIN_SRC ttl
imf:TerminalShape a sh:NodeShape ;
  sh:targetClass imf:Terminal ;
  sh:targetSubjectsOf imf:connectedTo , imf:medium , imf:hasTerminalQualifier ;
  sh:targetObjectsOf imf:hasTerminal, imf:connectedTo ;
  sh:property
    [ sh:path imf:partOf ; sh:maxCount 1 ; sh:class imf:Terminal ; sh:message "The Terminal has more than one parent." ] ,
    [ sh:path imf:connectedTo ; sh:maxCount 1 ; sh:class imf:Terminal ; sh:message "The Terminal is connected to more than one Terminal." ] ,
    [ sh:path imf:connectedTo ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "The Terminal has no connection (to a different Terminal)." ] ,
    #[ sh:path imf:hasTerminalQualifier ; sh:maxCount 1 ; sh:in ( imf:inputFlow imf:outputFlow ) ] ,
    [ sh:path imf:medium ; sh:maxCount 1 ; sh:nodeKind sh:IRI ; sh:message "The Terminal has more than one medium." ]  ,
    [ sh:path imf:medium ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "The Terminal has no medium." ] ,
    [ sh:path rdf:type ; sh:minCount 1 ; sh:class imf:TerminalType; sh:severity sh:Warning ; sh:message "The Terminal has no TerminalType." ] ;
  skos:changeNote
    "0.2.0 :: Added" ,
  """0.2.1 :: Changed: 
- Set nodeKind
- Add warning on missing TerminalType"""
.
#+END_SRC

*** ~medium~

#+NAME: owl-elements-relations-hasmedium
#+BEGIN_SRC ttl
imf:medium a owl:ObjectProperty  ;
  skos:prefLabel "medium" ;
  vs:term_status "testing" ;
  skos:definition "[medium] is an [external reference] that relates a [Terminal] *T* to a resource *X* to specify that *X* is the medium that flows through *T*." ;
  skos:example """[medium] is typically used to relate a [Terminal] to a resource that specifies one of the following:

  - Material (Fluid, Solids),
  - Energy (Mechanical, Electrical, Thermal),
  - Force (Mechanical),
  - Information(Electrical, Optical, Wireless)
""" ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subPropertyOf imf:externalReference ;
  rdfs:domain imf:Terminal ;
  .
#+END_SRC

*** ~connectedTo~

#+NAME: owl-elements-relations-connectedTo
#+BEGIN_SRC ttl
imf:connectedTo a owl:ObjectProperty ;
  skos:prefLabel "connected to" ;
  vs:term_status "testing" ;
  skos:definition "[connected to] is an [associative relation] and an [intra-aspect relation] that relates a [Terminal] *T1* to a [Terminal] *T2* to specify that *T1* is connected to *T2*. [connected to] specifies a topology of [Block]s by relating the [Terminal]s of [Block]s.";
  skos:scopeNote """[connected to] is used for describing how [Block]s are interconnected and indicates how they interact, i.e., how the [medium] of the connected [Terminal] flows between [Block]s.

[connected to] is a 1-1 relationship: a [Terminal] may only be [connected to] one other [Terminal], that is, a [Terminal] may not be [connected to] multiple [Terminal]s and it may not be [connected to] itself.

[connected to] is visualised with a line between the [Terminal]s.
""" ;
  foaf:depiction <http://ns.imfid.org/20230630/img/visualisation-connectedTo.jpg> ;
  skos:changeNote
    "0.1.0 :: Added" ,
    "0.2.0 :: Changed IRI from imf:isConnectedTo to imf:connectedTo." ;
  skos:editorialNote "Should connectedTo be symmetric?" ;
  vann:termGroup "elements" ;
  a owl:FunctionalProperty ;
  a owl:InverseFunctionalProperty ;
  a owl:IrreflexiveProperty ;
  rdfs:subPropertyOf imf:intraAspectRelation , imf:associativeRelation ;
  rdfs:domain imf:Terminal ;
  rdfs:range imf:Terminal ;
  .
#+END_SRC

*** TerminalQualifier

#+NAME: owl-elements-direction
#+BEGIN_SRC ttl
imf:TerminalQualifier a owl:Class ;
  skos:prefLabel "Terminal Qualifier" ;
  vs:term_status "testing" ;
  skos:definition "[Terminal Qualifier] is a feature or characteristic of a [Terminal]." ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  .

imf:inputFlow a owl:NamedIndividual, imf:TerminalQualifier ;
  skos:prefLabel "input flow" ;
  vs:term_status "testing" ;
  skos:definition "[input flow] is a [Terminal Qualifier] that indicates that the flow is incoming to the [Terminal] it qualifies." ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
.

imf:outputFlow a owl:NamedIndividual, imf:TerminalQualifier ;
  skos:prefLabel "output flow" ;
  vs:term_status "testing" ;
  skos:definition "[output flow] is a [Terminal Qualifier] that indicates that the flow is outgoing from the [Terminal] it qualifies." ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  .

[] ottr:of o-owl-ax:DifferentIndividuals ;
   ottr:values ( ( imf:inputFlow imf:outputFlow ) ) .

imf:hasTerminalQualifier a owl:ObjectProperty ;
  skos:prefLabel "has terminal qualifier" ;
  vs:term_status "testing" ;
  skos:definition "[has terminal qualifier] relates a [Terminal] *T* to a [Terminal Qualifier] *Q* to specify that *T* has the qualifier *Q*." ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:domain imf:Terminal ;
  rdfs:range imf:TerminalQualifier .
#+END_SRC

*** ~Input/OutputTerminal~

#+NAME: owl-elements-inputoutputTerminal
#+BEGIN_SRC ttl
imf:InputTerminal a owl:Class ;
  skos:prefLabel "Input Terminal" ;
  skos:altLabel "Input" ;
  vs:term_status "testing" ;
  skos:definition "An [Input Terminal] is a [Terminal] that accepts input (and not output)." ;
  skos:scopeNote "An [Input Terminal] is equivalent to a [Terminal] that has the [Terminal Qualifier] [input flow].";
  skos:changeNote
    "0.1.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subClassOf imf:Terminal ;
  .

[] ottr:of o-owl-ax:EquivHasValue ;
   ottr:values ( imf:InputTerminal imf:hasTerminalQualifier imf:inputFlow ) .

imf:OutputTerminal a owl:Class ;
  skos:prefLabel "Output Terminal" ;
  skos:altLabel "Output" ;
  vs:term_status "testing" ;
  skos:definition "An [Output Terminal] is a [Terminal] that accepts output (and not input)." ;
  skos:scopeNote "An [Output Terminal] is equivalent to a [Terminal] that has the [Terminal Qualifier] [output flow].";
  skos:changeNote
    "0.1.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subClassOf imf:Terminal ;
  .

[] ottr:of o-owl-ax:EquivHasValue ;
   ottr:values ( imf:OutputTerminal imf:hasTerminalQualifier imf:outputFlow ) .

imf:hasInputTerminal a owl:ObjectProperty ;
  skos:prefLabel "has input terminal" ;
  vs:term_status "testing" ;
  skos:definition "[has input terminal] specialises the [has terminal] property to relate [Block]s to [InputTerminal]s." ;
  skos:changeNote
    "0.1.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subPropertyOf imf:hasTerminal ;
  rdfs:range imf:InputTerminal ;
  .

imf:hasOutputTerminal a owl:ObjectProperty ;
  skos:prefLabel "has output terminal" ;
  vs:term_status "testing" ;
  skos:definition "[has output terminal] specialises the [has terminal] property to relate [Block]s to [Output Terminal]s." ;
  skos:changeNote
    "0.1.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subPropertyOf imf:hasTerminal ;
  rdfs:range imf:OutputTerminal ;
  .
#+END_SRC

*** Association Points
**** Overview

#+NAME: plantuml-elements-w-reified
#+BEGIN_SRC plantuml :noweb yes :file out/img/imf-ontology-elements-w-reified.png
<<plantuml-elements>>

' reified relations
class BreakdownPoint
(Element, Element) .. BreakdownPoint
Element "1" <-- "1" BreakdownPoint : thePart
Element "1" <-- "1" BreakdownPoint : theWhole

class ConnectionPoint
(Terminal, Terminal) .. ConnectionPoint
Terminal "1" <-- "1" ConnectionPoint : theInput
Terminal "1" <-- "1" ConnectionPoint : theOutput
#+END_SRC

**** ~BreakdownPoint~

#+NAME: owl-elements-reifieds-breakdownpoint
#+BEGIN_SRC ttl

imf:BreakdownPoint a owl:Class ;
  skos:prefLabel "Breakdown Point (unstable)" ;
  vs:term_status "unstable" ;
  skos:scopeNote """A [Breakdown Point] represents a reified [has part]/[part of] property instance, using the properties [the whole] and [the part] to relate to the [Element]s that are related by the [has part]/[part of] property.

[Breakdown Point] has the status 'unstable'; its details are yet to be worked out.""" ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subClassOf imf:Element ;
  .

imf:thePart a owl:ObjectProperty ;
  skos:prefLabel "the part (unstable)" ;
  vs:term_status "unstable" ;
  skos:scopeNote "See [Breakdown Point]." ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  a owl:FunctionalProperty ;
  rdfs:subPropertyOf imf:intraAspectRelation, imf:associativeRelation ;
  skos:editorialNote "Is [thePart] and [theWhole] associative, hierarchical or none?" ;
  rdfs:domain imf:BreakdownPoint ;
  rdfs:range imf:Element .

imf:theWhole a owl:ObjectProperty ;
  skos:prefLabel "the whole (unstable)" ;
  vs:term_status "unstable" ;
  skos:scopeNote "See [Breakdown Point]." ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  a owl:FunctionalProperty ;
  rdfs:subPropertyOf imf:intraAspectRelation, imf:associativeRelation ;
  rdfs:domain imf:BreakdownPoint ;
  rdfs:range imf:Element .

[] ottr:of o-owl-ax:SubObjectSomeValuesFrom ;
   ottr:values ( imf:BreakdownPoint imf:thePart imf:Element ) .
[] ottr:of o-owl-ax:SubObjectSomeValuesFrom ;
   ottr:values ( imf:BreakdownPoint imf:theWhole imf:Element ) .

### Problem: gives non-simple property
#imf:partOf a owl:ObjectProperty ;
#  owl:propertyChainAxiom ( [ owl:inverseOf imf:thePart ] imf:theWhole ) .
#+END_SRC

#+NAME: shacl-elements-breakdownpoint
#+BEGIN_SRC ttl
imf:BreakdownPointShape a sh:NodeShape ;
  sh:targetClass imf:BreakdownPoint ;
  sh:targetSubjectsOf imf:thePart , imf:theWhole ;
  sh:property
    [ sh:path imf:thePart  ; sh:minCount 1 ; sh:maxCount 1 ; sh:class imf:Element ; sh:message "The Breakdown Point must have exactly one part." ] ,
    [ sh:path imf:theWhole ; sh:minCount 1 ; sh:maxCount 1 ; sh:class imf:Element ; sh:message "The Breakdown Point must have exactly one whole." ] ;
  skos:changeNote
    "0.2.0 :: Added"
.
#+END_SRC

**** ~ConnectionPoint~

#+NAME: owl-elements-reifieds-connectionpoint
#+BEGIN_SRC ttl

imf:ConnectionPoint a owl:Class ;
  skos:prefLabel "Connection Point (unstable)" ;
  vs:term_status "unstable" ;
  skos:scopeNote """A [Connection Point] represents a reified [connected to] property instance, using the property [the connected] or subproperties [the input]/[the output] to relate to the [Terminal]s that are related by the [connected to] property.

[Connection Point] has the status 'unstable'; its details are yet to be worked out.""" ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subClassOf imf:Element ;
  .

imf:theConnected a owl:ObjectProperty ;
  skos:prefLabel "the connected (unstable)" ;
  vs:term_status "unstable" ;
  skos:scopeNote "See [Connection Point]." ;
  rdfs:subPropertyOf imf:intraAspectRelation, imf:associativeRelation ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:domain imf:ConnectionPoint ;
  rdfs:range imf:Terminal .

[] ottr:of o-owl-ax:SubObjectExactCardinality ;
   ottr:values( imf:ConnectionPoint "2"^^xsd:nonNegativeInteger imf:theConnected imf:Element ) .
[] ottr:of o-owl-ax:SubObjectMaxCardinality ;
   ottr:values( imf:ConnectionPoint "1"^^xsd:nonNegativeInteger imf:theInput imf:Element ) .
[] ottr:of o-owl-ax:SubObjectMaxCardinality ;
   ottr:values( imf:ConnectionPoint "1"^^xsd:nonNegativeInteger imf:theOutput imf:Element ) .

imf:theInput a owl:ObjectProperty ;
  skos:prefLabel "the input (unstable)" ;
  vs:term_status "unstable" ;
  skos:scopeNote "See [Connection Point]." ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subPropertyOf imf:theConnected ;
  rdfs:range imf:OutputTerminal .

imf:theOutput a owl:ObjectProperty ;
  skos:prefLabel "the output (unstable)" ;
  vs:term_status "unstable" ;
  skos:scopeNote "See [Connection Point]." ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subPropertyOf imf:theConnected ;
  rdfs:range imf:InputTerminal .

### Problem: gives non-simple property
#imf:connectedTo a owl:ObjectProperty ;
#  owl:propertyChainAxiom ( imf:theOutput [ owl:inverseOf imf:theInput ] ) .
#+END_SRC

#+NAME: shacl-elements-connectionpoint
#+BEGIN_SRC ttl
imf:ConnectionPointShape a sh:NodeShape ;
  sh:targetClass imf:ConnectionPoint ;
  sh:targetSubjectsOf imf:theConnected , imf:theInput , imf:theOutput ;
  sh:property
    [ sh:path imf:theInput  ; sh:maxCount 1 ; sh:class imf:Element ; sh:message "The Connection Point has more than one input." ] ,
    [ sh:path imf:theOutput ; sh:maxCount 1 ; sh:class imf:Element ; sh:message "The Connection Point has more than one output." ] ,
    [ sh:path imf:theConnected ; sh:maxCount 2 ; sh:class imf:Element ; sh:message "The Connection Point has more than two connected." ] ;
  skos:changeNote
    "0.2.0 :: Added"
.
#+END_SRC

** Aspects

#+NAME: plantuml-aspect-elements
#+BEGIN_SRC plantuml :noweb yes :file out/owl/imf-ontology-aspects.png
<<plantuml-style>>

abstract class AspectElement
abstract class Element

Element <|-- AspectElement

enum Aspect {
  Function
  Location
  Product
  Installed
}

AspectElement "*" --> "1" Aspect : hasAspect

Element --> Element : intraAspectRelation
Element --> Element : interAspectRelation
#+END_SRC

#+ATTR_LATEX: :width 6cm
#+RESULTS: plantuml-aspect-elements
[[file:out/owl/imf-ontology-aspects.png]]

*** ~AspectElement~

#+NAME: owl-aspects-aspectelement
#+BEGIN_SRC ttl
imf:AspectElement a owl:Class ;
  skos:prefLabel "Aspect Element";
  skos:definition "An [Aspect Element] is an [Element] that has exactly one [Aspect]." ;
  skos:scopeNote """Avoid direct instantiation of [Aspect Element], use instead one of its subclasses.

The [Aspect] of an [Aspect Element] is visualised by filling the shape of the [Element] with the color of the [Aspect].
""" ;
  vs:term_status "testing" ;
  foaf:depiction <http://ns.imfid.org/20230630/img/imf-ontology-aspects.png> ;
  skos:changeNote
    "0.1.0 :: Added" ;
  vann:termGroup "aspects" ;

  # an aspect element is an element with an aspect:
  owl:equivalentClass [
    rdf:type owl:Class ;
    owl:intersectionOf (
      imf:Element
      [ rdf:type owl:Restriction ;
	owl:onProperty imf:hasAspect ;
	owl:qualifiedCardinality "1"^^xsd:nonNegativeInteger ;
	owl:onClass imf:Aspect
      ]
  ) ]
  .

imf:hasAspect a owl:ObjectProperty ;
  skos:prefLabel "has aspect" ;
  vs:term_status "testing" ;
  skos:definition "[has aspect] is a relation from an [Element] *E* to an [Aspect] *A* that specifies that *E* has the [Aspect] *A*." ;
  skos:changeNote
    "0.1.0 :: Added" ;
  vann:termGroup "aspects" ;
  rdfs:domain imf:Element ;
  rdfs:range imf:Aspect .
#+END_SRC

#+NAME: shacl-aspect-aspectelement
#+BEGIN_SRC ttl
imf:AspectElementShape a sh:NodeShape ;
  sh:targetClass imf:AspectElement ;
  sh:targetSubjectsOf imf:hasAspect ;
  sh:property
    [ sh:path imf:hasAspect ; sh:minCount 1 ; sh:maxCount 1 ; sh:class imf:Aspect ; sh:message "The AspectElement must have exactly one Aspect." ]  ;
  skos:changeNote
    "0.2.0 :: Added"
.
#+END_SRC

*** ~Aspect~

#+NAME: owl-aspects-aspect
#+BEGIN_SRC ttl
imf:Aspect a owl:Class ;
  skos:prefLabel "Aspect" ;
  vs:term_status "testing" ;
  skos:definition """An [Aspect] describes a context for interpreting [Element]s. An [Aspect] specifies a *perspective*, an *interest*, and a *modality*.

 - *Perspective* refers to from which viewpoint the [Element] is interpreted.
 - *Interest* refers to the scope for which the information is intended used.
 - *Modality* refers to the form in which information is recorded.
""" ;
 skos:note "Aspect is a core concept of ISO/IEC 81346 and the IMF ontology includes aspects that are found in ISO/IEC 81346: function, location and product. We anticipate that more aspects will be added to support future modelling needs." ;
  skos:example "For examples, see the instances of [Aspect] defined in this ontology, e.g., [function aspect]." ;
  skos:changeNote
    "0.1.0 :: Added" ;
  vann:termGroup "aspects" ;
  .

imf:prefix a owl:AnnotationProperty ;
  skos:prefLabel "prefix" ;
  vs:term_status "testing" ;
  skos:definition "[prefix] is a relation from an [Aspect] *A* to a string *s* to specify that *s* is the prefix associated with *A*. Such prefix strings are typically used for identifying the aspect when constructing reference designation system (RDS) identifiers." ;
  skos:example "For examples, see the instances of [Aspect] defined in this ontology, e.g., [function aspect]." ;
  skos:changeNote
    "0.1.0 :: Added" ;
  vann:termGroup "aspects" ;
  rdfs:domain imf:Aspect ;
  rdfs:range xsd:string ;
  .

imf:color a owl:AnnotationProperty ;
  skos:prefLabel "color" ;
  vs:term_status "testing" ;
  skos:definition "[color] is a relation from a resource *X* to a string identifying a hexadecimal color *c* to specify that the *c* is a color that is associated with *A*.";
  skos:scopeNote "[Aspect]s are often associated with a distinct color, which is used in graphical presentations of IMF data." ;
  skos:example "For examples, see the instances of [Aspect] defined in this ontology, e.g., [function aspect]." ;
  skos:changeNote
    "0.1.0 :: Added" ;
  vann:termGroup "aspects" ;
  rdfs:range xsd:string
  .

#+END_SRC

#+NAME: owl-aspects-relations
#+BEGIN_SRC ttl
imf:intraAspectRelation a owl:ObjectProperty ;
  skos:prefLabel "intra-aspect relation" ;
  skos:definition "[intra-aspect relation] a generic relation between [Element]s *E1* and *E2* such that *E1* and *E2* share at least one [Aspect]." ;
  skos:scopeNote "[intra-aspect relations] is not used directly, rather use one of its subproperties. An [intra-aspect relation] is used to relate [Element]s that represent different (but related) systems/system elements within the same [Aspect]." ;
  vs:term_status "testing" ;
  skos:changeNote
    "0.1.0 :: Added" ;
  vann:termGroup "aspects" ;
  rdfs:domain imf:Element ;
  rdfs:range imf:Element ;
  .

#[] ottr:of o-owl-ax:SubObjectAllValuesFrom ;
#   ottr:values ( imf:AspectElement imf:intraAspectRelation imf:AspectElement ) .

imf:interAspectRelation a owl:ObjectProperty ;
  skos:prefLabel "inter-aspect relation" ;
  skos:definition "[inter-aspect relation] a generic relation between [Element]s *E1* and *E2* such that *E1* and *E2* do not share any [Aspect]s." ;
  skos:scopeNote "[inter-aspect relations] is not used directly, rather use one of its subproperties. An [inter-aspect relation] is used to relate [Element]s that represent the same system/system element, but in different [Aspect]s." ;
  vs:term_status "testing" ;
  skos:changeNote
    "0.1.0 :: Added" ;
  vann:termGroup "aspects" ;
  rdfs:domain imf:Element ;
  rdfs:range imf:Element ;
  owl:propertyDisjointWith imf:intraAspectRelation ;
  .
#+END_SRC

*** Aspects

This is the current list of aspects:

#+NAME: tbl-aspects
| Aspect, IRIs        | Prefix, string | Color, string | Definition                                                                                                                                                                                                                                                 |
|---------------------+----------------+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| imf:functionAspect  | '='            | '#FFFF00'     | '[function aspect] is an [Aspect] about the intended activity of [Element]s, i.e., the activity an [Element] performs or is designed to bring about. [function aspect] has *perspective* \"Activity\", *interest* \"System design\", and *modality* \"Specification\".' |
| imf:locationAspect  | '+'            | '#FF00FF'     | '[location aspect] is an [Aspect] about the spatial envelope (e.g., geometry, size and shape) of [Element]s. [location aspect] has *perspective* \"Location\", *interest* \"Geometry and Position\", and *modality* \"Specification\".'           |
| imf:productAspect   | '-'            | '#00FFFF'     | '[product aspect] is an [Aspect] about the specification of a (physical) solution/implementation of [Element]s. [product aspect] has *perspective* \"Artefact\", *interest* \"Built\", and *modality* \"Specification\".'                          |
| imf:installedAspect | '::'           | '#0000FF'     | '[installed aspect] is an [Aspect] about the information of [Element] instances. [installed aspect] has *perspective* \"Artefact\", *interest* \"Built\", and *modality* \"Description of individual\".'                                         |

**** Processing                                                          :QA:

#+BEGIN_SRC ttl :noweb strip-export :tangle out/ottr/imf-ontology/aspects.stottr :mkdirp yes
<<prefixes>>

## This creates an individual for each of the aspects in the table.
o-imf:Aspect [owl:NamedIndividual ?aspect, xsd:string ?label, xsd:string ?symbol, xsd:string ?color, xsd:string ?definition] :: {
  o-rdf:Type(?aspect, imf:Aspect) ,
  o-rdf:Type(?aspect, owl:NamedIndividual) ,
  ottr:Triple(?aspect, imf:prefix, ?symbol),
  ottr:Triple(?aspect, imf:color, ?color),
  ottr:Triple(?aspect, skos:prefLabel, ?label),
  ottr:Triple(?aspect, skos:definition, ?definition),
  ottr:Triple(?aspect, vs:term_status, "testing"),
  ottr:Triple(?aspect, skos:changeNote, "0.1.0 :: Added"),
  ottr:Triple(?aspect, skos:changeNote, "0.2.0 :: Changed: use lowerCamelCase for localname of IRI.")
  ottr:Triple(?aspect, vann:termGroup, "aspects")
} .

o-imf:AspectClass [owl:Class ?class, xsd:string ?label, owl:NamedIndividual ?aspect] :: {
  o-owl-ax:SubClassOf(?class, imf:AspectElement),
  ottr:Triple(?class, skos:prefLabel, ?label),
  o-owl-ax:EquivObjectHasValue(?class, imf:hasAspect, ?aspect),
  o-owl-ax:SubObjectAllValuesFrom(?class, imf:intraAspectRelation, ?class),
  o-imf:GeneratedNote(?class)
} .

o-imf:AspectElementClass [owl:Class ?class, xsd:string ?label, owl:Class ?aspectClass, owl:Class ?elementClass] :: {
  o-owl-ax:EquivObjectIntersectionOf(?class, ( ?aspectClass, ?elementClass ) )
  ottr:Triple(?class, skos:prefLabel, ?label),
  o-owl-ax:SubClassOf(?class, ?aspectClass),
  o-owl-ax:SubClassOf(?class, ?elementClass),
  o-imf:GeneratedNote(?class)
} .

o-imf:InterAspectRelation [owl:ObjectProperty ?property, xsd:string ?label, owl:Class ?aspectClass] :: {
  o-rdf:Type(?property, owl:ObjectProperty),
  ottr:Triple(?property, skos:prefLabel, ?label),
  o-owl-ax:SubPropertyOf(?property, imf:interAspectRelation),
  o-rdfs:Range(?property, ?aspectClass),
  o-imf:GeneratedNote(?property)
} .

o-imf:GeneratedNote [ottr:IRI ?resource] :: {
  ottr:Triple(?resource, skos:note, "This resource is programatically generated. Please consult its defining resources for textual descriptions."),
  ottr:Triple(?resource, vs:term_status, "testing"),
  ottr:Triple(?resource, vann:termGroup, "aspects")
} .
#+END_SRC

#+NAME: py_aspect_ottr_instances_aspects
#+BEGIN_SRC python :results raw :wrap src ttl :var table=tbl-aspects :exports none
output = ""

instance = "[] ottr:of {} ;\n   ottr:values( {} ) . \n"

## aspects
for row in table[0:]:
  aspectName = row[0].replace("imf:", "", ).replace('Aspect', ' aspect')
  row.insert(1, "'" + aspectName + "'")
  output += instance.format("o-imf:Aspect", " ".join(f'{w}' for w in row))

output += "\n"

all_aspects = list(zip(*table[0:]))[0]
all_systemelements = [ 'Block', 'Terminal' ]

## aspects are different
output += instance.format("o-owl-ax:DifferentIndividuals", "( " + " ".join(all_aspects) + " )")

output += "\n"

## Create a class that represents all elements of a given aspect
for aspect in all_aspects:
  aspectName = aspect.replace("imf:", "", ).replace('Aspect', '').capitalize()
  output += instance.format("o-imf:AspectClass", "imf:" + aspectName + "Element '" + aspectName + " Element' " + aspect)

output += "\n"

## create a class of each aspect, element type combination, e.g., FunctionBlock.
for aspect in all_aspects:
  for element in all_systemelements:
    aspectName = aspect.replace("imf:", "", ).replace('Aspect', '').capitalize()
    output += instance.format("o-imf:AspectElementClass", "imf:" + aspectName + element + " '" + aspectName + " " + element + "' imf:" + aspectName  + "Element imf:" + element)

output += "\n"

## Create a object property for each aspect
for aspect in all_aspects:
  aspectName = aspect.replace("imf:", "", ).replace('Aspect', '').capitalize()
  output += instance.format("o-imf:InterAspectRelation", "imf:as" + aspectName + " 'as " + aspectName.lower() + "' imf:" + aspectName + "Element")

output += "\n"

return output
#+END_SRC

#+RESULTS: py_aspect_ottr_instances_aspects
#+BEGIN_src ttl
[] ottr:of o-imf:Aspect ;
   ottr:values( imf:functionAspect 'function aspect' '=' '#FFFF00' '[function aspect] is an [Aspect] about the intended activity of [Element]s, i.e., the activity an [Element] perfoms or is designed to bring about. [function aspect] has /perspective/ \"Activity\", /interest/ \"System design\", and /modality/ \"Specification\".' ) .
[] ottr:of o-imf:Aspect ;
   ottr:values( imf:locationAspect 'location aspect' '+' '#FF00FF' '[location aspect] is an [Aspect] about the spatial envelope (e.g., geometry, size and shape) of [Element]s. [location aspect] has /perspective/ \"Location\", /interest/ \"Geometry and Position\", and /modality/ \"Specification\".' ) .
[] ottr:of o-imf:Aspect ;
   ottr:values( imf:productAspect 'product aspect' '-' '#00FFFF' '[product aspect] is an [Aspect] about the specification of a (physical) solution/implementation of [Element]s. [product aspect] has /perspective/ \"Artefact\", /interest/ \"Built\", and /modality/ \"Specification\".' ) .
[] ottr:of o-imf:Aspect ;
   ottr:values( imf:installedAspect 'installed aspect' '::' '#0000FF' '[installed aspect] is an [Aspect] about the information of [element] instances. [installed aspect] has /perspective/ \"Artefact\", /interest/ \"Built\", and /modality/ \"Description of individual\".' ) .

[] ottr:of o-owl-ax:DifferentIndividuals ;
   ottr:values( ( imf:functionAspect imf:locationAspect imf:productAspect imf:installedAspect ) ) .

[] ottr:of o-imf:AspectClass ;
   ottr:values( imf:FunctionElement 'Function Element' imf:functionAspect ) .
[] ottr:of o-imf:AspectClass ;
   ottr:values( imf:LocationElement 'Location Element' imf:locationAspect ) .
[] ottr:of o-imf:AspectClass ;
   ottr:values( imf:ProductElement 'Product Element' imf:productAspect ) .
[] ottr:of o-imf:AspectClass ;
   ottr:values( imf:InstalledElement 'Installed Element' imf:installedAspect ) .

[] ottr:of o-imf:AspectElementClass ;
   ottr:values( imf:FunctionBlock 'Function Block' imf:FunctionElement imf:Block ) .
[] ottr:of o-imf:AspectElementClass ;
   ottr:values( imf:FunctionTerminal 'Function Terminal' imf:FunctionElement imf:Terminal ) .
[] ottr:of o-imf:AspectElementClass ;
   ottr:values( imf:LocationBlock 'Location Block' imf:LocationElement imf:Block ) .
[] ottr:of o-imf:AspectElementClass ;
   ottr:values( imf:LocationTerminal 'Location Terminal' imf:LocationElement imf:Terminal ) .
[] ottr:of o-imf:AspectElementClass ;
   ottr:values( imf:ProductBlock 'Product Block' imf:ProductElement imf:Block ) .
[] ottr:of o-imf:AspectElementClass ;
   ottr:values( imf:ProductTerminal 'Product Terminal' imf:ProductElement imf:Terminal ) .
[] ottr:of o-imf:AspectElementClass ;
   ottr:values( imf:InstalledBlock 'Installed Block' imf:InstalledElement imf:Block ) .
[] ottr:of o-imf:AspectElementClass ;
   ottr:values( imf:InstalledTerminal 'Installed Terminal' imf:InstalledElement imf:Terminal ) .

[] ottr:of o-imf:InterAspectRelation ;
   ottr:values( imf:asFunction 'as function' imf:FunctionElement ) .
[] ottr:of o-imf:InterAspectRelation ;
   ottr:values( imf:asLocation 'as location' imf:LocationElement ) .
[] ottr:of o-imf:InterAspectRelation ;
   ottr:values( imf:asProduct 'as product' imf:ProductElement ) .
[] ottr:of o-imf:InterAspectRelation ;
   ottr:values( imf:asInstalled 'as installed' imf:InstalledElement ) .

#+END_src

*** Inter-aspect Relations

#+NAME: plantuml-aspect-element-interaspect
#+BEGIN_SRC plantuml :noweb yes :file out/img/overview-aspect-element-interaspect.png
<<plantuml-style>>

<<py_aspectelement_interaspect_rels()>>
#+END_SRC

#+RESULTS: plantuml-aspect-element-interaspect
[[file:out/img/plantuml-aspect-element-interaspect.png]]


*** ~AspectElement~ specialisations

#+NAME: plantuml-aspect-element-subs
#+BEGIN_SRC plantuml :noweb yes :file out/img/imf-overview-aspect-element-subs.png
<<plantuml-style>>

<<py_aspectelement_interaspect_rels()>>
<<py_aspectelement_subs()>>
#+END_SRC

#+RESULTS: plantuml-aspect-element-subs
[[file:out/img/imf-overview-aspect-element-subs.png]]

**** Processing                                                          :QA:

#+NAME: py_aspectelement_interaspect_rels
#+BEGIN_SRC python :var table=tbl-aspects :exports none
output = ""

for row in table:
  aspect = row[0].replace("imf:","").replace("Aspect", "").capitalize()
  color = row[2].replace("'","").replace("#","")

  ae = aspect + "Element"

  output += "class " + ae + " #back:" + color + "\n"
  output += "AspectElement --> " + ae + " : as" + aspect + "\n"
  output += "AspectElement <|-- " + ae + " \n"

return output
#+END_SRC

#+RESULTS: py_aspectelement_interaspect_rels
#+begin_example
class FunctionElement #back:FFFF00
AspectElement --> FunctionElement : asFunction
AspectElement <|-- FunctionElement
class LocationElement #back:FF00FF
AspectElement --> LocationElement : asLocation
AspectElement <|-- LocationElement
class ProductElement #back:00FFFF
AspectElement --> ProductElement : asProduct
AspectElement <|-- ProductElement
class InstalledElement #back:0000FF
AspectElement --> InstalledElement : asInstalled
AspectElement <|-- InstalledElement
#+end_example


#+NAME: py_aspectelement_subs
#+BEGIN_SRC python :var table=tbl-aspects :exports none
output = ""

for row in table:
  aspect = row[0].replace("imf:","").replace("Aspect", "").capitalize()
  color = row[2].replace("'","").replace("#","")

  for element in ['Block', 'Terminal']:
    ae = aspect + element

    output += "class " + ae + " #back:" + color + "\n"
    output += element + " <|-- " + ae + "\n"
    output += aspect + "Element <|-- " + ae + "\n"

output += "\n"
return output
#+END_SRC

#+RESULTS: py_aspectelement_subs
#+begin_example
class FunctionBlock #back:FFFF00
Block <|-- FunctionBlock
FunctionElement <|-- FunctionBlock
class FunctionTerminal #back:FFFF00
Terminal <|-- FunctionTerminal
FunctionElement <|-- FunctionTerminal
class LocationBlock #back:FF00FF
Block <|-- LocationBlock
LocationElement <|-- LocationBlock
class LocationTerminal #back:FF00FF
Terminal <|-- LocationTerminal
LocationElement <|-- LocationTerminal
class ProductBlock #back:00FFFF
Block <|-- ProductBlock
ProductElement <|-- ProductBlock
class ProductTerminal #back:00FFFF
Terminal <|-- ProductTerminal
ProductElement <|-- ProductTerminal
class InstalledBlock #back:0000FF
Block <|-- InstalledBlock
InstalledElement <|-- InstalledBlock
class InstalledTerminal #back:0000FF
Terminal <|-- InstalledTerminal
InstalledElement <|-- InstalledTerminal
#+end_example

** Attributes
*** Overview

#+NAME: plantuml-attributes
#+BEGIN_SRC plantuml :noweb yes :file out/owl/imf-ontology-attributes.png
<<plantuml-style>>

abstract class Element

Element *--> "*" Attribute : hasAttribute

'Element *--> "*" AttributeGroup : hasAttributeGroup

'AttributeGroup *--> "*" Attribute : hasAttribute

'
'class AttributeGroup {
' name : 0..1
' description : 0..1
'}


class Attribute {
 name : 0..1
 description : 0..1
 value : 1..*
}

class UoM << RDL >>
class RDLItem <<RDL >>

Attribute "*" --> "0..1" UoM : uom
Attribute "*" --> "1" RDLItem : predicate

Attribute "*" --> "0..1" Provenance : hasAttributeQualifier
Attribute "*" --> "0..1" Range : hasAttributeQualifier
Attribute "*" --> "0..1" Regularity : hasAttributeQualifier
Attribute "*" --> "0..1" Scope : hasAttributeQualifier

''' Qualifiers

class AttributeQualifier

AttributeQualifier <|-- Provenance
AttributeQualifier <|-- Range
AttributeQualifier <|-- Regularity
AttributeQualifier <|-- Scope

enum Provenance {
  calculated
  measured
  specified
}
enum Range {
  average
  maximum
  minimum
  nominal
  normal
}
enum Regularity {
  absolute
  continuous
}
enum Scope {
  design
  operating
}
#+END_SRC

#+ATTR_LATEX: :width 12cm
#+RESULTS: plantuml-attributes
[[file:out/owl/imf-ontology-attribute.png]]

*** ~Attribute~

#+NAME: owl-attributes-value
#+BEGIN_SRC ttl
imf:Attribute a owl:Class ;
  skos:prefLabel "Attribute" ;
  vs:term_status "testing" ;
  skos:definition "An [Attribute] describes a quality, property or characteristic of a resource by setting a [predicate], a [value], and optionally a [unit of measure]. An [Attribute] may be qualified by [Attribute Qualifier]s." ;
  skos:example "Specified color: red." , "Measured weight: 1250 kg." , "Maximum ambient operating temperature: 120 K." ;
  foaf:depiction <http://ns.imfid.org/20230630/img/imf-ontology-attributes.png> ;
  skos:changeNote
    "0.2.0 :: Added" ,
    "0.2.1 :: Changed: add axioms that specify that an [Attribute] has a [value] and a [predicate] and is the [Attribute], via [has attibute], for some [Element]." ;
  vann:termGroup "attributes" ;
  .

[] ottr:of o-owl-ax:SubDataSomeValuesFrom ;
   ottr:values (imf:Attribute imf:value rdfs:Literal ) .
[] ottr:of o-owl-ax:SubObjectSomeValuesFrom ;
   ottr:values (imf:Attribute imf:predicate owl:Thing ) .
[] ottr:of o-owl-ax:SubObjectSomeValuesFrom ;
   ottr:values (imf:Attribute [ owl:inverseOf imf:hasAttribute ] imf:Element ) .


imf:hasAttribute a owl:ObjectProperty ;
  skos:prefLabel "has attribute" ;
  vs:term_status "testing" ;
  skos:definition "[has attribute] is a relation between an [Element] *E* and an [Attribute] *A* that specifies that *E* has the attribute *A*." ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "attributes" ;
  rdfs:domain imf:Element ;
  rdfs:range  imf:Attribute .

imf:predicate a owl:ObjectProperty ;
  skos:prefLabel "predicate" ;
  vs:term_status "testing" ;
  skos:definition "[predicate] is an [external reference] that relates an [Attribute] *A* to a resource *X* to specify that *A* has the predicate *X*." ;
  skos:example "The [predicate] of an [Attribute] \"Weight: 1250 kg\" could be expressed as WEIGHT <http://data.posccaesar.org/rdl/RDS356894>." ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "attributes" ;
  rdfs:subPropertyOf imf:externalReference ;
  rdfs:domain imf:Attribute .

imf:uom a owl:ObjectProperty ;
  skos:prefLabel "unit of measure" ;
  skos:altLabel "uom" ;
  vs:term_status "testing" ;
  skos:definition "[unit of measure] is an [external reference] that relates an [Attribute] *A* to a resource *X* to specify that *A* has the unit of measure *X*." ;
  skos:example "The [unit of measure] of an [Attribute] \"Weight: 1250 kg\" could be expressed as KILOGRAM <http://data.posccaesar.org/rdl/RDS1328669>." ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "attributes" ;
  rdfs:subPropertyOf imf:externalReference ;
  rdfs:domain imf:Attribute .

imf:value a owl:DatatypeProperty ;
  skos:prefLabel "value" ;
  vs:term_status "testing" ;
  skos:definition "[value] relates an [Attribute] *A* to literal value *v* to specify that *A* has the value *v*." ;
  skos:example "The [value] of an [Attribute] \"Weight: 1250 kg\" could be expressed as the literal `\"1250\"^^xsd:integer` (or using a different appropriate literal datatype)." ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "attributes" ;
  rdfs:domain imf:Attribute
.
#+END_SRC

#+NAME: shacl-attributes-value
#+BEGIN_SRC ttl
imf:AttributeShape a sh:NodeShape ;
  sh:targetClass imf:Attribute ;
  sh:targetObjectsOf imf:hasAttribute ;
  sh:targetSubjectsOf imf:predicate, imf:uom, imf:hasAttributeQualifier ;
  sh:property
    [ sh:path imf:predicate ; sh:minCount 1 ; sh:maxCount 1 ; sh:nodeKind sh:IRI ; sh:message "The Attribute must have exactly one predicate." ] ,
    [ sh:path imf:value ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "The Attribute has no value." ] ,
    [ sh:path imf:uom ; sh:maxCount 1 ] ,
    [ sh:path imf:hasAttributeQualifier ; sh:qualifiedMaxCount 1 ; sh:qualifiedValueShape [ sh:class imf:RegularityQualifier ] ; sh:message "The Attribute has more than one regularity qualifier." ] ,
    [ sh:path imf:hasAttributeQualifier ; sh:qualifiedMaxCount 1 ; sh:qualifiedValueShape [ sh:class imf:RangeQualifier ] ;      sh:message "The Attribute has more than one range qualifier." ] ,
    [ sh:path imf:hasAttributeQualifier ; sh:qualifiedMaxCount 1 ; sh:qualifiedValueShape [ sh:class imf:ProvenanceQualifier ] ; sh:message "The Attribute has more than one provenance qualifier." ] ,
    [ sh:path imf:hasAttributeQualifier ; sh:qualifiedMaxCount 1 ; sh:qualifiedValueShape [ sh:class imf:ScopeQualifier ] ;      sh:message "The Attribute has more than one scope qualifier." ] ,
    [ sh:path imf:hasAttributeQualifier ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "The Attribute has no qualifier." ] ;
  skos:changeNote
    "0.2.0 :: Added" ,
    """0.2.1 :: Changed: 
- fix bug: for each attribute qualifier, change maxCount to qualifiedMaxCount and qualifiedValueShape.
- add nodeKinds to fit type of the path's property."""
.
#+END_SRC

*** ~AttributeGroup~                                               :noexport:

#+NAME: owl-attributes-group
#+BEGIN_SRC ttl
imf:AttributeGroup a owl:Class ;
  skos:prefLabel "Attribute Group" ;
  vs:term_status "testing" ;
  skos:definition "An [Attribute Group] is a collection of [Attribute]s which are typically grouped for convenience as they describe closely related features or characteristics of a resource." ;
  skos:example "The physical dimensions of a product, e.g., its length, width and height, could be grouped by an [Attribute Group]." ;
  skos:editorialNote "Does an [Attribute Group] add any semantics? -- what is the difference from an [Attribute Group] and an [Element] with [Attribute]s?" ;
  skos:changeNote
    "0.2.0 :: Added" ;
  .

imf:hasAttributeGroup a owl:ObjectProperty ;
  skos:prefLabel "has attribute group" ;
  vs:term_status "testing" ;
  skos:definition "[has attribute group] is a relation between a resource *X* and an [Attribute Group] *A* that specifies that *X* has the attribute group *A*." ;
  skos:editorialNote "See comment on [Attribute Group], does [has attribute group] represent a \"long-hand property\" meaning that attaching the Attributes of the Attribute Group directly is equivalent? Perhaps the functionality of [Attribute Group]s is best realised as aspect-less-types?" ;
  skos:changeNote
    "0.2.0 :: Added" ;
  rdfs:range imf:AttributeGroup .
#+END_SRC

#+NAME: shacl-attributes-group
#+BEGIN_SRC ttl
imf:AttributeGroupShape a sh:NodeShape ;
  sh:targetClass imf:AttributeGroup ;
  sh:targetObjectsOf imf:hasAttributeGroup ;
  sh:property
    [ sh:path imf:hasAttribute ; sh:minCount 1 ; sh:message "AttributeGroup has no Attributes." ] ;
  skos:changeNote
    "0.2.0 :: Added"
.
#+END_SRC


*** ~AttributeQualifier~

#+NAME: owl-attributes-qualifier
#+BEGIN_SRC ttl
imf:AttributeQualifier a owl:Class ;
  skos:prefLabel "Attribute Qualifier" ;
  vs:term_status "testing" ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "attributes" ;
  .

imf:hasAttributeQualifier a owl:ObjectProperty ;
  skos:prefLabel "has attribute qualifier" ;
  vs:term_status "testing" ;
  skos:definition "[has attribute qualifier] is a relation between an [Attribute] *A* and an [Attribute Qualifier] *Q* to specify that *A* is qualified by *Q*." ;
  skos:changeNote
    "0.2.0 :: Added" ;
  vann:termGroup "attributes" ;
  rdfs:domain imf:Attribute ;
  rdfs:range  imf:AttributeQualifier .
#+END_SRC

*** Attribute Qualifiers

#+NAME: tbl-qualifier-classes
| Qualifier               | PCA mapping       |
|-------------------------+-------------------|
| imf:ProvenanceQualifier | pca-plm:PCA_100004033 |
| imf:RangeQualifier      | pca-plm:PCA_100004035 |
| imf:RegularityQualifier | pca-plm:PCA_100004036 |
| imf:ScopeQualifier      | pca-plm:PCA_100004034 |


#+NAME: tbl-qualifiers
| Instance                | Qualifier               | PCA mapping           |
|-------------------------+-------------------------+-----------------------|
| imf:specifiedQualifier  | imf:ProvenanceQualifier | pca-plm:PCA_100004037 |
| imf:calculatedQualifier | imf:ProvenanceQualifier | pca-plm:PCA_100004038 |
| imf:measuredQualifier   | imf:ProvenanceQualifier | pca-plm:PCA_100004039 |
| imf:averageQualifier    | imf:RangeQualifier      | pca-plm:PCA_100004047 |
| imf:maximumQualifier    | imf:RangeQualifier      | pca-plm:PCA_100004048 |
| imf:minimumQualifier    | imf:RangeQualifier      | pca-plm:PCA_100004049 |
| imf:nominalQualifier    | imf:RangeQualifier      | pca-plm:PCA_100004045 |
| imf:normalQualifier     | imf:RangeQualifier      | pca-plm:PCA_100004046 |
| imf:absoluteQualifier   | imf:RegularityQualifier | pca-plm:PCA_100004052 |
| imf:continuousQualifier | imf:RegularityQualifier | pca-plm:PCA_100004051 |
| imf:designQualifier     | imf:ScopeQualifier      | pca-plm:PCA_100004042 |
| imf:operatingQualifier  | imf:ScopeQualifier      | pca-plm:PCA_100004043 |

#+NAME: tbl-qualifiers-other
| imf:actualQualifier     | imf:RangeQualifier      | pca-plm:PCA_100004050 |
| imf:testQualifier       | imf:ScopeQualifier      | pca-plm:PCA_100004044 |
| imf:setQualifier        | imf:ProvenanceQualifier | pca-plm:PCA_100004041 |
| imf:estimatedQualifier  | imf:ProvenanceQualifier | pca-plm:PCA_100004040 |

**** Processing                                                          :QA:

#+BEGIN_SRC ttl :noweb strip-export :tangle out/ottr/imf-ontology/attributes.stottr :mkdirp yes
<<prefixes>>

o-imf:AttributeQualifierClass [owl:Class ?qualifierClass, xsd:string ?label, ottr:IRI ?pcaMapping
] :: {
  o-rdf:Type(?qualifierClass, owl:Class) ,
  o-owl-ax:SubClassOf(?qualifierClass, imf:AttributeQualifier) ,
  ottr:Triple(?qualifierClass, skos:prefLabel, ?label),
  o-owl-ax:SubObjectMaxCardinality(imf:Attribute, "1"^^xsd:nonNegativeInteger, imf:hasAttributeQualifier, ?qualifierClass),
  ottr:Triple(?qualifierClass, skos:exactMatch, ?pcaMapping)
  #
  ottr:Triple(?qualifierClass, vs:term_status, "testing")
  ottr:Triple(?qualifierClass, skos:changeNote, "0.2.0 :: Added")
  ottr:Triple(?qualifierClass, vann:termGroup, "attributes")
} .


o-imf:AttributeQualifier [owl:NamedIndividual ?qualifier, xsd:string ?label, owl:Class ?qualifierClass, ottr:IRI ?pcaMapping
] :: {
  o-rdf:Type(?qualifier, owl:NamedIndividual)
  o-rdf:Type(?qualifier, ?qualifierClass),
  ottr:Triple(?qualifier, skos:prefLabel, ?label),
  ottr:Triple(?qualifier, skos:exactMatch, ?pcaMapping)
  #
  ottr:Triple(?qualifier, vs:term_status, "testing")
  ottr:Triple(?qualifier, skos:changeNote, "0.2.0 :: Added")
  ottr:Triple(?qualifier, vann:termGroup, "attributes")
} .
#+END_SRC

#+NAME: py_aspect_ottr_qualifiers
#+BEGIN_SRC python :results raw :wrap src ttl :var tI=tbl-qualifiers tC=tbl-qualifier-classes :exports none
output = ""
instance = "[] ottr:of {} ;\n   ottr:values( {} ) . \n"

for i in tI:
  i.insert(1, "'" + i[0].replace("imf:", "").replace("Qualifier", " qualifier") + "'")
  output += instance.format("o-imf:AttributeQualifier", " ".join(i))

allI = list(zip(*tI[0:]))[0]
output += instance.format("o-owl-ax:DifferentIndividuals", "( " + " ".join(allI) + " )")

for i in tC:
  i.insert(1, "'" + i[0].replace("imf:", "").replace("Qualifier", " Qualifier") + "'")
  output += instance.format("o-imf:AttributeQualifierClass", " ".join(i))

allC = list(zip(*tC[0:]))[0]
output += instance.format("o-owl-ax:DisjointClasses", "( " + " ".join(allC) + " )")


return output
#+END_SRC

#+RESULTS: py_aspect_ottr_qualifiers
#+BEGIN_src ttl
[] ottr:of o-imf:AttributeQualifier ;
   ottr:values( imf:calculatedQualifier 'calculated qualifier' imf:ProvenanceQualifier plm:PCA_100004038 ) .
[] ottr:of o-imf:AttributeQualifier ;
   ottr:values( imf:measuredQualifier 'measured qualifier' imf:ProvenanceQualifier plm:PCA_100004039 ) .
[] ottr:of o-imf:AttributeQualifier ;
   ottr:values( imf:specifiedQualifier 'specified qualifier' imf:ProvenanceQualifier plm:PCA_100004037 ) .
[] ottr:of o-imf:AttributeQualifier ;
   ottr:values( imf:estimatedQualifier 'estimated qualifier' imf:ProvenanceQualifier plm:PCA_100004040 ) .
[] ottr:of o-imf:AttributeQualifier ;
   ottr:values( imf:setQualifier 'set qualifier' imf:ProvenanceQualifier plm:PCA_100004041 ) .
[] ottr:of o-imf:AttributeQualifier ;
   ottr:values( imf:averageQualifier 'average qualifier' imf:RangeQualifier plm:PCA_100004047 ) .
[] ottr:of o-imf:AttributeQualifier ;
   ottr:values( imf:maximumQualifier 'maximum qualifier' imf:RangeQualifier plm:PCA_100004048 ) .
[] ottr:of o-imf:AttributeQualifier ;
   ottr:values( imf:minimumQualifier 'minimum qualifier' imf:RangeQualifier plm:PCA_100004049 ) .
[] ottr:of o-imf:AttributeQualifier ;
   ottr:values( imf:nominalQualifier 'nominal qualifier' imf:RangeQualifier plm:PCA_100004045 ) .
[] ottr:of o-imf:AttributeQualifier ;
   ottr:values( imf:actualQualifier 'actual qualifier' imf:RangeQualifier plm:PCA_100004050 ) .
[] ottr:of o-imf:AttributeQualifier ;
   ottr:values( imf:normalQualifier 'normal qualifier' imf:RangeQualifier plm:PCA_100004046 ) .
[] ottr:of o-imf:AttributeQualifier ;
   ottr:values( imf:absoluteQualifier 'absolute qualifier' imf:RegularityQualifier plm:PCA_100004052 ) .
[] ottr:of o-imf:AttributeQualifier ;
   ottr:values( imf:continuousQualifier 'continuous qualifier' imf:RegularityQualifier plm:PCA_100004051 ) .
[] ottr:of o-imf:AttributeQualifier ;
   ottr:values( imf:designQualifier 'design qualifier' imf:ScopeQualifier plm:PCA_100004042 ) .
[] ottr:of o-imf:AttributeQualifier ;
   ottr:values( imf:operatingQualifier 'operating qualifier' imf:ScopeQualifier plm:PCA_100004043 ) .
[] ottr:of o-imf:AttributeQualifier ;
   ottr:values( imf:testQualifier 'test qualifier' imf:ScopeQualifier plm:PCA_100004044 ) .
[] ottr:of o-owl-ax:DifferentIndividuals ;
   ottr:values( ( imf:calculatedQualifier imf:measuredQualifier imf:specifiedQualifier imf:estimatedQualifier imf:setQualifier imf:averageQualifier imf:maximumQualifier imf:minimumQualifier imf:nominalQualifier imf:actualQualifier imf:normalQualifier imf:absoluteQualifier imf:continuousQualifier imf:designQualifier imf:operatingQualifier imf:testQualifier ) ) .
[] ottr:of o-imf:AttributeQualifierClass ;
   ottr:values( imf:ProvenanceQualifier 'Provenance Qualifier' plm:PCA_100004038 ) .
[] ottr:of o-imf:AttributeQualifierClass ;
   ottr:values( imf:RangeQualifier 'Range Qualifier' plm:PCA_100004047 ) .
[] ottr:of o-imf:AttributeQualifierClass ;
   ottr:values( imf:RegularityQualifier 'Regularity Qualifier' plm:PCA_100004051 ) .
[] ottr:of o-imf:AttributeQualifierClass ;
   ottr:values( imf:ScopeQualifier 'Scope Qualifier' plm:PCA_100004044 ) .
[] ottr:of o-owl-ax:DisjointClasses ;
   ottr:values( ( imf:ProvenanceQualifier imf:RangeQualifier imf:RegularityQualifier imf:ScopeQualifier ) ) .
#+END_src

** Types
*** Overview

#+NAME: plantuml-types
#+BEGIN_SRC plantuml :noweb yes :file out/owl/imf-ontology-types.png
<<plantuml-style>>

abstract class Type
abstract class ElementType

ElementType <- Element : type

class BlockType
class TerminalType
class AttributeType

abstract class TypeReference

Type <|-- ElementType
ElementType <|-- BlockType
ElementType <|-- TerminalType
ElementType <|-- AttributeType

TypeReference -> Type : source
TypeReference -> Type : target
#+END_SRC

#+ATTR_LATEX: :width 12cm
#+RESULTS: plantuml-types
[[file:out/owl/imf-ontology-types.png]]

*** ~Type~

#+NAME: owl-types-type
#+BEGIN_SRC ttl
imf:Type a owl:Class ;
  skos:prefLabel "Type (unstable)" ;
  vs:term_status "unstable" ;
  #skos:definition "A [Type] is a ... " ;
  skos:scopeNote """

[Type] has the status 'unstable'; ... """ ;
  skos:changeNote
    "0.2.1 :: Added" ;
  vann:termGroup "type" ;
  foaf:depiction <http://ns.imfid.org/20230630/img/imf-ontology-type.png> ;
.

imf:ElementType a owl:Class ;
  skos:prefLabel "Element Type (unstable)" ;
  vs:term_status "unstable" ;
  skos:changeNote
    "0.2.1 :: Added" ;
  vann:termGroup "type" ;
  rdfs:subClassOf imf:Type .

imf:BlockType a owl:Class ;
  skos:prefLabel "Block Type (unstable)" ;
  vs:term_status "unstable" ;
  skos:changeNote
    "0.2.1 :: Added" ;
  vann:termGroup "type" ;
  rdfs:subClassOf imf:ElementType .

imf:TerminalType a owl:Class ;
  skos:prefLabel "Terminal Type (unstable)" ;
  vs:term_status "unstable" ;
  skos:changeNote
    "0.2.1 :: Added" ;
  vann:termGroup "type" ;
  rdfs:subClassOf imf:ElementType .

imf:AttributeType a owl:Class ;
  skos:prefLabel "Attribute Type (unstable)" ;
  vs:term_status "unstable" ;
  skos:changeNote
    "0.2.1 :: Added" ;
  vann:termGroup "type" ;
  rdfs:subClassOf imf:ElementType .
#+END_SRC

* IMF Grammar (SHACL)
** IMF Terms

#+BEGIN_SRC ttl :noweb yes :tangle out/shacl/imf-terms-grammar.shacl.ttl :mkdirp yes
<<prefixes-imf>>

imf:IMFTermsGrammar a owl:Ontology ;
    owl:versionIRI <http://ns.imfid.org/20230630/imf-terms-grammar.shacl.ttl> ;
    owl:versionInfo "0.2.0" ;
    skos:prefLabel "IMF Terms Grammar -- SHACL" ;
    dc:description """
These SHACL Shapes restrict the use of IRIs in the IMF namespace to those defined in the IMF Ontology.

Use them to validate RDF data against correct use of IMF terms, IRIs only.""" ;
    pav:createdBy [ foaf:name "Martin G. Skjæveland" ] ;
    pav:createdOn "2023-06-30T00:00:00"^^xsd:dateTime ;
    sh:shapesGraph
      <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl> ,
      <http://www.w3.org/ns/shacl-shacl#> ;
    skos:editorialNote """Result of validation against specified sh:shapesGraph:
<<sh_jena_shacl_validate(shapes="http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl", data="out/shacl/imf-terms-grammar.shacl.ttl")>>

<<sh_jena_shacl_validate(shapes="http://www.w3.org/ns/shacl-shacl#", data="out/shacl/imf-terms-grammar.shacl.ttl")>>
    """
.

[] a sh:NodeShape ;
    sh:message "Unrecognised IMF vocabulary element. Check spelling." ;
    sh:name "IMF vocabulary element." ;
    sh:sparql [ a sh:SPARQLConstraint ;
	    sh:select """
	      PREFIX imf: <http://ns.imfid.org/imf#>
	      PREFIX owl: <http://www.w3.org/2002/07/owl#>
	      PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
	      SELECT DISTINCT ?value
	      WHERE { { ?value ?p ?o }
		  UNION { ?s ?value ?o }
		  UNION { ?s ?p ?value }
		FILTER (isIRI(?value) && STRSTARTS(STR(?value), 'http://ns.imfid.org/imf#'))
		FILTER NOT EXISTS { ?value a owl:Ontology }
		FILTER(IRI(REPLACE(STR(?value), '^(.*?)(Shape)?$', '$1')) NOT IN (<<py_list_iris()>>))
	      }"""
	      ] ;
    sh:targetNode <http://shipshape.dyreriket.xyz#ANY_NODE> .
#+END_SRC

** IMF Model Grammar

#+CALL:sh_jena_shacl_validate(shapes="out/shacl/imf-terms-grammar.shacl.ttl", data="out/shacl/imf-model-grammar.shacl.ttl")

#+RESULTS:
#+BEGIN_src ttl
Result of validating RDF data <out/shacl/imf-model-grammar.shacl.ttl> against SHACL shape <out/shacl/imf-terms-grammar.shacl.ttl>:
2023-06-28
Node=<http://shipshape.dyreriket.xyz#ANY_NODE>
  Value: <http://ns.imfid.org/imf#MetadataShape>
  Message: Unrecognised IMF vocabulary element. Check spelling.
#+END_src

#+BEGIN_SRC ttl :noweb yes :tangle out/shacl/imf-model-grammar.shacl.ttl :mkdirp yes
<<prefixes-imf>>

imf:IMFModelGrammar a owl:Ontology ;
    owl:versionIRI <http://ns.imfid.org/20230630/imf-model-grammar.shacl.ttl> ;
    owl:versionInfo "0.2.0" ;
    owl:priorVersion <https://ns.imfid.org/20221118/imf-grammar.shacl.ttl> ;
    skos:prefLabel "IMF Model Grammar -- SHACL" ;
    dc:description "This shapes graph can be used to validate IMF Model RDF data against the grammar for IMF Models." ;
    pav:createdBy [ foaf:name "Martin G. Skjæveland" ] ;
    pav:createdOn "2023-06-30T00:00:00"^^xsd:dateTime ;
    owl:imports
      <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl> ,
      <http://ns.imfid.org/20230630/imf-terms-grammar.shacl.ttl> ;
    sh:entailment <http://www.w3.org/ns/entailment/RDFS> ;
    sh:shapesGraph
      <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl> ,
      <http://www.w3.org/ns/shacl-shacl#> ,
      <http://ns.imfid.org/20230630/imf-terms-grammar.shacl.ttl> ;
    skos:editorialNote """Result of validation against specified sh:shapesGraph:
<<sh_jena_shacl_validate(data="out/shacl/imf-model-grammar.shacl.ttl", shapes="http://www.w3.org/ns/shacl-shacl#")>>

<<sh_jena_shacl_validate(data="out/shacl/imf-model-grammar.shacl.ttl", shapes="http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl")>>

<<sh_jena_shacl_validate(data="out/shacl/imf-model-grammar.shacl.ttl", shapes="http://ns.imfid.org/20230630/imf-terms-grammar.shacl.ttl")>>
    """
.

<<shacl-model-model>>
<<shacl-elements-annotations>>
<<shacl-elements-block>>
<<shacl-elements-terminal>>
<<shacl-elements-breakdownpoint>>
<<shacl-elements-connectionpoint>>
<<shacl-aspect-aspectelement>>
<<shacl-attributes-value>>
#<<shacl-attributes-group>>
#+END_SRC


** IMF Ontology Grammar

#+BEGIN_SRC ttl :noweb yes :tangle out/shacl/imf-ontology-grammar.shacl.ttl :mkdirp yes
<<prefixes-imf>>

imf:IMFOntologyGrammar a owl:Ontology ;
    owl:versionIRI <http://ns.imfid.org/20230630/imf-ontology-grammar.shacl.ttl> ;
    owl:versionInfo "0.2.1" ;
    skos:prefLabel "IMF Ontology Grammar -- SHACL" ;
    dc:description """
These SHACL Shapes specify requirements on the definition of terms in the IMF ontology and is therefore useful only for the development of the IMF ontology.""" ;
    pav:createdBy [ foaf:name "Martin G. Skjæveland" ] ;
    pav:createdOn "2023-06-30T00:00:00"^^xsd:dateTime ;
    owl:imports
      <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl>,
      <http://ns.imfid.org/20230630/imf-terms-grammar.shacl.ttl> ;
    sh:shapesGraph
      <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl> ,
      <http://www.w3.org/ns/shacl-shacl#> ,
      <http://ns.imfid.org/20230630/imf-terms-grammar.shacl.ttl> ;
    skos:editorialNote """Result of validation against specified sh:shapesGraph:
<<sh_jena_shacl_validate(shapes="http://www.w3.org/ns/shacl-shacl#", data="out/shacl/imf-ontology-grammar.shacl.ttl")>>

<<sh_jena_shacl_validate(shapes="http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl", data="out/shacl/imf-ontology-grammar.shacl.ttl")>>

<<sh_jena_shacl_validate(shapes="http://ns.imfid.org/20230630/imf-terms-grammar.shacl.ttl", data="out/shacl/imf-ontology-grammar.shacl.ttl")>>
    """
.


_:TermMetadata a sh:NodeShape ;
  sh:target [
    a sh:SPARQLTarget ;
    sh:select """
<<vocabulary-checks-select-query>>
      """
  ] ;
  sh:property
    [ sh:path vs:term_status ; sh:minCount 1 ; sh:maxCount 1 ; sh:in ( "unstable" "testing" "stable" "archaic" ) ] ,
    [ sh:path vann:termGroup ; sh:minCount 1 ; sh:maxCount 1 ; sh:in ( "elements" "aspects" "attributes" "generic relations" "model" "type" ) ] ,
    [ sh:path skos:prefLabel ; sh:minCount 1 ; sh:maxCount 1 ; sh:datatype xsd:string ] ,
    [ sh:path skos:definition ; sh:minCount 1 ; sh:maxCount 1 ; sh:datatype xsd:string  ] ,
    [ sh:path skos:changeNote ; sh:minCount 1 ; sh:pattern "^[0-9].[0-9].[0-9] :: [Added|Changed:]" ] ;
    #[ sh:path skos:scopeNote ; sh:minCount 1 ; sh:severity sh:Warning ]
  skos:changeNote
    "0.2.0 :: Added" ,
    "0.2.1 :: Changed: add termGroup for type"
.

#+END_SRC

*** SPARQL query

#+NAME: vocabulary-checks-select-query
#+BEGIN_SRC ttl
      PREFIX owl:   <http://www.w3.org/2002/07/owl#>
      PREFIX skos:  <http://www.w3.org/2004/02/skos/core#>
      SELECT ?this {
	?this a ?type
	FILTER (STRSTARTS(STR(?this), 'http://ns.imfid.org'))
	FILTER (isIRI(?this))
	#FILTER (?type IN ( owl:Class, owl:NamedIndividual, owl:ObjectProperty, owl:DatatypeProperty, owl:AnnotationProperty ))
	FILTER (?type != owl:Ontology)
	FILTER NOT EXISTS {
	  ?this skos:note ?note .
	  FILTER (STRSTARTS(STR(?note), 'This resource is programatically generated.'))
	}
	FILTER NOT EXISTS {
	  ?this skos:exactMatch [] .
	}
      }
      ## ORDER BY ?this
#+END_SRC


#+CALL: sh_jena_sparql(query=vocabulary-checks-select-query, "out/owl/imf-ontology.owl.ttl")

** IMF Type Grammar

#+BEGIN_SRC ttl :noweb yes :tangle out/shacl/imf-types-grammar.shacl.ttl :mkdirp yes
<<prefixes-imf>>

imf:IMFTypesGrammar a owl:Ontology ;
    owl:versionIRI <http://ns.imfid.org/20230630/imf-types-grammar.shacl.ttl> ;
    owl:versionInfo "0.2.0" ;
    skos:prefLabel "IMF Types Grammar -- SHACL" ;
    dc:description """
These SHACL Shapes specify requirements for creating IMF Types SHACL Shapes. This SHACL Shape file extends the W3C SHACL Shapes specification.

Use them to validate IMF Type SHACL Shapes.
""" ;
    pav:createdBy [ foaf:name "Martin G. Skjæveland" ] ;
    pav:createdOn "2023-06-30T00:00:00"^^xsd:dateTime ;
    owl:imports
      <http://www.w3.org/ns/shacl-shacl#> ,
      <http://ns.imfid.org/20230630/imf-terms-grammar.shacl.ttl> ;
    sh:shapesGraph
      <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl> ,
      <http://www.w3.org/ns/shacl-shacl#> ;
    skos:editorialNote """Result of validation against specified sh:shapesGraph:
<<sh_jena_shacl_validate(data="out/shacl/imf-types-grammar.shacl.ttl", shapes="http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl")>>

<<sh_jena_shacl_validate(data="out/shacl/imf-types-grammar.shacl.ttl", shapes="http://www.w3.org/ns/shacl-shacl#")>>
    """
.

<<shacl-type-grammar-typeshape>>
<<shacl-type-grammar-attributeshape>>

#+END_SRC

*** TypeShape

#+NAME: shacl-type-grammar-typeshape
#+BEGIN_SRC ttl
imf:TypeShape a sh:NodeShape ;
  sh:targetClass imf:Type ;
  sh:property
    [ sh:deactivated true; sh:path sh:targetClass ; sh:minCount 1 ; sh:message "The Type has no sh:targetClass." ] ,
    [ sh:path sh:property ;
      sh:severity sh:Warning ;
      sh:node [ sh:property [ sh:path [ sh:alternativePath ( sh:hasValue sh:in sh:node sh:datatype sh:class ) ] ; sh:minCount 1 ; sh:maxCount 1 ] ] ;
      sh:name "sh:property target" ;
      sh:message "A property constraint should specify exactly one of the following: sh:hasValue, sh:in, sh:node, sh:class or sh:datatype in order to set a target for the path." ]  ,

    [ sh:path sh:property;
      sh:node [ sh:property [ sh:path [ sh:alternativePath ( sh:hasValue sh:minCount ) ] ; sh:minCount 1 ; sh:maxCount 1 ] ] ;
      sh:message "A property constraint must specify exactly one of the following: sh:hasValue, sh:minCount (which can be set to 0)." ] ,

    [ sh:path sh:property;
      sh:node [ sh:or ( # A -> B  =  not A or B
	  [ sh:not [ sh:path [ sh:alternativePath ( sh:minExclusive sh:maxExclusive sh:minInclusive sh:maxInclusive sh:pattern ) ] ; sh:minCount 1 ] ]
	  [ sh:path sh:datatype ; sh:minCount 1 ] ) ] ;
      sh:message "A property constraint must only specify one or more of the following: sh:minExclusive, sh:maxExclusive, sh:minInclusive, sh:maxInclusive, sh:pattern, and only if also sh:datatype is specified." ] ;
  skos:changeNote
    "0.2.0 :: Added" ,
  """0.2.1 :: Changed: 
- Set severity for 'sh:property target' to sh:Warning
- Deactivated targetClass requirement as we are using SHACL's implicit class target functionality
"""
.
#+END_SRC

*** AttributeShape

#+NAME: shacl-type-grammar-attributeshape
#+BEGIN_SRC ttl
imf:AttributeShape a sh:NodeShape ;
  # sh:deactivated true ;
  sh:targetClass imf:AttributeType ;
  sh:property
    [ sh:path ( sh:property sh:path ) ; sh:hasValue imf:predicate ; sh:minCount 1 ; sh:nodeKind sh:IRI ;
      sh:severity sh:Warning ; sh:message "The AttributeType does not specify a imf:predicate." ] ;
  skos:changeNote
    "0.2.0 :: Added" ,
    """0.2.1 :: Changed: 
- activate shape (by removing 'sh:deactivated true').
- set nodeKind
- bug fix: remove maxCount"""
.
#+END_SRC
* JSON-LD
** IMF type context

#+BEGIN_SRC js :noweb yes :tangle out/json/imf-type-shacl-context.json :mkdirp yes
{
    "@context":
    [        
      	"http://jsonld-context.dyreriket.xyz/rdfs.json",
        "http://jsonld-context.dyreriket.xyz/sh.json",
        "http://jsonld-context.dyreriket.xyz/pav.json",
        "http://jsonld-context.dyreriket.xyz/dc.json",
      	"http://jsonld-context.dyreriket.xyz/skos.json",
        "https://imf-lab.gitlab.io/imf-ontology/out/json/imf-context.json",
	{
	    "@version": 1.1,

	    "dc": "http://purl.org/dc/elements/1.1/",
	    "ex": "http://example.com/example/",
	    "foaf": "http://xmlns.com/foaf/0.1/",
	    "imf": "http://ns.imfid.org/imf#",
	    "owl": "http://www.w3.org/2002/07/owl#",
	    "pav": "http://purl.org/pav/",
	    "pca-plm": "http://rds.posccaesar.org/ontology/plm/rdl/",
	    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
	    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
	    "sh": "http://www.w3.org/ns/shacl#",
	    "skos": "http://www.w3.org/2004/02/skos/core#",
	    "vann": "http://purl.org/vocab/vann/",
	    "vs": "http://www.w3.org/2003/06/sw-vocab-status/ns#",
	    "xsd": "http://www.w3.org/2001/XMLSchema#"
	}
    ],

    "@type": "sh:NodeShape",
    "sh:property": {
        "sh:path": {},
	"sh:node": {
	    "@omitDefault": true,
	    "@embed": "@never"
	}
    },
    "rdfs:subClassOf": {
	"@omitDefault": true,
	"@embed": "@never"
    },
    "sh:targetClass": {
	"@omitDefault": true,
	"@embed": "@never"
    }
}
#+END_SRC
* Modelling patterns (OTTR)
** IMF Types templates
*** TODO Overview

The diagram displays the type patterns.

Some terms are prefixed with ~sh.~ to indicate that they refer to
terms that are defined in the SHACL standard:
https://www.w3.org/TR/shacl. This also indicates how the type pattern
instances are translated into SHACL.

#+NAME: plantuml-patterns-types
#+BEGIN_SRC plantuml :noweb yes :file out/img/imf-patterns-types.png
<<plantuml-style>>

metaclass SHACL.Shape {
  id: 1 iri
}

metaclass SHACL.NodeShape {
  sh.targetClass: 0..1 iri
}

metaclass SHACL.PropertyShape {
  sh.name: 0..1 string
  sh.description: 0..1 string
  sh.path: 1 iri
  sh.severity: 0..1 iri
  sh.message: 0..1 string
}

metaclass Type {
  typeClass: 1 iri
}

metaclass TypeReference {
  sh.minCount: 0..1 integer
  sh.maxCount: 0..1 integer
}

metaclass PropertyConstraint {
.. Values ..
  sh.hasValue: 0..1
  sh.in: 0..*
  sh.class: 0..1 iri
  sh.datatype: 0..1 iri
.. Cardinality ..
  sh.minCount: 0..1 integer
  sh.maxCount: 0..1 integer
.. Numeric constraints ..
  sh.minExclusive: 0..1
  sh.minInclusive: 0..1
  sh.maxExclusive: 0..1
  sh.maxInclusive: 0..1
.. String constraints ..
  sh.pattern: 0..1 string
  sh.flags: 0..1 string
}

SHACL.Shape <|-- SHACL.NodeShape
SHACL.Shape <|-- SHACL.PropertyShape

SHACL.NodeShape <|-- Type

SHACL.PropertyShape <|-- PropertyConstraint
SHACL.PropertyShape <|-- TypeReference

SHACL.NodeShape "1" -right-> SHACL.PropertyShape : sh.property
TypeReference --> "1" SHACL.NodeShape : node

#+END_SRC

*** Basic SHACL templates

#+NAME: ottr_types_shacl
#+BEGIN_SRC ttl
o-imf:ShaclNodeShape[
  ottr:IRI ?id,
  ? owl:Class ?targetClass
] :: {
  o-rdf:Type(?id, sh:NodeShape),
  ottr:Triple(?id, sh:targetClass, ?targetClass)
} .

o-imf:ShaclPropertyShape[
    ottr:IRI ?id,
    ottr:IRI ?nodeShape, ## the node shape to which this property belongs.
    ottr:IRI ?path,
  ? xsd:string ?name,
  ? xsd:string ?description,
  ? ottr:IRI ?severity,
  ? xsd:string ?message
] :: {
  ottr:Triple(?id, sh:name, ?name),
  ottr:Triple(?id, sh:description, ?description)
  ottr:Triple(?nodeShape, sh:property, ?id),
  ottr:Triple(?id, sh:path, ?path),
  ottr:Triple(?id, sh:severity, ?severity),
  ottr:Triple(?id, sh:message, ?message)
} .
#+END_SRC

*** Low-level type templates

#+NAME: ottr_types_basic_types
#+BEGIN_SRC ttl
o-imf-t-s:Type[
  owl:Class ?id,        # id of the type
  owl:Class ?IMFClass,  # the IMF superclass of this type, e.g., imf:Block
  owl:Class ?typeClass, # the IMF type class, e.g., imf:BlockType
  ? List<owl:Class> ?superclass,
  ? xsd:string ?name,
  ? xsd:string ?description
] :: {
  o-imf:ShaclNodeShape(?id, none),
  ottr:Triple(?id, skos:prefLabel, ?name),
  ottr:Triple(?id, dc:description, ?description),
  o-rdf:Type(?id, rdfs:Class),
  o-rdfs:SubClassOf(?id, ?IMFClass)
  o-rdf:Type(?id, ?typeClass)
  cross | o-rdfs:SubClassOf(?id, ++?superclass)
} .

o-imf-t-s:TypeReference[
    ottr:IRI ?id = _:P,
    ottr:IRI ?typeSource,
    ottr:IRI ?path,
    ottr:IRI ?typeTarget,
    xsd:integer ?minCount = 0,
  ? xsd:integer ?maxCount,
  ? xsd:string ?name,
  ? xsd:string ?description,
  ? ottr:IRI ?severity,
  ? xsd:string ?message
] :: {
  o-imf:ShaclPropertyShape(?id, ?typeSource, ?path, ?name, ?description, ?severity, ?message),
  ottr:Triple(?id, sh:node, ?typeTarget),
  ottr:Triple(?id, sh:minCount, ?minCount),
  ottr:Triple(?id, sh:maxCount, ?maxCount)
} .

o-imf-t-s:PropertyConstraint[
    ottr:IRI ?id = _:P,
    ottr:IRI ?typeSource,
    ottr:IRI ?path,
  ? rdfs:Resource ?value,
  ? List<rdfs:Resource> ?in,
  ? owl:Class ?class,
  ? ottr:IRI ?datatype,
  ? xsd:integer ?minCount,
  ? xsd:integer ?maxCount,
  ? rdfs:Literal ?minInclusive,
  ? rdfs:Literal ?minExclusive,
  ? rdfs:Literal ?maxInclusive,
  ? rdfs:Literal ?maxExclusive,
  ? xsd:string ?pattern,
  ? xsd:string ?name,
  ? xsd:string ?description,
  ? ottr:IRI ?severity,
  ? xsd:string ?message
] :: {
  o-imf:ShaclPropertyShape(?id, ?typeSource, ?path, ?name, ?description, ?severity, ?message),
  ottr:Triple(?id, sh:hasValue, ?value),
  ottr:Triple(?id, sh:in, ?in),
  ottr:Triple(?id, sh:class, ?class),
  ottr:Triple(?id, sh:datatype, ?datatype),
  ottr:Triple(?id, sh:minCount, ?minCount),
  ottr:Triple(?id, sh:maxCount, ?maxCount),
  ottr:Triple(?id, sh:minInclusive, ?minInclusive),
  ottr:Triple(?id, sh:minExclusive, ?minExclusive),
  ottr:Triple(?id, sh:maxInclusive, ?maxInclusive),
  ottr:Triple(?id, sh:maxExclusive, ?maxExclusive),
  #ottr:Triple(?id, sh:minLength, ?minLength),
  #ottr:Triple(?id, sh:maxLength, ?maxLength),
  ottr:Triple(?id, sh:pattern, ?pattern)
  #ottr:Triple(?id, sh:flags, ?flags)
} .
#+END_SRC

*** Low-level utility templates

#+NAME: ottr_types_utility
#+BEGIN_SRC ttl
o-imf-t-s:PropertyConstraintSingleValue[
    ottr:IRI ?id = _:P,
    ottr:IRI ?typeSource,
    ottr:IRI ?path,
    rdfs:Resource ?value
] :: {
o-imf-t-s:PropertyConstraint(?id, ?typeSource, ?path, ?value,
  none, none, none, none, none, none, none, none, none, none, none, none, none, none)
} .

o-imf-t-s:PropertyConstraintCardinality[
    ottr:IRI ?id = _:P,
    ottr:IRI ?typeSource,
    ottr:IRI ?path,
    xsd:integer ?minCount,
  ? xsd:integer ?maxCount
] :: {
o-imf-t-s:PropertyConstraint(?id, ?typeSource, ?path, none,
  none, none, none, ?minCount, ?maxCount, none, none, none, none, none, none, none, none, none)
} .
#+END_SRC

*** User-facing templates

#+NAME: ottr_types_user
#+BEGIN_SRC ttl
o-imf-t-s:ElementType[
  owl:Class ?id,
  owl:Class ?IMFClass,
  owl:Class ?typeClass,
  ? xsd:string ?name,
  ? xsd:string ?description,
  ? List<owl:Class> ?superclass,
  ? ottr:IRI ?aspect,
  ? List<ottr:IRI> ?classifiers
] :: {
  o-imf-t-s:Type(?id, ?IMFClass, ?typeClass, ?superclass, ?name, ?description),
  o-imf-t-s:PropertyConstraintSingleValue(none, ?id, imf:hasAspect, ?aspect),
  cross | o-imf-t-s:PropertyConstraintSingleValue(none, ?id, imf:classifier, ++?classifiers)
} .

o-imf-t-s:BlockType[
  owl:Class ?id,
  ? xsd:string ?name,
  ? xsd:string ?description,
  ? List<owl:Class> ?superclass,
  ? ottr:IRI ?aspect,
  ? ottr:IRI ?purpose,
  ? List<ottr:IRI> ?classifiers,
  ? ottr:IRI ?symbol
] :: {
  o-imf-t-s:ElementType(?id, imf:Block, imf:BlockType, ?name, ?description, ?superclass, ?aspect, ?classifiers),
  o-imf-t-s:PropertyConstraintSingleValue(none, ?id, imf:purpose, ?purpose),
  o-imf-t-s:PropertyConstraintSingleValue(none, ?id, imf:symbol, ?symbol)
} .

o-imf-t-s:TerminalType[
  owl:Class ?id,
  ? xsd:string ?name,
  ? xsd:string ?description,
  ? List<owl:Class> ?superclass,
  ? ottr:IRI ?aspect,
  ? List<ottr:IRI> ?classifiers,
  ? ottr:IRI ?medium
] :: {
  o-imf-t-s:ElementType(?id, imf:Terminal, imf:TerminalType, ?name, ?description, ?superclass, ?aspect, ?classifiers),
  o-imf-t-s:PropertyConstraintSingleValue(none, ?id, imf:medium, ?medium)
} .

o-imf-t-s:AttributeType[
  owl:Class ?id,
  ? xsd:string ?name,
  ? xsd:string ?description,
  ? List<owl:Class> ?superclass,
  ottr:IRI ?predicate,
  ? xsd:integer ?minCountUoM, # does the attribute have a uom or not?
  ? xsd:integer ?maxCountUoM
  #? rdfs:Datatype ?datatype,
  #? rdfs:Literal ?minInclusive, # lower range of attribute value
  #? rdfs:Literal ?maxInclusive # upper range of attribute value
] :: {
  o-imf-t-s:Type(?id, imf:Attribute, imf:AttributeType, ?superclass, ?name, ?description)
  o-imf-t-s:PropertyConstraintSingleValue(none, ?id, imf:predicate, ?predicate)
  o-imf-t-s:PropertyConstraintCardinality(none, ?id, imf:uom, ?minCountUoM, ?maxCountUoM)
  # o-imf-t-s:PropertyConstraint(none, ?id, imf:value,
  # none, #?value
  # none, #?in
  # none, #?class
  # ?datatype,
  # none, #?minCount,
  # none, #?maxCount,
  # ?minInclusive,
  # none, #?minExclusive,
  # ?maxInclusive,
  # none, #?maxExclusive,
  # none, #?pattern,
  # none,
  # none,
  # none, #?severity,
  # none #?message
  # )
} .
#+END_SRC

*** _all                                                           :noexport:

#+BEGIN_SRC ttl :noweb yes :tangle out/ottr/imf-types-shacl.stottr :mkdirp yes
<<prefixes>>

<<ottr_types_shacl>>

<<ottr_types_basic_types>>

<<ottr_types_utility>>

<<ottr_types_user>>
#+END_SRC
** IMF Model templates

#+BEGIN_SRC ttl :noweb yes :tangle out/ottr/imf-model-rdf.stottr :mkdirp yes
<<prefixes>>

o-imf-d:Element[
  owl:NamedIndividual ?id,
  ? xsd:string ?name,
  ? xsd:string ?description,
  ? List<owl:Class> ?types,
  ? owl:NamedIndividual ?parent,
  ? owl:NamedIndividual ?aspect
] :: {
  ottr:Triple(?id, skos:prefLabel, ?name),
  ottr:Triple(?id, rdfs:comment, ?description),
  cross | o-rdf:Type(?id, ++?types),
  ottr:Triple(?id, imf:partOf, ?parent),
  ottr:Triple(?id, imf:hasAspect, ?aspect)
} .

o-imf-d:Block[
  owl:NamedIndividual ?id,
  ? xsd:string ?name,
  ? xsd:string ?description,
  ? List<owl:Class> ?types,
  ? owl:NamedIndividual ?aspect,
  ? ottr:IRI ?purpose,
  ? owl:NamedIndividual ?parent
] :: {
  o-imf-d:Element(?id, ?name, ?description, ?types, ?parent, ?aspect)
  ottr:Triple(?id, imf:purpose, ?purpose)
} .

o-imf-d:Terminal[
  owl:NamedIndividual ?id = _:T,
  ? xsd:string ?name,
  ? xsd:string ?description,
  ? List<owl:Class> ?types,
  ! owl:ObjectProperty ?terminalDir = imf:hasTerminal,
  owl:NamedIndividual ?block,
  ? ottr:IRI ?medium,
  ? owl:NamedIndividual ?parent
] :: {
  o-imf-d:Element(?id, ?name, ?description, ?types, ?parent, none),
  ottr:Triple(?id, imf:medium, ?medium),
  ottr:Triple(?block, ?terminalDir, ?id)
} .

o-imf-d:Attribute[
  owl:NamedIndividual ?id = _:A,
  ? xsd:string ?name,
  ? xsd:string ?description,
  ? List<owl:Class> ?types,
  owl:NamedIndividual ?element,
  ? ottr:IRI ?predicate,
  ?value,
  ?? ottr:IRI ?uom,
  ? owl:NamedIndividual ?qualifier1,
  ? owl:NamedIndividual ?qualifier2,
  ? owl:NamedIndividual ?qualifier3,
  ? owl:NamedIndividual ?qualifier4
] :: {
  ottr:Triple(?id, skos:prefLabel, ?name),
  ottr:Triple(?id, rdfs:comment, ?description),
  cross | o-rdf:Type(?id, ++?types),
  ottr:Triple(?element, imf:hasAttribute, ?id)
  ottr:Triple(?id, imf:predicate, ?predicate)
  ottr:Triple(?id, imf:value, ?value)
  ottr:Triple(?id, imf:uom, ?uom)
  cross | ottr:Triple(?id, imf:hasAttributeQualifier, ++(?qualifier1, ?qualifier2, ?qualifier3, ?qualifier4))
} .
#+END_SRC

* Validation
** OTTR processing

Expand IMF ontology:

#+CALL: lutra-expand(in="out/owl/imf-ontology.owl.wottr.ttl", out="out/owl/imf-ontology.owl.ttl")

** RDF validate tangled file

#+CALL: sh_jena_validate_rdf(files="out/owl/imf-ontology.owl.wottr.ttl out/owl/imf-ontology.owl.ttl out/shacl/imf-terms-grammar.shacl.ttl out/shacl/imf-model-grammar.shacl.ttl out/shacl/imf-ontology-grammar.shacl.ttl out/shacl/imf-types-grammar.shacl.ttl")

#+RESULTS:
#+begin_example
12:08:30 INFO  riot            :: File: out/owl/imf-ontology.owl.wottr.ttl
file:///home/martige/repo/imf-lab/imf-ontology/out/owl/imf-ontology.owl.wottr.ttl : 0.25 sec : 982 Triples : 3,881.42 per second
12:08:30 INFO  riot            :: File: out/owl/imf-ontology.owl.ttl
file:///home/martige/repo/imf-lab/imf-ontology/out/owl/imf-ontology.owl.ttl : 0.04 sec : 953 Triples : 23,825.00 per second
12:08:30 INFO  riot            :: File: out/shacl/imf-terms-grammar.shacl.ttl
file:///home/martige/repo/imf-lab/imf-ontology/out/shacl/imf-terms-grammar.shacl.ttl : 0.01 sec : 18 Triples : 3,000.00 per second
12:08:30 INFO  riot            :: File: out/shacl/imf-model-grammar.shacl.ttl
file:///home/martige/repo/imf-lab/imf-ontology/out/shacl/imf-model-grammar.shacl.ttl : 0.01 sec : 233 Triples : 19,416.67 per second
12:08:30 INFO  riot            :: File: out/shacl/imf-ontology-grammar.shacl.ttl
file:///home/martige/repo/imf-lab/imf-ontology/out/shacl/imf-ontology-grammar.shacl.ttl : 0.01 sec : 64 Triples : 9,142.86 per second
12:08:30 INFO  riot            :: File: out/shacl/imf-types-grammar.shacl.ttl
file:///home/martige/repo/imf-lab/imf-ontology/out/shacl/imf-types-grammar.shacl.ttl : 0.01 sec : 97 Triples : 10,777.78 per second
Total           : 0.33 sec : 2,347 Triples : 7,177.37 per second
#+end_example

** SHACL validation
*** Vocabulary: Std + IMF

#+CALL: sh_jena_shacl_validate(data="out/owl/imf-ontology.owl.wottr.ttl out/shacl/imf-terms-grammar.shacl.ttl out/shacl/imf-model-grammar.shacl.ttl out/shacl/imf-ontology-grammar.shacl.ttl out/shacl/imf-types-grammar.shacl.ttl", shapes="http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl out/shacl/imf-terms-grammar.shacl.ttl")

#+RESULTS:
#+BEGIN_src ttl
Result of validating RDF data <out/owl/imf-ontology.owl.wottr.ttl> against SHACL shape <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl>:
2023-08-08
Conforms

Result of validating RDF data <out/shacl/imf-terms-grammar.shacl.ttl> against SHACL shape <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl>:
2023-08-08
Conforms

Result of validating RDF data <out/shacl/imf-model-grammar.shacl.ttl> against SHACL shape <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl>:
2023-08-08
Conforms

Result of validating RDF data <out/shacl/imf-ontology-grammar.shacl.ttl> against SHACL shape <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl>:
2023-08-08
Conforms

Result of validating RDF data <out/shacl/imf-types-grammar.shacl.ttl> against SHACL shape <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl>:
2023-08-08
Conforms

Result of validating RDF data <out/owl/imf-ontology.owl.wottr.ttl> against SHACL shape <out/shacl/imf-terms-grammar.shacl.ttl>:
2023-08-08
Node=<http://shipshape.dyreriket.xyz#ANY_NODE>
  Value: <http://ns.imfid.org/imf#TerminalType>
  Message: Unrecognised IMF vocabulary element. Check spelling.
Node=<http://shipshape.dyreriket.xyz#ANY_NODE>
  Value: <http://ns.imfid.org/imf#AttributeType>
  Message: Unrecognised IMF vocabulary element. Check spelling.
Node=<http://shipshape.dyreriket.xyz#ANY_NODE>
  Value: <http://ns.imfid.org/imf#BlockType>
  Message: Unrecognised IMF vocabulary element. Check spelling.
Node=<http://shipshape.dyreriket.xyz#ANY_NODE>
  Value: <http://ns.imfid.org/imf#Type>
  Message: Unrecognised IMF vocabulary element. Check spelling.
Node=<http://shipshape.dyreriket.xyz#ANY_NODE>
  Value: <http://ns.imfid.org/imf#ElementType>
  Message: Unrecognised IMF vocabulary element. Check spelling.

Result of validating RDF data <out/shacl/imf-terms-grammar.shacl.ttl> against SHACL shape <out/shacl/imf-terms-grammar.shacl.ttl>:
2023-08-08
Conforms

Result of validating RDF data <out/shacl/imf-model-grammar.shacl.ttl> against SHACL shape <out/shacl/imf-terms-grammar.shacl.ttl>:
2023-08-08
Node=<http://shipshape.dyreriket.xyz#ANY_NODE>
  Value: <http://ns.imfid.org/imf#MetadataShape>
  Message: Unrecognised IMF vocabulary element. Check spelling.

Result of validating RDF data <out/shacl/imf-ontology-grammar.shacl.ttl> against SHACL shape <out/shacl/imf-terms-grammar.shacl.ttl>:
2023-08-08
Conforms

Result of validating RDF data <out/shacl/imf-types-grammar.shacl.ttl> against SHACL shape <out/shacl/imf-terms-grammar.shacl.ttl>:
2023-08-08
Node=<http://shipshape.dyreriket.xyz#ANY_NODE>
  Value: <http://ns.imfid.org/imf#TypeShape>
  Message: Unrecognised IMF vocabulary element. Check spelling.
Node=<http://shipshape.dyreriket.xyz#ANY_NODE>
  Value: <http://ns.imfid.org/imf#AttributeType>
  Message: Unrecognised IMF vocabulary element. Check spelling.
Node=<http://shipshape.dyreriket.xyz#ANY_NODE>
  Value: <http://ns.imfid.org/imf#TerminalType>
  Message: Unrecognised IMF vocabulary element. Check spelling.
Node=<http://shipshape.dyreriket.xyz#ANY_NODE>
  Value: <http://ns.imfid.org/imf#BlockType>
  Message: Unrecognised IMF vocabulary element. Check spelling.

#+END_src


*** IMF SHACL Grammar

#+CALL: sh_jena_shacl_validate(data="out/shacl/imf-terms-grammar.shacl.ttl out/shacl/imf-model-grammar.shacl.ttl out/shacl/imf-ontology-grammar.shacl.ttl out/shacl/imf-types-grammar.shacl.ttl", shapes="http://www.w3.org/ns/shacl-shacl#")

#+RESULTS:
#+BEGIN_src ttl
Result of validating RDF data <out/shacl/imf-terms-grammar.shacl.ttl> against SHACL shape <http://www.w3.org/ns/shacl-shacl#>:
2023-08-08
Conforms

Result of validating RDF data <out/shacl/imf-model-grammar.shacl.ttl> against SHACL shape <http://www.w3.org/ns/shacl-shacl#>:
2023-08-08
Conforms

Result of validating RDF data <out/shacl/imf-ontology-grammar.shacl.ttl> against SHACL shape <http://www.w3.org/ns/shacl-shacl#>:
2023-08-08
Conforms

Result of validating RDF data <out/shacl/imf-types-grammar.shacl.ttl> against SHACL shape <http://www.w3.org/ns/shacl-shacl#>:
2023-08-08
Conforms

Result of validating RDF data <out/shacl/imf-terms-grammar.shacl.ttl> against SHACL shape <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl>:
2023-08-08
Conforms

Result of validating RDF data <out/shacl/imf-model-grammar.shacl.ttl> against SHACL shape <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl>:
2023-08-08
Conforms

Result of validating RDF data <out/shacl/imf-ontology-grammar.shacl.ttl> against SHACL shape <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl>:
2023-08-08
Conforms

Result of validating RDF data <out/shacl/imf-types-grammar.shacl.ttl> against SHACL shape <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl>:
2023-08-08
Conforms

#+END_src

*** IMF Ontology

#+CALL: sh_jena_shacl_validate(data="out/owl/imf-ontology.owl.wottr.ttl", shapes="out/shacl/imf-terms-grammar.shacl.ttl out/shacl/imf-ontology-grammar.shacl.ttl")

#+RESULTS:
#+BEGIN_src ttl
Result of validating RDF data <out/owl/imf-ontology.owl.wottr.ttl> against SHACL shape <out/shacl/imf-terms-grammar.shacl.ttl>:
2023-08-08
Node=<http://shipshape.dyreriket.xyz#ANY_NODE>
  Value: <http://ns.imfid.org/imf#TerminalType>
  Message: Unrecognised IMF vocabulary element. Check spelling.
Node=<http://shipshape.dyreriket.xyz#ANY_NODE>
  Value: <http://ns.imfid.org/imf#AttributeType>
  Message: Unrecognised IMF vocabulary element. Check spelling.
Node=<http://shipshape.dyreriket.xyz#ANY_NODE>
  Value: <http://ns.imfid.org/imf#BlockType>
  Message: Unrecognised IMF vocabulary element. Check spelling.
Node=<http://shipshape.dyreriket.xyz#ANY_NODE>
  Value: <http://ns.imfid.org/imf#Type>
  Message: Unrecognised IMF vocabulary element. Check spelling.
Node=<http://shipshape.dyreriket.xyz#ANY_NODE>
  Value: <http://ns.imfid.org/imf#ElementType>
  Message: Unrecognised IMF vocabulary element. Check spelling.

Result of validating RDF data <out/owl/imf-ontology.owl.wottr.ttl> against SHACL shape <out/shacl/imf-model-grammar.shacl.ttl>:
2023-08-08
Conforms

Result of validating RDF data <out/owl/imf-ontology.owl.wottr.ttl> against SHACL shape <out/shacl/imf-ontology-grammar.shacl.ttl>:
2023-08-08
Node=<http://ns.imfid.org/imf#BreakdownPoint>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#theInput>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#theConnected>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#TerminalType>
  Path=<http://www.w3.org/2004/02/skos/core#changeNote>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#TerminalType>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#TerminalType>
  Path=<http://purl.org/vocab/vann/termGroup>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#BlockType>
  Path=<http://www.w3.org/2004/02/skos/core#changeNote>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#BlockType>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#BlockType>
  Path=<http://purl.org/vocab/vann/termGroup>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#ConnectionPoint>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#AttributeType>
  Path=<http://www.w3.org/2004/02/skos/core#changeNote>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#AttributeType>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#AttributeType>
  Path=<http://purl.org/vocab/vann/termGroup>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#theWhole>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#Type>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#ElementType>
  Path=<http://www.w3.org/2004/02/skos/core#changeNote>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#ElementType>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#ElementType>
  Path=<http://purl.org/vocab/vann/termGroup>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#thePart>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#theOutput>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#AttributeQualifier>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0

#+END_src


** OTTR checks

Format OTTR templates to RDF to enable RDF based checks:
#+BEGIN_SRC sh
java -jar bin/lutra.jar --mode formatLibrary -l out/ottr -L stottr -f -p out/.std-prefixes.ttl -O wottr -o out/temp/ottr
#+END_SRC

#+RESULTS:

#+NAME: validate_ottr_vocabulary
#+BEGIN_SRC sh :results raw :wrap txt :output result
for data in `find out/temp/ottr/ns.imfid.org/ -name *.ttl`
do
  echo $data
  bin/apache-jena/bin/shacl v --text --shapes http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl --data $data
  bin/apache-jena/bin/shacl v --text --shapes out/shacl/imf-terms-grammar.shacl.ttl --data $data
done
#+END_SRC


** Diagram
#+CALL: rdfvizler(rules="out/rdfvizler/ontology-overview.rule", data="out/owl/imf-ontology.owl.wottr.ttl", output="out/owl/imf-overview.svg")

#+RESULTS:

[[./out/owl/imf-overview.svg]]


* Summary
** Overview

All diagrams combined.

#+BEGIN_SRC plantuml :noweb yes :file out/owl/imf-ontology.png
<<plantuml-style>>

<<plantuml-model>>

<<plantuml-aspect-elements>>

'<<plantuml-elements>>
<<plantuml-elements-w-reified>>

<<plantuml-attributes>>

<<plantuml-types>>

#+END_SRC

#+RESULTS:
[[file:out/owl/imf-ontology.png]]

** Vocabulary

Report of the vocabulary used by the IMF ontology.

*** IMF Vocabulary

#+NAME: sparql_all_imf_iris
#+BEGIN_SRC ttl
SELECT DISTINCT
 ?iri ?label ?group ?type ?status ?definition ?scopeNotes ?examples ?notes ?eds ?image
{
  { ?iri ?x1 ?x2 }
  UNION
  { ?x3 ?iri ?x4 }
  UNION
  { ?x5 ?x5 ?iri }
  #FILTER(!isBlank(?iri))
  FILTER(STRSTARTS(STR(?iri), "http://ns.imfid.org"))

  ?iri a ?type
  FILTER(?type IN (
      #owl:Ontology,
      owl:Class,
      owl:ObjectProperty,
      owl:DatatypeProperty,
      owl:AnnotationProperty,
      owl:NamedIndividual
      ))

  OPTIONAL {
    ?iri vann:termGroup ?group }
  OPTIONAL {
    ?iri skos:prefLabel ?label }
  OPTIONAL {
    ?iri vs:term_status ?status }
  OPTIONAL {
    ?iri skos:definition ?definition }
  OPTIONAL {
    ?iri foaf:depiction ?image }

  { SELECT ?iri
      (GROUP_CONCAT(?x1; SEPARATOR=" ") AS ?scopeNotes)
    { ?iri vann:termGroup ?l1 .
      OPTIONAL { ?iri skos:scopeNote ?x1 } }
    GROUP BY ?iri ?l1
  }

  { SELECT ?iri
      (GROUP_CONCAT(?x2; SEPARATOR=" ") AS ?examples)
    { ?iri vann:termGroup ?l2 .
      OPTIONAL { ?iri skos:example ?x2 } }
    GROUP BY ?iri ?l2
  }

  { SELECT ?iri
      (GROUP_CONCAT(?x3; SEPARATOR=" ") AS ?eds)
    { ?iri vann:termGroup ?l3 .
      OPTIONAL { ?iri skos:editorialNote ?x3 } }
    GROUP BY ?iri ?l3
  }

  { SELECT ?iri
      (GROUP_CONCAT(?x4; SEPARATOR=" ") AS ?notes)
    { ?iri vann:termGroup ?l4 .
      OPTIONAL { ?iri skos:note ?x4 } }
    GROUP BY ?iri ?l4
  }


}
ORDER BY DESC(?group) ?status ?type ?iri
#+END_SRC

#+CALL: py_run_sparql(query=sparql_all_imf_iris)

*** IRIs

#+NAME: sparql_all_iris
#+BEGIN_SRC ttl
SELECT DISTINCT ?iri ?type
{
  { ?iri ?x1 ?x2 }
  UNION
  { ?x3 ?iri ?x4 }
  UNION
  { ?x5 ?x5 ?iri }
  FILTER(!isBlank(?iri))

  OPTIONAL {
    ?iri a ?type
    FILTER(?type IN (
      owl:Ontology,
      owl:Class,
      owl:ObjectProperty,
      owl:DatatypeProperty,
      owl:AnnotationProperty,
      owl:NamedIndividual
      ))
  }
}
ORDER BY ?type ?iri
#+END_SRC

#+CALL: py_run_sparql(query=sparql_all_iris)

*** Classes

#+NAME: sparql_class
#+BEGIN_SRC ttl
SELECT ?class ?prefLabel ?superclasses
{
  ?class a owl:Class.
  FILTER (!isBlank(?class))

  OPTIONAL { ?class skos:prefLabel ?prefLabel }

  { SELECT ?class
      (GROUP_CONCAT(?superclass; SEPARATOR=", ") AS ?superclasses)
    {
      OPTIONAL { ?class rdfs:subClassOf ?superclass. FILTER (!isBlank(?superclass)) }
    } GROUP BY ?superclasses ?class
  }
}
ORDER BY ?superclasses ?class
#+END_SRC

#+CALL: py_run_sparql(query=sparql_class)

*** Properties

#+NAME: sparql_property
#+BEGIN_SRC ttl
SELECT ?type ?property ?prefLabel ?domain ?range ?characteristics ?superproperties
{
  ?property a ?type.
  FILTER (?type = owl:ObjectProperty || ?type = owl:DatatypeProperty || ?type = owl:AnnotationProperty )
  FILTER (!isBlank(?property))

  OPTIONAL { ?property skos:prefLabel ?prefLabel }
  OPTIONAL { ?property rdfs:domain ?domain }
  OPTIONAL { ?property rdfs:range ?range }

  { SELECT ?property
      (GROUP_CONCAT(?superproperty; SEPARATOR=", ") AS ?superproperties)
      (GROUP_CONCAT(?characteristic; SEPARATOR=", ") AS ?characteristics)
    {
      OPTIONAL { ?property rdfs:subPropertyOf ?superproperty }
      OPTIONAL { ?property a ?characteristic .
	  FILTER (?characteristic != owl:ObjectProperty && ?characteristic != owl:DatatypeProperty && ?characteristic != owl:AnnotationProperty )
      }
      OPTIONAL { ?property skos:altLabel ?altLabel }
    } GROUP BY ?property
  }

}
ORDER BY ?type ?property
#+END_SRC

#+CALL: py_run_sparql(query=sparql_property)



** Grammar
*** IMF Vocabulary

#+NAME: sparql_all_imf_pathShapes
#+BEGIN_SRC ttl
SELECT DISTINCT
 ?shape ?path ?class ?minCount ?maxCount ?severity ?message
{
  ?shape sh:property ?p .
  ?p sh:path ?path .

  OPTIONAL {
    ?p sh:class ?class }
  OPTIONAL {
    ?p sh:minCount ?minCount }
  OPTIONAL {
    ?p sh:maxCount ?maxCount }
  OPTIONAL {
    ?p sh:severity ?severity }
  OPTIONAL {
    ?p sh:message ?message }

}
ORDER BY ?shape ?path ?class
#+END_SRC

#+CALL: py_run_sparql(query=sparql_all_imf_pathShapes, data="out/shacl/imf-model-grammar.shacl.ttl")

#+RESULTS:
| ~shape~                    | ~path~                                   | ~class~                   | ~minCount~ | ~maxCount~ | ~severity~   | ~message~                                                   |
|----------------------------+------------------------------------------+---------------------------+------------+------------+--------------+-------------------------------------------------------------|
| ~imf:AspectElementShape~   | ~imf:hasAspect~                          | ~imf:Aspect~              | ~1~        | ~1~        |              |                                                             |
| ~imf:AttributeShape~       | ~imf:hasAttributeQualifier~              |                           | ~1~        |            | ~sh:Warning~ | ~Attribute has no qualifier.~                               |
| ~imf:AttributeShape~       | ~imf:hasAttributeQualifier~              | ~imf:ProvenenceQualifier~ |            | ~1~        |              |                                                             |
| ~imf:AttributeShape~       | ~imf:hasAttributeQualifier~              | ~imf:RangeQualifier~      |            | ~1~        |              |                                                             |
| ~imf:AttributeShape~       | ~imf:hasAttributeQualifier~              | ~imf:RegularityQualifier~ |            | ~1~        |              |                                                             |
| ~imf:AttributeShape~       | ~imf:hasAttributeQualifier~              | ~imf:ScopeQualifier~      |            | ~1~        |              |                                                             |
| ~imf:AttributeShape~       | ~imf:property~                           |                           | ~1~        | ~1~        |              |                                                             |
| ~imf:AttributeShape~       | ~imf:uom~                                |                           |            | ~1~        |              |                                                             |
| ~imf:AttributeShape~       | ~imf:value~                              |                           | ~1~        |            | ~sh:Warning~ | ~Attribute has no value.~                                   |
| ~imf:BlockShape~           | ~imf:hasPart~                            | ~imf:Block~               |            |            |              | ~Blocks can only have Blocks as parts.~                     |
| ~imf:BlockShape~           | ~imf:hasTerminal~                        |                           | ~1~        |            | ~sh:Warning~ | ~The Block has no Terminals.~                               |
| ~imf:BlockShape~           | ~imf:hasTerminal~                        | ~imf:Terminal~            |            |            |              |                                                             |
| ~imf:BlockShape~           | ~imf:partOf~                             | ~imf:Block~               |            |            |              | ~Blocks can only be part of Blocks.~                        |
| ~imf:BreakdownPointShape~  | ~imf:thePart~                            | ~imf:Element~             | ~1~        | ~1~        |              |                                                             |
| ~imf:BreakdownPointShape~  | ~imf:theWhole~                           | ~imf:Element~             | ~1~        | ~1~        |              |                                                             |
| ~imf:ConnectionPointShape~ | ~imf:theConnected~                       | ~imf:Element~             |            | ~2~        |              |                                                             |
| ~imf:ConnectionPointShape~ | ~imf:theInput~                           | ~imf:Element~             |            | ~1~        |              |                                                             |
| ~imf:ConnectionPointShape~ | ~imf:theOutput~                          | ~imf:Element~             |            | ~1~        |              |                                                             |
| ~imf:ElementShape~         | ~_:nd1490807077b4065936195b45b7d583eb25~ |                           | ~1~        |            | ~sh:Warning~ | ~Element is not contained in a Model.~                      |
| ~imf:ElementShape~         | ~imf:classifier~                         |                           | ~1~        |            | ~sh:Warning~ | ~Element has no classifier.~                                |
| ~imf:ElementShape~         | ~imf:partOf~                             |                           |            | ~1~        |              | ~Elements cannot be part of multiple Elements.~             |
| ~imf:ElementShape~         | ~dc:description~                         |                           | ~1~        |            | ~sh:Warning~ | ~Element has no description.~                               |
| ~imf:ElementShape~         | ~pav:createdBy~                          |                           | ~1~        |            | ~sh:Warning~ | ~Element has creator.~                                      |
| ~imf:ElementShape~         | ~pav:createdOn~                          |                           | ~1~        |            | ~sh:Warning~ | ~Element has created timestamp.~                            |
| ~imf:ElementShape~         | ~pav:version~                            |                           | ~1~        |            | ~sh:Warning~ | ~Element has no version number.~                            |
| ~imf:ElementShape~         | ~skos:prefLabel~                         |                           | ~1~        |            | ~sh:Warning~ | ~Element has no prefLabel.~                                 |
| ~imf:ModelShape~           | ~skos:hasElement~                        |                           | ~1~        |            | ~sh:Warning~ | ~Model has contains no Elements.~                           |
| ~imf:TerminalShape~        | ~imf:connectedTo~                        |                           | ~1~        |            | ~sh:Warning~ | ~The Terminal has no connection (to a different Terminal).~ |
| ~imf:TerminalShape~        | ~imf:connectedTo~                        | ~imf:Terminal~            |            | ~1~        |              |                                                             |
| ~imf:TerminalShape~        | ~imf:hasTerminalQualifier~               |                           |            | ~1~        |              |                                                             |
| ~imf:TerminalShape~        | ~imf:medium~                             |                           | ~1~        |            | ~sh:Warning~ | ~The Terminal has no medium.~                               |
| ~imf:TerminalShape~        | ~imf:medium~                             |                           |            | ~1~        |              |                                                             |
| ~imf:TerminalShape~        | ~imf:partOf~                             | ~imf:Terminal~            |            | ~1~        |              |                                                             |


* Appendix
** Prefixes

This section contains the prefixes used throughout this document.

*** Standard vocabulary prefixes

#+NAME: prefixes-std
#+BEGIN_SRC ttl :tangle out/.std-prefixes.ttl
@prefix xsd:	<http://www.w3.org/2001/XMLSchema#> .
@prefix rdf:	<http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:	<http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl:    <http://www.w3.org/2002/07/owl#> .
@prefix sh:	<http://www.w3.org/ns/shacl#> .

@prefix dc:	<http://purl.org/dc/elements/1.1/> .
@prefix foaf:   <http://xmlns.com/foaf/0.1/> .
@prefix pav:	<http://purl.org/pav/> .
@prefix skos:	<http://www.w3.org/2004/02/skos/core#> .
@prefix vann:   <http://purl.org/vocab/vann/> .
@prefix vs:     <http://www.w3.org/2003/06/sw-vocab-status/ns#> .

@prefix ex:	<http://example.com#> .
#+END_SRC

#+RESULTS: prefixes-std
#+begin_example
@prefix xsd:	<http://www.w3.org/2001/XMLSchema#> .
@prefix rdf:	<http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:	<http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl:    <http://www.w3.org/2002/07/owl#> .
@prefix sh:	<http://www.w3.org/ns/shacl#> .
@prefix shsh:   <http://www.w3.org/ns/shacl-shacl#> .

@prefix skos:	<http://www.w3.org/2004/02/skos/core#> .
@prefix pav:	<http://purl.org/pav/> .
@prefix vs:     <http://www.w3.org/2003/06/sw-vocab-status/ns#> .
@prefix vann:   <http://purl.org/vocab/vann/> .
@prefix foaf:   <http://xmlns.com/foaf/0.1/> .

@prefix imf:	<http://ns.imfid.org/imf#> .
@prefix ex:	<http://example.com#> .
#+end_example

*** IMF prefixes

#+NAME: prefixes-imf
#+BEGIN_SRC ttl :noweb yes
<<prefixes-std>>

@prefix imf:	   <http://ns.imfid.org/imf#> .
@prefix pca-plm:   <http://rds.posccaesar.org/ontology/plm/rdl/> .
#+END_SRC

*** OTTR template prefixes

#+NAME: prefixes-ottr
#+BEGIN_SRC ttl
@prefix ottr:        <http://ns.ottr.xyz/0.4/> .

@prefix o-rdf:       <http://tpl.ottr.xyz/rdf/0.1/> .
@prefix o-rdfs:      <http://tpl.ottr.xyz/rdfs/0.2/> .
@prefix o-owl-ax:    <http://tpl.ottr.xyz/owl/axiom/0.1/> .
@prefix o-owl-ma:    <http://tpl.ottr.xyz/owl/macro/0.1/> .
@prefix o-owl-rstr:  <http://tpl.ottr.xyz/owl/restriction/0.1/> .
@prefix o-owl-dec:   <http://tpl.ottr.xyz/owl/declaration/0.1/> .

@prefix o-imf:	     <http://ns.imfid.org/templates/> .
@prefix o-imf-t-s:   <http://ns.imfid.org/templates/type/shacl/> .
@prefix o-imf-t-o:   <http://ns.imfid.org/templates/type/owl/> .
@prefix o-imf-d:     <http://ns.imfid.org/templates/data/> .
#+END_SRC

*** All prefixes combined                                          :noexport:

#+NAME: prefixes
#+BEGIN_SRC ttl :noweb yes
<<prefixes-imf>>

<<prefixes-ottr>>
#+END_SRC

#+RESULTS: prefixes
#+begin_example
@prefix xsd:	<http://www.w3.org/2001/XMLSchema#> .
@prefix rdf:	<http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:	<http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl:    <http://www.w3.org/2002/07/owl#> .
@prefix skos:	<http://www.w3.org/2004/02/skos/core#> .
@prefix pav:	<http://purl.org/pav/> .
@prefix sh:	<http://www.w3.org/ns/shacl#> .
@prefix shsh:   <http://www.w3.org/ns/shacl-shacl#> .
@prefix ex:	<http://example.com#> .
@prefix imf:	<http://ns.imfid.org/imf#> .

@prefix p14:    <http://example.com/P14#> .
@prefix ottr:        <http://ns.ottr.xyz/0.4/> .
@prefix o-rdf:       <http://tpl.ottr.xyz/rdf/0.1/> .
@prefix o-rdfs:       <http://tpl.ottr.xyz/rdfs/0.2/> .
@prefix o-owl-ax:    <http://tpl.ottr.xyz/owl/axiom/0.1/> .
@prefix o-owl-ma:    <http://tpl.ottr.xyz/owl/macro/0.1/> .
@prefix o-owl-rstr:  <http://tpl.ottr.xyz/owl/restriction/0.1/> .

@prefix o-imf:	     <http://ns.imfid.org/templates/> .
@prefix o-imf-t-s:   <http://ns.imfid.org/templates/type/shacl/> .
#+end_example

#+NAME: py_prefixes_sparql
#+BEGIN_SRC python :var prefixes=prefixes
output = ""

for p in prefixes.split("\n"):
  output += p.replace("@","").strip().strip(".") + "\n"

return output
#+END_SRC

#+RESULTS: py_prefixes_sparql
#+begin_example
prefix xsd:	<http://www.w3.org/2001/XMLSchema#>
prefix rdf:	<http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs:	<http://www.w3.org/2000/01/rdf-schema#>
prefix owl:    <http://www.w3.org/2002/07/owl#>
prefix skos:	<http://www.w3.org/2004/02/skos/core#>
prefix pav:	<http://purl.org/pav/>
prefix sh:	<http://www.w3.org/ns/shacl#>
prefix shsh:   <http://www.w3.org/ns/shacl-shacl#>
prefix ex:	<http://example.com#>
prefix imf:	<http://ns.imfid.org/imf#>

prefix p14:    <http://example.com/P14#>
prefix ottr:        <http://ns.ottr.xyz/0.4/>
prefix o-rdf:       <http://tpl.ottr.xyz/rdf/0.1/>
prefix o-rdfs:       <http://tpl.ottr.xyz/rdfs/0.2/>
prefix o-owl-ax:    <http://tpl.ottr.xyz/owl/axiom/0.1/>
prefix o-owl-ma:    <http://tpl.ottr.xyz/owl/macro/0.1/>
prefix o-owl-rstr:  <http://tpl.ottr.xyz/owl/restriction/0.1/>

prefix o-imf:	     <http://ns.imfid.org/templates/>
prefix o-imf-t-s:   <http://ns.imfid.org/templates/type/shacl/>
#+end_example




* System setup                                                     :noexport:
** Apache Jena

https://jena.apache.org/:

"A free and open source Java framework for building Semantic Web and
Linked Data applications", including reading and writing RDF, SHACL
validation and SPARQL query processing.

This section contains the script calls used for processing the RDF
code snippets in this document.

*** Download

#+BEGIN_SRC sh :results raw
cd bin
wget -O apache-jena.zip -nc -x https://dlcdn.apache.org/jena/binaries/apache-jena-4.4.0.zip
unzip apache-jena.zip
mv apache-jena-4.4.0 apache-jena
#+END_SRC


*** RIOT

Reading, writing and validating RDF.

#+BEGIN_SRC sh :results output verbatim
bin/apache-jena/bin/riot --help
#+END_SRC

#+RESULTS:
#+begin_example
riot [--help] [--time] [--base=IRI] [-syntax=FORMAT] [--out=FORMAT] [--count] file ...
  Parser control
      --sink                 Parse but throw away output
      --syntax=NAME          Set syntax (otherwise syntax guessed from file extension)
      --base=URI             Set the base URI (does not apply to N-triples and N-Quads)
      --check                Additional checking of RDF terms
      --strict               Run with in strict mode
      --validate             Same as --sink --check --strict
      --count                Count triples/quads parsed, not output them
      --rdfs=file            Apply some RDFS inference using the vocabulary in the file
      --nocheck              Turn off checking of RDF terms
  Output control
      --output=FMT           Output in the given format, streaming if possible.
      --formatted=FMT        Output, using pretty printing (consumes memory)
      --stream=FMT           Output, using a streaming format
      --compress             Compress the output with gzip
  Time
      --time                 Time the operation
  Symbol definition
      --set                  Set a configuration symbol to a value
  General
      -v   --verbose         Verbose
      -q   --quiet           Run with minimal output
      --debug                Output information for debugging
      --help
      --version              Version information
#+end_example

#+NAME: sh_jena_validate_rdf
#+BEGIN_SRC sh :results output verbatim :var syntax="TTL" :var files="out/owl/imf-ontology.owl.ttl"
bin/apache-jena/bin/riot --verbose --syntax=$syntax --validate --time $files
#+END_SRC

#+RESULTS: sh_jena_validate_rdf
: file:///home/martige/repo/imf-lab/imf-ontology/out/owl/imf-ontology.owl.ttl : 0.22 sec : 494 Triples : 2,235.29 per second

#+NAME: sh_jena_merge
#+BEGIN_SRC sh :results output verbatim :var syntax="TTL" :var files="out/owl/imf-elements.owl.ttl out/owl/imf-attributes.owl.ttl" :var out="out/owl/imf-ontology.owl.ttl"
bin/apache-jena/bin/riot --verbose --syntax=$syntax --check --time $files > $out
#+END_SRC

#+RESULTS: sh_jena_merge
: 08:47:29 INFO  riot            :: File: out/owl/imf-elements.owl.ttl
: file:///home/martige/repo/imf-lab/imf-ontology/out/owl/imf-elements.owl.ttl : 0.19 sec : 146 Triples : 768.42 per second
: 08:47:29 INFO  riot            :: File: out/owl/imf-attributes.owl.ttl
: file:///home/martige/repo/imf-lab/imf-ontology/out/owl/imf-attributes.owl.ttl : 0.02 sec : 140 Triples : 7,000.00 per second
: Total           : 0.21 sec : 286 Triples : 1,361.90 per second

*** SHACL

Validate RDF wrt. SHACL shapes.

#+BEGIN_SRC sh :results output verbatim
bin/apache-jena/bin/shacl v --help
#+END_SRC

#+RESULTS:
#+begin_example
shacl_validate [--target URI] --shapes shapesFile --data dataFile
  General
      -v   --verbose         Verbose
      -q   --quiet           Run with minimal output
      --debug                Output information for debugging
      --help
      --version              Version information
      --shapes               Shapes file
      --data                 Data file
      --target               Validate specific node [may use prefixes from the data]
      --text                 Output in concise text format
#+end_example

#+NAME: sh_jena_shacl_validate
#+BEGIN_SRC sh :results output raw :var shapes="shapefile" :var data="rdf-examples/coffee-machine.ttl" :wrap src ttl
for shape in $shapes 
do
  for dat in $data 
  do
    echo "Validating RDF data <$dat> against SHACL shape <$shape>:"
    bin/apache-jena/bin/shacl v --text --shapes $shape --data $dat
    echo
  done
done
#+END_SRC

#+NAME: sh_jena_shacl_std_validate
#+BEGIN_SRC sh :results output raw :var data="out/owl/imf-ontology.owl.ttl" :wrap src ttl
echo "Result of validating RDF data <$data> against SHACL shape <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl>:\n"
bin/apache-jena/bin/shacl v --text --shapes http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl --data $data
#+END_SRC

#+RESULTS: sh_jena_shacl_std_validate
#+BEGIN_src ttl
Result of validating data <out/owl/imf-ontology.owl.ttl> against shape <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl>:

Conforms
#+END_src

*** SPARQL

Query RDF.

#+BEGIN_SRC sh :results output verbatim
bin/apache-jena/bin/sparql --help
#+END_SRC

#+RESULTS:
#+begin_example
sparql --data=<file> --query=<query>
  Control
      --explain              Explain and log query execution
      --repeat=N or N,M      Do N times or N warmup and then M times (use for timing to overcome start up costs of Java)
      --optimize=            Turn the query optimizer on or off (default: on)
  Time
      --time                 Time the operation
  Query Engine
      --engine=EngineName    Register another engine factory[ref]
      --unengine=EngineName   Unregister an engine factory
  Dataset
      --data=FILE            Data for the dataset - triple or quad formats
      --graph=FILE           Graph for default graph of the datset
      --namedGraph=FILE      Add a graph into the dataset as a named graph
  Results
      --results=             Results format (Result set: text, XML, JSON, CSV, TSV; Graph: RDF serialization)
      --desc=                Assembler description file
  Query
      --query, --file        File containing a query
      --syntax, --in         Syntax of the query
      --base                 Base URI for the query
  Symbol definition
      --set                  Set a configuration symbol to a value
  General
      -v   --verbose         Verbose
      -q   --quiet           Run with minimal output
      --debug                Output information for debugging
      --help
      --version              Version information
      --strict               Operate in strict SPARQL mode (no extensions of any kind)
#+end_example


#+NAME: sh_jena_sparql
#+BEGIN_SRC sh :results output :var query="PREFIX imf: <http://ns.imfid.org/imf#> SELECT * {?s ?p ?o} LIMIT 1" :var files="out/owl/imf-ontology.owl.ttl" :hlines yes :exports both
echo "$query" > out/temp/.temp-sh_jena_sparql
bin/apache-jena/bin/sparql --results=text --data=$files --query out/temp/.temp-sh_jena_sparql
#+END_SRC

#+RESULTS: sh_jena_sparql
: ---------------------------------------------------------------------------------------------------------------
: | s    | p                                                 | o                                                |
: ===============================================================================================================
: | _:b0 | <http://www.w3.org/1999/02/22-rdf-syntax-ns#rest> | <http://www.w3.org/1999/02/22-rdf-syntax-ns#nil> |
: ---------------------------------------------------------------------------------------------------------------

** Lutra

Lutra is the reference implementation for working with OTTR templates
and instances.

This section contains the scripts that are used to expand the OTTR
instances found in this document.

#+BEGIN_SRC sh
cd bin
wget -O lutra.jar -nc -x http://ottr.xyz/downloads/lutra/lutra-master.jar
#+END_SRC

#+RESULTS:

#+NAME: lutra-help
#+BEGIN_SRC sh :results output verbatim
java -jar bin/lutra.jar --help
#+END_SRC

#+RESULTS: lutra-help
#+begin_example
Usage: lutra [-fhV] [--debugFullTrace] [--debugStackTrace] [--quiet] [--stdout]
	     [-F=<fetchFormat>] [--haltOn=<haltOn>] [-I=<inputFormat>]
	     [-L=<libraryFormat>] [-m=<mode>] [-o=<out>] [-O=<outputFormat>]
	     [-p=<prefixes>] [-e=<extensions>[,<extensions>...]]...
	     [-E=<ignoreExtensions>[,<ignoreExtensions>...]]...
	     [-l=<library>]... [<inputs>...]

DESCRIPTION:
Reference implementation for OTTR Templates. Use for expanding template
instances and template definitions, translating between different formats and
for checking the integrity of template libraries.

PARAMETERS:
      [<inputs>...]         Files of instances to which operations are to be
			      applied.

OPTIONS:
      --debugFullTrace      This enables tracing such that printed messages get
			      a stack trace giving more information on the
			      location of the concerned objects. NB! Enabling
			      this flag will deteriorate performance.
			    default: false)
      --debugStackTrace     This enables printing a regular java stack trace
			      for error messages.Enabling this flag will not
			      deteriorate performance.
			    default: false)
  -e, --extension=<extensions>[,<extensions>...]
			    File extension of files to use as input to template
			      library.
			    (default: [])
  -E, --ignoreExtension=<ignoreExtensions>[,<ignoreExtensions>...]
			    File extensions of files to ignore as input to
			      template library.
			    (default: [])
  -f, --fetchMissing        Fetch missing template dependencies. It is here
			      assumed that templates' definitions are
			      accessible via their IRI, that is, the IRI is
			      either a path to a file, a URL, or similar.
			    (default: false)
  -F, --fetchFormat=<fetchFormat>
			    The input format of the templates fetched via the
			      -f flag.
  -h, --help                Show this help message and exit.
      --haltOn=<haltOn>     Halt execution upon receiving messages with a
			      severity equal to or greater than this value.
			    (legal values: INFO, WARNING, ERROR, FATAL;
			      default: ERROR)
  -I, --inputFormat=<inputFormat>
			    Input format of instances.
			    (legal values: wottr, stottr, tabottr, bottr
			      default: wottr)
  -l, --library=<library>   Folder containing templates to use as library. Can
			      be used multiple times for multiple libraries.
  -L, --libraryFormat=<libraryFormat>
			    The input format of the libraries. If omitted, all
			      available formats are attempted.
			    (legal values: wottr, stottr)
  -m, --mode=<mode>         The mode of operation to be applied to input.
			    (legal values: expand, expandLibrary, format,
			      formatLibrary, lint, checkSyntax, docttrLibrary;
			      default: expand)
  -o, --output=<out>        Path for writing output.
  -O, --outputFormat=<outputFormat>
			    Output format of output of operation defined by the
			      mode.
			    (legal values: wottr, stottr; default: wottr)
  -p, --prefixes=<prefixes> Path to RDF file containing prefix declarations to
			      be used when rendering output.    Any other data
			      in the file is read, but ignored.
      --quiet               Suppress all messages, including errors and
			      warnings.
			    (default: false)
      --stdout              Print system of operations to standard out.
			    (default: false)
  -V, --version             Print version information and exit.

LINKS:
Website:  https://ottr.xyz
Primers:  https://primer.ottr.xyz
Git repo: https://gitlab.com/ottr/lutra/lutra
#+end_example

#+NAME: lutra-expand
#+BEGIN_SRC sh :results output verbatim :var in="out/owl/imf-aspects.owl.wottr.ttl" :var inFormat="wottr" :var out="out/owl/imf-aspects.owl.ttl"
java -jar bin/lutra.jar -l out/ottr -L stottr -f -p out/.std-prefixes.ttl -I $inFormat -o $in.temp $in
rapper -i turtle -o turtle $in.temp > $out
rm $in.temp
#+END_SRC

#+RESULTS: lutra-expand
** RDFVizler with rules

https://rdfvizler.dyreriket.xyz/:

#+BEGIN_QUOTE
RDFVizler is a simple RDF visualisation software built with the Apache
Jena Java API and Graphviz visualisation software. It requires Java 8
and Graphviz to be installed on the system.

RDFVizler visualises RDF graphs by parsing a designated RDFVizler OWL
vocabulary into Graphviz's DOT language and then straight-forwardly to
images using the Graphviz software. The RDFVizler vocabulary acts as a
mere "RDF wrapper language" for the DOT language, all graph, edge and
node attributes are taken directly from DOT."
#+END_QUOTE

*** TODO Script calls

TODO: setup download

#+BEGIN_SRC sh :results output verbatim
java -jar bin/rdfvizler.jar --help
#+END_SRC

#+RESULTS:
#+begin_example

RDFVizler: RDF visualisation

Usage:
java -jar rdfvizler-[version].jar [--help] [--mergeInput] [--skipRules]
				  [--version]
				  [--inputFormatRDF=<inputFormatRDF>]
				  [--outputFormatRDF=<outputFormatRDF>]
				  [-i=<outputFormatImage>] [-r=<rules>]
				  [-x=<mode>] RDF_FILES...

Description:
RDFVizler visualises RDF by parsing a designated RDF RDFVizler vocabulary into
Graphviz syntax and processing this to a graph using Graphviz' dot software.
For more details, see http://rdfvizler.dyreriket.xyz.

Parameters:
      RDF_FILES...      Input RDF: URIs or file paths

Options:
  -x, --executionMode=<mode>
			What output to produce. (legal values: rdf, dot, image;
			  default: image)
  -r, --rules=<rules>   Input rules: URI or file path (default: http://rdfvizler.
			  dyreriket.xyz/rules/rdf.jrule)
      --skipRules       Skip rule application to input? (default: false)
      --inputFormatRDF=<inputFormatRDF>
			Format of RDF input (legal values: rdf, ttl, nt, guess;
			  default: guess -- by file extension as per jena.util.
			  FileUtils, then Turtle)
      --mergeInput      Merge input files to a single model to visualise?
      --outputFormatRDF=<outputFormatRDF>
			Format of RDF output (legal values: rdf, ttl, nt, guess;
			  default: rdf)
  -i, --outputFormatImage=<outputFormatImage>
			Format of image output (legal values: PNG, SVG,
			  SVG_STANDALONE, DOT, XDOT, PLAIN, PLAIN_EXT, PS, PS2,
			  JSON, JSON0, IMAP, CMAPX; default: SVG_STANDALONE)
      --version         Display version info
      --help            Display this help message
#+end_example


#+NAME: rdfvizler
#+BEGIN_SRC sh :results output verbatim :var rules="out/rdfvizler/import-hierarchy.rule" :var data="out/owl/imf-ontology.owl.ttl" :var output="out/.output-rdfvizler.svg"
java -jar bin/rdfvizler.jar --rules=$rules $data > $output
#+END_SRC

#+RESULTS: rdfvizler
#+begin_example
Exception in thread "main" picocli.CommandLine$ExecutionException: Error while running command (xyz.dyreriket.rdfvizler.cli.RDFVizlerCLI@66498326): org.apache.jena.shared.RulesetNotFoundException: out/rdfvizler/import-hierarchy.rule
	at picocli.CommandLine.execute(CommandLine.java:1056)
	at picocli.CommandLine.access$900(CommandLine.java:142)
	at picocli.CommandLine$RunLast.handle(CommandLine.java:1255)
	at picocli.CommandLine$RunLast.handle(CommandLine.java:1223)
	at picocli.CommandLine$AbstractParseResultHandler.handleParseResult(CommandLine.java:1131)
	at picocli.CommandLine.parseWithHandlers(CommandLine.java:1414)
	at picocli.CommandLine.run(CommandLine.java:1878)
	at picocli.CommandLine.run(CommandLine.java:1808)
	at xyz.dyreriket.rdfvizler.cli.RDFVizlerCLI.main(RDFVizlerCLI.java:133)
Caused by: org.apache.jena.shared.RulesetNotFoundException: out/rdfvizler/import-hierarchy.rule
	at org.apache.jena.reasoner.rulesys.Rule.rulesFromURL(Rule.java:511)
	at org.apache.jena.reasoner.rulesys.Rule.rulesFromURL(Rule.java:524)
	at xyz.dyreriket.rdfvizler.RDFVizler.getRules(RDFVizler.java:39)
	at xyz.dyreriket.rdfvizler.RDFVizler.getRDFDotModel(RDFVizler.java:72)
	at xyz.dyreriket.rdfvizler.RDFVizler.writeDotGraph(RDFVizler.java:105)
	at xyz.dyreriket.rdfvizler.RDFVizler.writeDotGraph(RDFVizler.java:111)
	at xyz.dyreriket.rdfvizler.RDFVizler.write(RDFVizler.java:99)
	at xyz.dyreriket.rdfvizler.cli.RDFVizlerCLI.processFile(RDFVizlerCLI.java:156)
	at xyz.dyreriket.rdfvizler.cli.RDFVizlerCLI.run(RDFVizlerCLI.java:166)
	at picocli.CommandLine.execute(CommandLine.java:1048)
	... 8 more
#+end_example

*** Prefixes                                                       :noexport:

#+NAME: prefixes-rdfvizler
#+BEGIN_SRC ttl :noweb yes :tangle out/rdfvizler/imf-data.rule :mkdirp yes
<<prefixes>>
@prefix rvz:  <http://rdfvizler.dyreriket.xyz/vocabulary/core#> .
@prefix rvz-a: <http://rdfvizler.dyreriket.xyz/vocabulary/attribute#> .
@prefix rvz-n: <http://rdfvizler.dyreriket.xyz/vocabulary/attribute-default-node#> .
@prefix rvz-e: <http://rdfvizler.dyreriket.xyz/vocabulary/attribute-default-edge#> .
@prefix :      <urn:temp#>
#+END_SRC

*** IMF data, old                                                  :noexport:

#+BEGIN_SRC ttl :noweb yes :mkdirp yes
<<prefixes-rdfvizler>>

### GRAPH default settings
    [init:
	->
	(:graph rdf:type rvz:RootGraph)
	(:graph rdf:type rvz:DiGraph)
	(:graph rvz-a:rankdir "LR")
	(:graph rvz-a:nodesep "1")
	(:graph rvz-a:ranksep "1")
	(:graph rvz-a:center "true")
	(:graph rvz-a:overlap "true")
	(:graph rvz-a:splines "ortho")
	// node defaults
	(:graph rvz-n:fontname "Arial")
	(:graph rvz-n:fontsize "8px")
	(:graph rvz-n:height ".3")
	(:graph rvz-n:width ".3")
	(:graph rvz-n:fixedsize "true")
	// edge defaults
	(:graph rvz-e:fontname "Arial")
	(:graph rvz-e:fontsize "8px")
	]

### SELECTION: This rule selects the triples to be drawn. Selection is
### done on the basis of predicates. ONLY the nodes and edges selected
### here appear in the diagram.

    [triples:
	(?s ?p ?o)
	equalssome(?p, imf:hasPart, imf:hasTerminal, imf:connectedTo, imf:hasLocation, imf:fulfilledBy, imf:installedAs)
	makeSkolem(?edge, ?s, ?p, ?o)
	->
	(:graph rvz:hasEdge ?edge)
	(?edge :predicate ?p)
	(:graph rvz:hasNode ?s)
	(:graph rvz:hasNode ?o)
	(?edge rvz:hasSource ?s)
	(?edge rvz:hasTarget ?o)
	]

### EDGE FORMATTING

# constraint=false, see https://graphviz.org/docs/attrs/constraint/
    [imf:no-constraint:
	(?edge :predicate ?p)
	equalssome(?p, imf:connectedTo, imf:hasLocation, imf:fulfilledBy, imf:installedAs)
	->
	(?edge rvz-a:constraint "false")
	]

    [imf:hasPart:
	(?edge :predicate imf:hasPart)
	->
	(?edge rvz-a:arrowtail "empty")
	(?edge rvz-a:dir "back")
	]

    [imf:connectedTo:
	(?edge :predicate imf:connectedTo)
	->
	(?edge rvz-a:arrowhead "none")
	(?edge rvz-a:color "gray50")
	(?edge rvz-a:style "dashed")
	]
    [imf:hasTerminal:
	(?edge :predicate imf:hasTerminal)
	->
	(?edge rvz-a:arrowhead "none")
	]


    [imf:hasLocation:
	(?edge :predicate imf:hasLocation)
	->
	(?edge rvz-a:color "magenta")
	(?edge rvz-a:arrowhead "none")
	(?edge rvz-a:style "dashed")
	]

    [imf:fullfilledBy:
	(?edge :predicate imf:fulfilledBy)
	->
	(?edge rvz-a:color "cyan")
	(?edge rvz-a:arrowhead "none")
	(?edge rvz-a:style "dashed")
	]

    [imf:installedAs:
	(?edge :predicate imf:installedAs)
	->
	(?edge rvz-a:color "skyblue2")
	(?edge rvz-a:arrowhead "none")
	(?edge rvz-a:style "dashed")
	]

### NODE FORMATTING
### labels and URIs

    [Nodes:
	(:graph rvz:hasNode ?node)
	shortvalue(?node, ?name)
	->
	//(?node rvz-a:label "")
	(?node rvz-a:label ?name)
	(?node rvz-a:style "filled")
	(?node rvz-a:URL ?node)
	]

### Shapes: move these to ontology

    [Transport-shape:
	(:graph rvz:hasNode ?node)(?node rdf:type imf:Transport)
	->
	(?node rvz-a:shape "hexagon")
	]

    [Interface-shape:
	(:graph rvz:hasNode ?node)(?node rdf:type imf:Interface)
	->
	(?node rvz-a:shape "triangle")
	(?node rvz-a:orientation "90")
	]

    [Terminal-block-shape:
	(:graph rvz:hasNode ?node)(?node rdf:type imf:Terminal)
	-> (?node rvz-a:shape "doublecircle")
	]

    [System-block-shape:
	(:graph rvz:hasNode ?node)(?node rdf:type imf:FunctionalBlock)
	-> (?node rvz-a:shape "square")
	]


### Colours

    [Aspect-colour:
	(:graph rvz:hasNode ?node)
	(?node imf:hasAspect ?aspect)(?aspect imf:color ?color)
	->
	(?node rvz-a:fillcolor ?color)
	]

#+END_SRC

*** Ontology import hierarchy

This rule set visualises the owl:imports hierarchy.

#+BEGIN_SRC ttl :noweb yes :tangle out/rdfvizler/ontology-import-hierarchy.rule :mkdirp yes
<<prefixes-rdfvizler>>

### GRAPH default settings
    [init:
	->
	(:graph rdf:type rvz:RootGraph)
	(:graph rdf:type rvz:DiGraph)
	(:graph rvz-a:rankdir "LR")
	(:graph rvz-a:center "true")
	(:graph rvz-a:overlap "true")
	// node defaults
	(:graph rvz-n:fontname "Arial")
	(:graph rvz-n:fontsize "8px")
	// edge defaults
	(:graph rvz-e:fontname "Arial")
	(:graph rvz-e:fontsize "8px")
	]

    [imports:
	(?ont owl:versionIRI ?iri)
	(?ont owl:imports ?import)
	makeSkolem(?_edge, ?iri, ?import)
	->
	(:graph rvz:hasEdge ?_edge)
	(:graph rvz:hasNode ?iri)
	(:graph rvz:hasNode ?import)
	(?_edge rvz:hasSource ?iri)
	(?_edge rvz:hasTarget ?import)
	]
#+END_SRC

#+CALL: rdfvizler(rules="out/rdfvizler/ontology-import-hierarchy.rule", output="out/temp/.ontology-import-hierarchy.svg")

#+RESULTS:

*** Ontology overview

This rule set creates a overview visualisation of an ontology taking
only the "easy to visualise" structures like classes, subclass
relations, properties with their domain and range, and instances.

#+BEGIN_SRC ttl :noweb yes :tangle out/rdfvizler/ontology-overview.rule :mkdirp yes
<<prefixes-rdfvizler>>

    [init-graph:
	->
	(:graph rdf:type rvz:RootGraph)
	(:graph rdf:type rvz:DiGraph)
	(:graph rvz-a:rankdir "BT")
	(:graph rvz-a:center "true")
	// node defaults
	(:graph rvz-n:shape "box")
	(:graph rvz-n:fontname "Arial")
	(:graph rvz-n:fontsize "8px")
	// edge defaults
	(:graph rvz-e:fontname "Arial")
	(:graph rvz-e:fontsize "8px")
	]

    [class:
	(?s rdf:type owl:Class)
	notBNode(?s)
	->
	(:graph rvz:hasNode ?s)
	]

    [individual:
	(:graph rvz:hasNode ?s)
	(?i rdf:type ?s)
	makeSkolem(?edge, ?i, rdf:type, ?s)
	->
	(:graph rvz:hasNode ?i)
	(:graph rvz:hasEdge ?edge)
	(?edge :predicate rdf:type)
	(?edge rvz-a:style "dotted")
	(?edge rvz:hasSource ?i)
	(?edge rvz:hasTarget ?s)
	]

    [label-node:
	(:graph rvz:hasNode ?node)
	shortvalue(?node ?label)
	->
	(?node rvz-a:label ?label)
	]

    [subclass:
	(?s rdfs:subClassOf ?o)
	makeSkolem(?edge, ?s, rdfs:subClassOf, ?o)
	->
	(:graph rvz:hasEdge ?edge)
	(?edge :predicate ?p)
	(?edge rvz-a:arrowhead "empty")
	(?edge rvz-a:dir "forward")
	(:graph rvz:hasNode ?s)
	(:graph rvz:hasNode ?o)
	(?edge rvz:hasSource ?s)
	(?edge rvz:hasTarget ?o)
	]

    [property:
	(?p rdfs:domain ?domain)
	(?p rdfs:range ?range)
	shortvalue(?p ?label)
	makeSkolem(?edge, ?domain, ?p, ?range)
	->
	(:graph rvz:hasEdge ?edge)
	(:graph rvz:hasNode ?domain)
	(:graph rvz:hasNode ?range)
	(?edge :predicate ?p)
	(?edge rvz-a:label ?label)
	(?edge rvz:hasSource ?domain)
	(?edge rvz:hasTarget ?range)
	]

    [SubObjectExactCardinality:
	(?i ottr:of o-owl-ax:SubObjectExactCardinality)
	(?i ottr:values ?arg1)
	(?arg1 rdf:first ?domain)
	(?arg1 rdf:rest ?arg2)
	(?arg2 rdf:first ?card)
	(?arg2 rdf:rest ?arg3)
	(?arg3 rdf:first ?property)
	(?arg3 rdf:rest ?arg4)
	(?arg4 rdf:first ?range)
	shortvalue(?property ?plabel)
	strConcat(?plabel, " ", ?card, ?label)
	makeSkolem(?edge, ?domain, ?card, ?property, ?range)
	->
	(:graph rvz:hasEdge ?edge)
	(:graph rvz:hasNode ?domain)
	(:graph rvz:hasNode ?range)
	(?edge :predicate ?property)
	(?edge rvz-a:label ?label)
	(?edge rvz-a:constraint "false")
	(?edge rvz-a:dir "forward")
	(?edge rvz-a:arrowhead "teetee")
	(?edge rvz:hasSource ?domain)
	(?edge rvz:hasTarget ?range)
	]

    [Blanks:
	(:graph rvz:hasNode ?node)
	isBNode(?node)
	typedvalue(?node, ?label)
	->
	(?node rvz-a:label ?label)
	(?node rvz-a:shape "box")
	(?node rvz-a:style "filled,dashed")
	(?node rvz-a:fillcolor "gray90")
	(?node rvz-a:height ".3")
	(?node rvz-a:width ".3")
	]
#+END_SRC

#+CALL: rdfvizler(rules="out/rdfvizler/ontology-overview.rule", output="out/temp/.ontology-overview.svg")

#+RESULTS:

*** TODO IMF data
**** Test data

#+BEGIN_SRC ttl :noweb yes :tangle test/a.ttl :mkdirp yes
<<prefixes-imf>>

ex:B1 a imf:Block ;
  imf:hasTerminal ex:T11 ;
  imf:hasTerminal ex:T12 ;
  imf:hasTerminal ex:T13 .

ex:B2 a imf:Block ;
  imf:hasTerminal ex:T21 ;
  imf:hasTerminal ex:T22 ;
  imf:hasTerminal ex:T23 .

ex:T11 a imf:Terminal .
ex:T12 a imf:Terminal .
ex:T13 a imf:Terminal .

ex:T21 a imf:Terminal .
ex:T22 a imf:Terminal .
ex:T23 a imf:Terminal .


ex:C1 a imf:ConnectionPoint .

ex:T12 imf:R ex:C1 .
ex:C1  imf:R ex:T21 .

#+END_SRC

#+CALL: rdfvizler(data="test/a.ttl", rules="out/rdfvizler/imf-data.rule", output="test/a.ttl.svg")

#+RESULTS:

**** Viz rules
Work in process. Rule set for visualising IMF data.

#+BEGIN_SRC ttl :noweb yes :tangle out/rdfvizler/imf-data.rule :mkdirp yes
<<prefixes-rdfvizler>>

### GRAPH default settings
    [init:
	->
	(:graph rdf:type rvz:RootGraph)
	(:graph rdf:type rvz:DiGraph)
	(:graph rvz-a:rankdir "LR")
	//# (:graph rvz-a:nodesep "1")
	//# (:graph rvz-a:ranksep "1")
	(:graph rvz-a:center "true")
	(:graph rvz-a:overlap "true")
	//# (:graph rvz-a:splines "ortho")
	//# node defaults
	(:graph rvz-n:fontname "Arial")
	(:graph rvz-n:fontsize "11px")
	(:graph rvz-n:fixedsize "true")
	//# edge defaults
	(:graph rvz-e:fontname "Arial")
	(:graph rvz-e:fontsize "11px")
	]


    [classes:
	(?s rdf:type ?type)
	equalssome(?type, imf:Block imf:Terminal imf:ConnectionPoint)
	->
	(:graph rvz:hasNode ?s)
	]


    [triples:
	(?s ?p ?o)
	equalssome(?p, imf:hasPart, imf:hasTerminal, imf:connectedTo, imf:R)
	makeSkolem(?edge, ?s, ?p, ?o)
	->
	(:graph rvz:hasEdge ?edge)
	(?edge :predicate ?p)
	(:graph rvz:hasNode ?s)
	(:graph rvz:hasNode ?o)
	(?edge rvz:hasSource ?s)
	(?edge rvz:hasTarget ?o)
	]

## class formatting

    [block-formatting:
	(:graph rvz:hasNode ?x)
	(?x rdf:type imf:Block)
	shortvalue(?x ?label)
	->
	(?x rvz-a:label  ?label)
	(?x rvz-a:shape  "rectangle")
	//# (?x rvz-a:height ".4")
	//# (?x rvz-a:width  ".9")
	]

    [terminal-formatting:
	(:graph rvz:hasNode ?x)
	(?x rdf:type imf:Terminal)
	->
	(?x rvz-a:label  "") //# drop label
	(?x rvz-a:shape  "square")
	(?x rvz-a:height ".1")
	(?x rvz-a:width  ".1")
	]

    [connectionpoint-formatting:
	(:graph rvz:hasNode ?x)
	(?x rdf:type imf:ConnectionPoint)
	->
	(?x rvz-a:label  "") //# drop label
	(?x rvz-a:shape  "circle")
	(?x rvz-a:height ".3")
	(?x rvz-a:width  ".3")
	]

## property formatting

    [hasTerminal-formatting:
	(:graph rvz:hasEdge ?x)
	(?x :predicate imf:hasTerminal)
	->
	(?x rvz-a:arrowhead "none")
	(?x rvz-a:dir "forward")
	]



### EDGE FORMATTING

# constraint=false, see https://graphviz.org/docs/attrs/constraint/
    [imf:no-constraint:
	(?edge :predicate ?p)
	equalssome(?p, imf:hasTerminal, imf:connectedTo)
	->
	// (?edge rvz-a:constraint "false")
	]

    [edge-attribute
	(:graph rvz:hasEdge ?edge)
	(?edge :predicate ?p)
	(?p ?rvza ?value)
	namespace(?rvza, "http://rdfvizler.dyreriket.xyz/vocabulary/attribute#")
	->
	(?edge ?rvza ?value)
	]

    [node-attribute
	(:graph rvz:hasNode ?node)
	(?node rdf:type ?class)
	(?class ?rvza ?value)
	namespace(?rvza, "http://rdfvizler.dyreriket.xyz/vocabulary/attribute#")
	->
	(?node ?rvza ?value)
	]
#+END_SRC

#+RESULTS:
#+begin_example
@prefix xsd:	<http://www.w3.org/2001/XMLSchema#> .
@prefix rdf:	<http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:	<http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl:    <http://www.w3.org/2002/07/owl#> .
@prefix sh:	<http://www.w3.org/ns/shacl#> .

@prefix dc:	<http://purl.org/dc/elements/1.1/> .
@prefix foaf:   <http://xmlns.com/foaf/0.1/> .
@prefix pav:	<http://purl.org/pav/> .
@prefix skos:	<http://www.w3.org/2004/02/skos/core#> .
@prefix vann:   <http://purl.org/vocab/vann/> .
@prefix vs:     <http://www.w3.org/2003/06/sw-vocab-status/ns#> .

@prefix ex:	<http://example.com#> .

@prefix imf:	   <http://ns.imfid.org/imf#> .
@prefix pca-plm:   <http://rds.posccaesar.org/ontology/plm/rdl/> .

@prefix ottr:        <http://ns.ottr.xyz/0.4/> .

@prefix o-rdf:       <http://tpl.ottr.xyz/rdf/0.1/> .
@prefix o-rdfs:      <http://tpl.ottr.xyz/rdfs/0.2/> .
@prefix o-owl-ax:    <http://tpl.ottr.xyz/owl/axiom/0.1/> .
@prefix o-owl-ma:    <http://tpl.ottr.xyz/owl/macro/0.1/> .
@prefix o-owl-rstr:  <http://tpl.ottr.xyz/owl/restriction/0.1/> .
@prefix o-owl-dec:   <http://tpl.ottr.xyz/owl/declaration/0.1/> .

@prefix o-imf:	     <http://ns.imfid.org/templates/> .
@prefix o-imf-t-s:   <http://ns.imfid.org/templates/type/shacl/> .
@prefix o-imf-t-o:   <http://ns.imfid.org/templates/type/owl/> .
@prefix o-imf-d:     <http://ns.imfid.org/templates/data/> .
@prefix rvz:  <http://rdfvizler.dyreriket.xyz/vocabulary/core#> .
@prefix rvz-a: <http://rdfvizler.dyreriket.xyz/vocabulary/attribute#> .
@prefix rvz-n: <http://rdfvizler.dyreriket.xyz/vocabulary/attribute-default-node#> .
@prefix rvz-e: <http://rdfvizler.dyreriket.xyz/vocabulary/attribute-default-edge#> .
@prefix :      <urn:temp#>

### GRAPH default settings
    [init:
	->
	(:graph rdf:type rvz:RootGraph)
	(:graph rdf:type rvz:DiGraph)
	(:graph rvz-a:rankdir "LR")
	//# (:graph rvz-a:nodesep "1")
	//# (:graph rvz-a:ranksep "1")
	(:graph rvz-a:center "true")
	(:graph rvz-a:overlap "true")
	//# (:graph rvz-a:splines "ortho")
	//# node defaults
	(:graph rvz-n:fontname "Arial")
	(:graph rvz-n:fontsize "11px")
	(:graph rvz-n:fixedsize "true")
	//# edge defaults
	(:graph rvz-e:fontname "Arial")
	(:graph rvz-e:fontsize "11px")
	]


    [classes:
	(?s rdf:type ?type)
	equalssome(?type, imf:Block imf:Terminal imf:ConnectionPoint)
	->
	(:graph rvz:hasNode ?s)
	]


    [triples:
	(?s ?p ?o)
	equalssome(?p, imf:hasPart, imf:hasTerminal, imf:connectedTo, imf:R)
	makeSkolem(?edge, ?s, ?p, ?o)
	->
	(:graph rvz:hasEdge ?edge)
	(?edge :predicate ?p)
	(:graph rvz:hasNode ?s)
	(:graph rvz:hasNode ?o)
	(?edge rvz:hasSource ?s)
	(?edge rvz:hasTarget ?o)
	]

## class formatting

    [block-formatting:
	(:graph rvz:hasNode ?x)
	(?x rdf:type imf:Block)
	shortvalue(?x ?label)
	->
	(?x rvz-a:label  ?label)
	(?x rvz-a:shape  "rectangle")
	//# (?x rvz-a:height ".4")
	//# (?x rvz-a:width  ".9")
	]

    [terminal-formatting:
	(:graph rvz:hasNode ?x)
	(?x rdf:type imf:Terminal)
	->
	(?x rvz-a:label  "")
	(?x rvz-a:shape  "square")
	(?x rvz-a:height ".1")
	(?x rvz-a:width  ".1")
	]

    [connectionpoint-formatting:
	(:graph rvz:hasNode ?x)
	(?x rdf:type imf:ConnectionPoint)
	->
	(?x rvz-a:label  "")
	(?x rvz-a:shape  "circle")
	(?x rvz-a:height ".3")
	(?x rvz-a:width  ".3")
	]

## property formatting

    [hasTerminal-formatting:
	(:graph rvz:hasEdge ?x)
	(?x :predicate imf:hasTerminal)
	->
	(?x rvz-a:arrowhead "none")
	(?x rvz-a:dir "forward")
	]



### EDGE FORMATTING

# constraint=false, see https://graphviz.org/docs/attrs/constraint/
    [imf:no-constraint:
	(?edge :predicate ?p)
	equalssome(?p, imf:hasTerminal, imf:connectedTo)
	->
	// (?edge rvz-a:constraint "false")
	]

    [edge-attribute
	(:graph rvz:hasEdge ?edge)
	(?edge :predicate ?p)
	(?p ?rvza ?value)
	namespace(?rvza, "http://rdfvizler.dyreriket.xyz/vocabulary/attribute#")
	->
	(?edge ?rvza ?value)
	]

    [node-attribute
	(:graph rvz:hasNode ?node)
	(?node rdf:type ?class)
	(?class ?rvza ?value)
	namespace(?rvza, "http://rdfvizler.dyreriket.xyz/vocabulary/attribute#")
	->
	(?node ?rvza ?value)
	]
#+end_example

** Python code snippets
*** py Common functions

#+NAME: py_common_functions
#+BEGIN_SRC python
import rdflib

def getAllIRIs(data):
  graph = rdflib.Graph()
  iri = []

  graph.parse(data, format="ttl")

  for s, p, o in graph:
    if(isinstance(s, rdflib.term.URIRef)):
      iri.append(s)
    if(isinstance(p, rdflib.term.URIRef)):
      iri.append(p)
    if(isinstance(o, rdflib.term.URIRef)):
      iri.append(o)

  return set(iri)


#+END_SRC

*** py_ottr_instances

Convert tables to OTTR instances.

#+NAME: py_ottr_instances
#+BEGIN_SRC python :results raw :wrap src ttl :var template="ex:template" :var table=tbl-aspects :exports none
output = ""

instance = "[] ottr:of {} ;\n   ottr:values ( {} ) . \n"

## aspects
for row in table[0:]:
  args = map(lambda x: 'ottr:none' if not str(x).strip() else x, row)
  output += instance.format(template, " ".join(f'{w}' for w in args))

return output
#+END_SRC

#+RESULTS: py_ottr_instances
#+BEGIN_src ttl
[] ottr:of ex:template ;
   ottr:values( imf:FunctionAspect '=' '#FFFF00' ) .
[] ottr:of ex:template ;
   ottr:values( imf:LocationAspect '+' '#FF00FF' ) .
[] ottr:of ex:template ;
   ottr:values( imf:ProductAspect '-' '#00FFFF' ) .
[] ottr:of ex:template ;
   ottr:values( imf:ActivityAspect '>' '#000000' ) .
#+END_src

*** py_run_sparql

Run SPARQL queries on RDF data files. Output a table.

#+NAME: py_run_sparql
#+BEGIN_SRC python :var query="SELECT ?s ?p ?o {?s ?p ?o} LIMIT 10" :var prefixes=py_prefixes_sparql() :var data="out/owl/imf-ontology.owl.ttl" :var formatting="table" :results raw

# input: 'query': SPARQL query string
# input: 'prefixes': a string of prefixes for conveniently appending to the query
# input: 'data': the RDF dataset to query

import rdflib
import csv

graph = rdflib.Graph()

# read RDF turtle file:
graph.parse(data, format="ttl")

# query graph:
qResult = graph.query(prefixes + " " + query)

output = ""

# handle the results according to the query type

if qResult.type == "SELECT":

  # serialise results to string
  sResult = qResult.serialize(format="csv").decode('utf-8')

  lines = sResult.splitlines() # split on each new line
  reader = csv.reader(lines, delimiter=',')

  if formatting == 'table':
    line = 1
    for row in reader: # split on each new line
      output += "|"
      for value in row:
	if value.startswith("http://"):
	  value = ", ".join(map(graph.namespace_manager.qname, value.split(", ")))
	  #value = graph.namespace_manager.qname(value) # convert urls to qnames
	if len(value) > 0:
	  output += "~" + ' '.join(value.split()) + "~" # monospace formatting
	output += "|"
      output += "\n"
      if line == 1:
	output += "|-\n" # hline
      line += 1

  elif formatting == 'list1':
    line = 0
    for row in reader:
      line += 1
      if line == 1:
	continue
      output += " -"
      for value in row:
	if value.startswith("http://"):
	  value = ", ".join(map(graph.namespace_manager.qname, value.split(", ")))
	  #value = graph.namespace_manager.qname(value) # convert urls to qnames
	if len(value) > 0:
	  output += " " +' '.join(value.split())
      output += "\n"


elif qResult.type == "ASK":
  output = str(bool(qResult))

elif qResult.type == "CONSTRUCT":
  gResult = rdflib.Graph()
  gResult.namespace_manager = graph.namespace_manager # copy prefixes from data source
  for row in qResult:
    gResult.add(row);
  output = gResult.serialize(format='turtle').decode('utf-8')

return output
#+END_SRC

**** _playground                                                   :noexport:

#+NAME: sparql_elementversioning
#+BEGIN_SRC ttl
SELECT DISTINCT ?element (STRAFTER(?changeNote, ?versionNo) AS ?note)
{
 ?ont a owl:Ontology ;
   owl:versionInfo ?versionNo .
 ?element a ?elementType ;
   skos:changeNote ?changeNote .
 FILTER (?elementType != owl:Ontology)
 FILTER (STRSTARTS(?changeNote, ?versionNo))
}
ORDER BY ?element
#+END_SRC

#+CALL: py_run_sparql(query=sparql_elementversioning, formatting="list1")

#+RESULTS:
 - imf:Attribute :: Added
 - imf:AttributeQualifier :: Added
 - imf:BreakdownPoint :: Added
 - imf:ConnectionPoint :: Added
 - imf:Element :: Added
 - imf:Model :: Added
 - imf:ProvenanceQualifier :: Added
 - imf:RangeQualifier :: Added
 - imf:RegularityQualifier :: Added
 - imf:ScopeQualifier :: Added
 - imf:TerminalQualifier :: Added
 - imf:absoluteQualifier :: Added
 - imf:averageQualifier :: Added
 - imf:calculatedQualifier :: Added
 - imf:classifier :: Added
 - imf:connectedTo :: Changed IRI from imf:isConnectedTo to imf:connectedTo.
 - imf:continuousQualifier :: Added
 - imf:designQualifier :: Added
 - imf:externalReference :: Added
 - imf:functionAspect :: Changed: use lowerCamelCase for localname of IRI.
 - imf:hasAttribute :: Added
 - imf:hasAttributeQualifier :: Added
 - imf:hasElement :: Added
 - imf:hasTerminalQualifier :: Added
 - imf:inputFlow :: Added
 - imf:installedAspect :: Changed: use lowerCamelCase for localname of IRI.
 - imf:locationAspect :: Changed: use lowerCamelCase for localname of IRI.
 - imf:maximumQualifier :: Added
 - imf:measuredQualifier :: Added
 - imf:medium :: Added
 - imf:minimumQualifier :: Added
 - imf:nominalQualifier :: Added
 - imf:normalQualifier :: Added
 - imf:operatingQualifier :: Added
 - imf:outputFlow :: Added
 - imf:partOf :: Changed: IRI from imf:isPartOf to imf:partOf.
 - imf:predicate :: Added
 - imf:productAspect :: Changed: use lowerCamelCase for localname of IRI.
 - imf:purpose :: Added
 - imf:specifiedQualifier :: Added
 - imf:symbol :: Added
 - imf:theConnected :: Added
 - imf:theInput :: Added
 - imf:theOutput :: Added
 - imf:thePart :: Added
 - imf:theWhole :: Added
 - imf:uom :: Added
 - imf:value :: Added

*** py_imf_ontology_latex_export

#+NAME: py_make_latex_ontology_report
#+BEGIN_SRC python :var prefixes=py_prefixes_sparql() :results file
import rdflib
from rdflib import URIRef, BNode
from rdflib.namespace import NamespaceManager, OWL, SH, RDFS, RDF, DC, SKOS, VANN

ROOT = ""

ontology = rdflib.Graph()
ontology.parse(ROOT + "out/owl/imf-ontology.owl.ttl", format="ttl")
nm = NamespaceManager(ontology)

shacl = rdflib.Graph()
shacl.parse(ROOT + "out/shacl/imf-model-grammar.shacl.ttl", format="ttl")


def qname(x):
    if type(x) == URIRef:
	return nm.normalizeUri(x)
    elif type(x) == BNode:
	return "blank"
    else:
	return x


def texEnv(env, s):
    if s != '':
	return "\n\\begin{" + env + "}\n" + s.strip() + "\n\end{" + env + "}\n\n"
    else:
	return s


def texItem(term, predicate, name, joiner="\n\n", dir="X", graph=ontology, env='markdown'):
    if dir == "subjects":
	values = graph.subjects(predicate, term)
    else:
	values = graph.objects(term, predicate)

    values = list(filter(lambda x: type(x) != BNode, list(values)))

    if not bool(values):
	return ''
    else:
	if env == 'uris':
	    values = map(lambda x: "\\texttt{" + x + "}", sorted(map(qname, values)))
	    return "\item[" + name + "] " + joiner.join(values) + "\n"
	else:
	    return "\item[" + name + "] " + texEnv(env, joiner.join(values))


output = ""

# Get ontology metadata

txtOntology = ""
iriOntology = URIRef("http://ns.imfid.org/imf#IMFOntology")

txtOntology += str(ontology.value(iriOntology, DC.description)) + "\n\n"
txtOntology += str(ontology.value(iriOntology, SKOS.scopeNote))
output += texEnv('markdown', txtOntology)

# Ontology summary

output += "The ontology defines the following terms, categorised by their OWL type:\n\n"
txtEntities  = texItem(OWL.Class, RDF.type, "Classes", joiner=", ", dir="subjects", env='uris')
txtEntities += texItem(OWL.ObjectProperty, RDF.type, "Object properties", joiner=", ", dir="subjects", env='uris')
txtEntities += texItem(OWL.DatatypeProperty, RDF.type, "Data properties", joiner=", ", dir="subjects", env='uris')
txtEntities += texItem(OWL.AnnotationProperty, RDF.type, "Annotation properties", joiner=", ", dir="subjects", env='uris')
txtEntities += texItem(OWL.NamedIndividual, RDF.type, "Individuals", joiner=", ", dir="subjects", env='uris')
output += texEnv('description', txtEntities)

# Term definitions

groups = sorted(ontology.objects(None, VANN.termGroup, True), reverse=True)

output += "The terms are presented below, categorised in informal groups according to topic: " + texEnv('compactitem', "\n".join(map(lambda x: "\item " + x.capitalize(), groups)))

output += "Each group contains an informal diagram of the group's terms. Each term is presented with a selection of metadata, its basic OWL ontology definitions and the SHACL shape constraints defined for the term. The listing does not contain all OWL axioms and SHACL shape definitions as it is difficult to represent in condenced form, please consult the OWL ontology and SHACL shape description for all details.\n\n"

for group in groups:
    output += "\section{" + group.capitalize() + "}\n\n"
    output += "\\begin{figure}\centering\n"
    output += "\includegraphics[width=1\\textwidth]{img/ontology/imf-ontology-" + group + ".png}\n\caption{Ontology group: " + group + "}\n\label{fig:ontology-group-" + group + "}\n\end{figure}\n\n"

    for term in sorted(ontology.subjects(VANN.termGroup, group)):
	# metadata
	output += "\subsection{" + str(ontology.value(term, SKOS.prefLabel, None)) + "}\n"
	txtItems = "\item[IRI] \\texttt{" + qname(term) + "}\n"
	txtItems += texItem(term, SKOS.definition, "Definition")
	txtItems += texItem(term, SKOS.scopeNote, "Usage note")
	txtItems += texItem(term, SKOS.example, "Example")
	txtItems += texItem(term, SKOS.note, "Note")
	txtItems += texItem(term, RDF.type, "Type", joiner=", ", env='uris')
	txtItems += texItem(term, RDFS.subClassOf, "Superclass", joiner=", ", env='uris')
	txtItems += texItem(term, RDFS.subClassOf, "Subclass", joiner=", ", dir="subjects", env='uris')
	txtItems += texItem(term, RDFS.subPropertyOf, "Superproperty", joiner=", ", env='uris')
	txtItems += texItem(term, RDFS.subPropertyOf, "Subproperties", joiner=", ", dir="subjects", env='uris')
	txtItems += texItem(term, RDFS.domain, "Domain", joiner=", ", env='uris')
	txtItems += texItem(term, RDFS.range, "Range", joiner=", ", env='uris')
	txtItems += texItem(term, RDF.type, "Instances", joiner=", ", dir="subjects", env='uris')
	txtItems += texItem(term, SKOS.editorialNote, "Editoral note")
	output += texEnv('compactdesc', txtItems)

	# SHACL
	txtShacl = ""
	boolShacl = False
	termShape = URIRef(str(term) + "Shape")
	shprops = ['path', 'class', 'minCount', 'maxCount', 'severity', 'message']
	shpropsN = ['path', 'class', 'min', 'max', 'severity', 'message']

	tblEnd = " \\\\ \n"
	txtShacl += "{|" + 'l|' * len(shprops) + "}\n"
	txtShacl += "\\hline\n" + " & ".join(shpropsN) + tblEnd + "\\hline\n"
	for property in sorted(shacl.objects(termShape, SH.property)):
	    boolShacl = True
	    txtShacl += " & ".join([qname(shacl.value(property, SH[shp], None, default="")) for shp in shprops]) + tblEnd
	txtShacl += "\\hline\n"

	if boolShacl:
	    output += "\subsubsection*{SHACL Definition}\n" + texEnv('tabular', txtShacl)

f = open(ROOT + "out/imf-ontology.tex", "w")
f.write(output)
f.close()
#+END_SRC

#+RESULTS: py_make_latex_ontology_report
[[file:None]]

*** py_list_iris

#+NAME: py_list_iris
#+BEGIN_SRC python :noweb yes :var datafile="out/owl/imf-ontology.owl.ttl" :results raw
<<py_common_functions>>

iris = list(filter(lambda x: x.startswith("http://ns.imfid.org/imf#"), getAllIRIs(datafile)))
iris = ['<' + str(i) + '>' for i in iris]
iris.sort()

return ', '.join(iris)
#+END_SRC

#+RESULTS: py_list_iris
<http://ns.imfid.org/imf#>, <http://ns.imfid.org/imf#Aspect>, <http://ns.imfid.org/imf#AspectElement>, <http://ns.imfid.org/imf#Attribute>, <http://ns.imfid.org/imf#AttributeQualifier>, <http://ns.imfid.org/imf#Block>, <http://ns.imfid.org/imf#BreakdownPoint>, <http://ns.imfid.org/imf#ConnectionPoint>, <http://ns.imfid.org/imf#Element>, <http://ns.imfid.org/imf#FunctionBlock>, <http://ns.imfid.org/imf#FunctionElement>, <http://ns.imfid.org/imf#FunctionTerminal>, <http://ns.imfid.org/imf#IMFOntology>, <http://ns.imfid.org/imf#InputTerminal>, <http://ns.imfid.org/imf#InstalledBlock>, <http://ns.imfid.org/imf#InstalledElement>, <http://ns.imfid.org/imf#InstalledTerminal>, <http://ns.imfid.org/imf#LocationBlock>, <http://ns.imfid.org/imf#LocationElement>, <http://ns.imfid.org/imf#LocationTerminal>, <http://ns.imfid.org/imf#Model>, <http://ns.imfid.org/imf#OutputTerminal>, <http://ns.imfid.org/imf#ProductBlock>, <http://ns.imfid.org/imf#ProductElement>, <http://ns.imfid.org/imf#ProductTerminal>, <http://ns.imfid.org/imf#ProvenanceQualifier>, <http://ns.imfid.org/imf#RangeQualifier>, <http://ns.imfid.org/imf#RegularityQualifier>, <http://ns.imfid.org/imf#ScopeQualifier>, <http://ns.imfid.org/imf#Terminal>, <http://ns.imfid.org/imf#TerminalQualifier>, <http://ns.imfid.org/imf#absoluteQualifier>, <http://ns.imfid.org/imf#asFunction>, <http://ns.imfid.org/imf#asInstalled>, <http://ns.imfid.org/imf#asLocation>, <http://ns.imfid.org/imf#asProduct>, <http://ns.imfid.org/imf#associativeRelation>, <http://ns.imfid.org/imf#averageQualifier>, <http://ns.imfid.org/imf#calculatedQualifier>, <http://ns.imfid.org/imf#classifier>, <http://ns.imfid.org/imf#color>, <http://ns.imfid.org/imf#connectedTo>, <http://ns.imfid.org/imf#continuousQualifier>, <http://ns.imfid.org/imf#designQualifier>, <http://ns.imfid.org/imf#externalReference>, <http://ns.imfid.org/imf#functionAspect>, <http://ns.imfid.org/imf#hasAspect>, <http://ns.imfid.org/imf#hasAttribute>, <http://ns.imfid.org/imf#hasAttributeQualifier>, <http://ns.imfid.org/imf#hasElement>, <http://ns.imfid.org/imf#hasInputTerminal>, <http://ns.imfid.org/imf#hasOutputTerminal>, <http://ns.imfid.org/imf#hasPart>, <http://ns.imfid.org/imf#hasTerminal>, <http://ns.imfid.org/imf#hasTerminalQualifier>, <http://ns.imfid.org/imf#hierachicalRelation>, <http://ns.imfid.org/imf#hierarchicalRelation>, <http://ns.imfid.org/imf#inputFlow>, <http://ns.imfid.org/imf#installedAspect>, <http://ns.imfid.org/imf#interAspectRelation>, <http://ns.imfid.org/imf#intraAspectRelation>, <http://ns.imfid.org/imf#locationAspect>, <http://ns.imfid.org/imf#maximumQualifier>, <http://ns.imfid.org/imf#measuredQualifier>, <http://ns.imfid.org/imf#medium>, <http://ns.imfid.org/imf#minimumQualifier>, <http://ns.imfid.org/imf#nominalQualifier>, <http://ns.imfid.org/imf#normalQualifier>, <http://ns.imfid.org/imf#operatingQualifier>, <http://ns.imfid.org/imf#outputFlow>, <http://ns.imfid.org/imf#partOf>, <http://ns.imfid.org/imf#predicate>, <http://ns.imfid.org/imf#prefix>, <http://ns.imfid.org/imf#productAspect>, <http://ns.imfid.org/imf#specifiedQualifier>, <http://ns.imfid.org/imf#symbol>, <http://ns.imfid.org/imf#theConnected>, <http://ns.imfid.org/imf#theInput>, <http://ns.imfid.org/imf#theOutput>, <http://ns.imfid.org/imf#thePart>, <http://ns.imfid.org/imf#theWhole>, <http://ns.imfid.org/imf#uom>, <http://ns.imfid.org/imf#value>

*** py_iri_rdf_diff

Simple diff of 2 RDF files, output list of changed IRIs.

#+NAME: py_iri_rdf_diff
#+BEGIN_SRC python :noweb yes :var v2="out/owl/imf-ontology.owl.ttl" :var v1="https://ns.imfid.org/20221118/imf-vocabulary.owl.ttl" :results raw

<<py_common_functions>>

pGraph = rdflib.Graph()
pGraph.parse(v2, format="ttl")

def prepare(input):
  rL = list(input)
  rL2 = list(filter(lambda x: x.startswith("http://ns.imfid.org"), rL))
  rL2.sort()
  return list(map(pGraph.namespace_manager.qname, rL2))

iri1 = getAllIRIs(v1)
iri2 = getAllIRIs(v2)

inboth = iri1 & iri2
added = iri2 - iri1
deleted = iri1 - iri2

output = ""

output += " - IRIs present in both versions :: " + ", ".join(prepare(inboth)) + "\n\n"
output += " - IRIs present only in this version :: " + ", ".join(prepare(added)) + "\n\n"
output += " - IRIs present only in previous version :: " + ", ".join(prepare(deleted))

return output
#+END_SRC

#+RESULTS: py_iri_rdf_diff
 - IRIs present in both versions :: ns1:imf, imf:Aspect, imf:AspectElement, imf:Block, imf:FunctionBlock, imf:FunctionTerminal, imf:InputTerminal, imf:InstalledBlock, imf:InstalledTerminal, imf:LocationBlock, imf:LocationTerminal, imf:OutputTerminal, imf:ProductBlock, imf:ProductTerminal, imf:Terminal, imf:associativeRelation, imf:color, imf:hasAspect, imf:hasInputTerminal, imf:hasOutputTerminal, imf:hasPart, imf:hasTerminal, imf:hierarchicalRelation, imf:interAspectRelation, imf:intraAspectRelation, imf:prefix, imf:theInput, imf:theOutput

 - IRIs present only in this version :: ns2:imf, imf:, imf:Attribute, imf:AttributeQualifier, imf:BreakdownPoint, imf:ConnectionPoint, imf:Element, imf:FunctionElement, imf:InstalledElement, imf:LocationElement, imf:ProductElement, imf:ProvenanceQualifier, imf:RangeQualifier, imf:RegularityQualifier, imf:ScopeQualifier, imf:TerminalQualifier, imf:absoluteQualifier, imf:asFunction, imf:asInstalled, imf:asLocation, imf:asProduct, imf:averageQualifier, imf:calculatedQualifier, imf:classifier, imf:connectedTo, imf:continuousQualifier, imf:designQualifier, imf:externalReference, imf:functionAspect, imf:hasAttribute, imf:hasAttributeQualifier, imf:hasTerminalQualifier, imf:hierachicalRelation, imf:inputFlow, imf:installedAspect, imf:locationAspect, imf:maximumQualifier, imf:measuredQualifier, imf:medium, imf:minimumQualifier, imf:nominalQualifier, imf:normalQualifier, imf:operatingQualifier, imf:outputFlow, imf:partOf, imf:productAspect, imf:property, imf:specifiedQualifier, imf:symbol, imf:theConnected, imf:thePart, imf:theWhole, imf:uom, imf:value

 - IRIs present only in previous version :: ns3:imf-vocabulary, imf:FunctionAspect, imf:FunctionAspectElement, imf:FunctionInterfacePoint, imf:InstalledAspect, imf:InstalledAspectElement, imf:InstalledInterfacePoint, imf:InterAspectRelation, imf:InterfacePoint, imf:LocationAspect, imf:LocationAspectElement, imf:LocationInterfacePoint, imf:ProductAspect, imf:ProductAspectElement, imf:ProductInterfacePoint, imf:System, imf:SystemElement, imf:fulfilledBy, imf:fulfills, imf:isConnectedTo, imf:isPartOf, imf:memberOf

*** py_parse-ttl-file: Parse source block

Parses an ttl file and outputs a turtle source block.

#+NAME: py_parse-ttl-file
#+BEGIN_SRC python :var file="out/owl/imf-top.owl.ttl"
from rdflib import Graph

g = Graph()
g.parse(file, format="text/turtle")

return g.serialize(format='turtle').decode('utf-8')
#+END_SRC

#+RESULTS: py_parse-ttl-file

*** py_parse-ttl-block: Parse source block

Parses and outputs a turtle source block. Prefixes are given as input.

#+NAME: py_parse-ttl-block
#+BEGIN_SRC python :var prefixes=prefixes :var block=owl-top-ontology
from rdflib import Graph

g = Graph()
rdf = prefixes + "\n" + block
g.parse(data=rdf, format="text/turtle")

return g.serialize(format='turtle').decode('utf-8')
#+END_SRC

*** py Output RDF

#+NAME: py_output
#+BEGIN_SRC python :var file="out/owl/imf-top.owl.ttl" :var s="None" :var p="RDF.type"
from rdflib import Graph, RDF

g = Graph()
g.parse(file, format="text/turtle")

output = ""

for s, p, o in g.triples((s,  p, None)):
    output += f"{o}"

return output
#+END_SRC

#+RESULTS: py_output


*** Lists                                                          :noexport:

#+NAME: prefixlist
 - xsd :: http://www.w3.org/2001/XMLSchema#
 - rdf :: http://www.w3.org/1999/02/22-rdf-syntax-ns#
 - rdfs :: http://www.w3.org/2000/01/rdf-schema#
 - owl :: http://www.w3.org/2002/07/owl#
 - skos :: http://www.w3.org/2004/02/skos/core#
 - imf :: http://ns.imfid.org/imf#

#+NAME: py_functions
#+BEGIN_SRC python

## converts a org-mode definition list into a python dict
def deflist2dict(list):
  newlist={}
  for row in list:
    newrow = row[0].split(' :: ')
    newlist[newrow[0]] = newrow[1]

  return newlist

from rdflib import Graph, Namespace, URIRef

def getURIRef(prefixdict, qname):
  prefix, localname = qname.split(':')
  return URIRef(prefixdict[prefix] + localname)

def getGraph(prefixdict):
  graph = Graph()
  for key, value in prefixdict.items():
    ns = Namespace(value)
    graph.bind(key, ns)
  return graph
#+END_SRC

#+RESULTS: py_functions
: None

#+NAME: py_prefixlist2ttl
#+BEGIN_SRC python :noweb yes :var list=prefixlist
<<py_functions>>

output = ""
for key, value in deflist2dict(list).items():
  output += '@prefix ' + key + ':\t<' + value + '> .\n'
return output
#+END_SRC

#+RESULTS: py_prefixlist2ttl
: @prefix xsd:	<http://www.w3.org/2001/XMLSchema#> .
: @prefix rdf:	<http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
: @prefix rdfs:	<http://www.w3.org/2000/01/rdf-schema#> .
: @prefix skos:	<http://www.w3.org/2004/02/skos/core#> .
: @prefix imf:	<http://ns.imfid.org/imf#> .

#+CALL: py_prefixlist2ttl[:wrap src ttl](list=prefixlist)
** org-mode setup
*** stderr

Include stderr in source block output:

#+PROPERTY: header-args:sh :prologue "exec 2>&1" :epilogue ":"

*** Folders

#+BEGIN_SRC ttl :tangle out/temp/.folder :mkdirp yes
#+END_SRC

#+BEGIN_SRC ttl :tangle bin/.folder :mkdirp yes
#+END_SRC

#+BEGIN_SRC ttl :tangle out/img/.folder :mkdirp yes

#+END_SRC

*** Global tangle includes
**** Graphviz
#+NAME: graphviz-style
#+BEGIN_SRC dot :file out/img/.dummy-graphiz
 node [shape=box, fontname="Arial", style="filled"];
 edge [fontname="Arial"];
#+END_SRC


**** PlantUML

#+NAME: plantuml-style
#+BEGIN_SRC plantuml :file out/img/.dummy-plantuml
hide empty members

skinparam class {
 BackgroundColor HoneyDew
 BackgroundColor<< RDL >> SeaShell
 BackgroundColor<< Type >> LightCyan
}


#+END_SRC

* TODOs [3/7]                                                      :noexport:

 - ontology
   - [ ] make all comments more "readable".
   - [ ] make examples, also using code, `ex:myBlockA imf:hasPart
     ex:myBlockB` expresses that ...
   - [ ] documentation?: https://github.com/owlcs/miro/blob/master/miro.md

 - SHACL
   - [X] Write messages for all SHACL shapes
   - [X] add imports bewtween SHACL shape files?
     - add to terms
   - [ ] SHACL for attributes?
     - Min < Max
     - Operating ~ Specified?

 - Document
   - add imnages of r block and termianl to the ontologiy as oaf
     defipiction.
     - [X] to document
     - [X] and online for ontology
   - [ ] +explanation of OWL and SHACL definition.+
   - [X] add more intro text, both to main heading and sub headings
   - [ ] Fix inverse SHACL path
   - [ ] sort SHACL paths. user SPARQL? https://rdflib.readthedocs.io/en/stable/intro_to_sparql.html
   - [X] fix width of SHACL table
   - [X] link to sections and their figures in the start.
   - [X] Update generated diagrams from ontology
     - attribute qualifiers
   - [X] size of images
   - [X] remove draft


 web
 - [X] publish spreadsheet + Makefile, update links + downloads
 - [X] py-tools
 - [X] description on frontpage of ns.imgid.org

 - Types
   - [X] create a SHACL shape for types, e.g., hasValue xor class xor in xor datatype
   - [X] ontology of types
     - connect classes and shapes, generate link

 - OTTR
   - [ ] OTTR templates to instantiate datamodel
   - [ ] Simpler OTTR templates to create types?

 - "Code"
   - [ ] add RDFS reasoning to SHACL validation
   - [ ] add imports to python scrtips
   - [ ] https://github.com/aidhog/blabel

 - Other
   - [ ] https://dgarijo.github.io/Widoco/
   - [ ] Visualisation vocabulary
     - point (xyz), node, path
     - connectionpoints
   - [ ] Visualisation
     - [ ] Instance data
     - [ ] Type data
   - [ ] Generated diagrams of types/SHACL shapes, for validation?
     https://fsteeg.wordpress.com/2006/11/17/uml-class-diagrams-with-graphviz/
   - [ ] Align with Mimir:
     https://github.com/mimir-org/mimir/blob/main/src/service/ModelBuilder.Rdf/Properties/Resources.resx

 - RDF:
   - [ ] ?? Define JSON/JSON-LD format (using JSON-LD context object)
     - https://json-schema.org/
     - https://www.npmjs.com/package/shacl-jsonschema-converter
     - https://github.com/mulesoft-labs/json-ld-schema
     - https://github.com/philbarker/lr_schema/tree/book
   - [ ] ?? JSON framing?

 - Modelling questions:
   - [X] Are BreakdownPoints and ConnectionPoints also Elements? Perhaps
     not: If Elements may be broken down, ie. related by partOf, then we
     can breakdown a breakdown point, which does not seem correct.
   - [ ] Block and ConnectionPoints should be broken down to
     Graphs. Terminals might not be Elements (if elements are things
     that can be broken down to graphs). -> IMF v3
   - [ ] Can an Element be member of many Models?
   - What is the name of the relation between an Element and a Model.
   - [X] Can an attribute have many values? -> let's leave that open --
     and for the type to decide.
   - [ ] Represent ownership of models and elements?
   - [X] Compatibility: Should next version be backwards compatible --
     what does that mean?
   - [X] Check domain and range
     - Should hierarchial/assosicative relation have aspectelement as doman and range?
   - [X] Should connectedTo be symmetric? -> moved to editorialNote
   - [X] problem with direction-less connectedTo and the names theInput
     and theOutput.
   - [X] replace subproperty of inter/intra-aspectrelation to class
     axioms on AspectElement.
     - [X] also FunctionElement and so on, do this in Template
   - [ ] An InputTerminal cannot be connected to an InputTerminal
     (resp. OutputTerminal)
   - [X] Suggested list of metadata *for ontology*:
     - pav:version
   - [X] Create unstable ontology file, containing
     - [X] model
     - [X] breakdown points and connection points


 Challenges:
 - [ ] Optimise generation of prototypes from SHACL
 - [ ] Structuring, maintenence of types
 - [ ] Merging IMF models, identifying conflicts
 - [ ] Align IMF models with Records

* Backup                                                           :noexport:
** Design                                                          :noexport:
*** Diagram legend

The specification consists of a series of partially overlapping
diagrams. The combined diagram is presented in Figure ...

The diagrams are UML class diagrams are drawn using [[https://plantuml.com/][PlantUML]]
restricted to the following elements:

 - Classes, marked with the icon "C". Classes may have "fields" that
   can hold values, fields are not used to represent relationships.
 - Abstract classes, marked with an icon "A", are classes that are not
   intended to be instantiated.
 - Enumerations, marked with the icon "E", are used to represent UML
   classes with a limited list of instantiations and where the
   instantiations are defined in the IMF language.
 - Stereotypes, marked with an icon "S" are used to represent a class
   structure that is not intended to be explicitly represented in the
   language, but represents a tag and a convenient repetitive
   structure. Classes that use stereotypes indicate this with ~<<
   stereotype >>~ above the class name.
 - Subclass relationships between classes, which are drawn using
   directed relations with an open arrow.
 - Directed associations (relations) between classes, which are marked
   with a name and possibly a cardinality. If no cardinality is given,
   then the cardinality is 0--many.
 - Composition relations, drawn with a filled diamond as arrow,
   indicates a strong dependency to the target of the relationship;
   the target is considered as a part of the source and cannot exist
   independently of the source of the relationship.
 - Composition relations, drawn with a open diamond as arrow,
   indicates a weak dependency to the target of the relationship than
   to that of a composition relation, the target is considered as part
   of the source but can exist independently of the source of the
   relationship.

 Here is an example:

#+NAME: plantuml-diagram-legend
#+BEGIN_SRC plantuml :noweb yes :file out/img/plantuml-legend.png
<<plantuml-style>>

abstract class AbstractConcept1

class Concept2 {
 field1
 field2
}

AbstractConcept1 <|-- Concept2
Concept2 <|-- SubConcept3

Concept2 -left-> Concept4 : 1..* hasRelationA

enum EnumeratedConcept5 {
 element1
 element2
}

Concept2 -right-> EnumeratedConcept5 : 1 hasRelationB

Concept4 --o SubConcept3

Concept4 --> Item

class Item << RDL >>
#+END_SRC

#+RESULTS: plantuml-diagram-legend
[[file:out/img/plantuml-legend.png]]

Note: The structural specification is described by a series of
diagrams, each focus on a specific part. In the case that a class is
used in multiple diagrams, only one diagram contains the full
specification of the class, while the other diagrams only contain the
class name. The diagram that contains the complete specification
combines all diagrams and contains all information.


** Media                                                           :noexport:

  Media, taken from ~MaterialsBreakdownRev3.xlsx~.

  | 1           | 2          | 3            |
  |-------------+------------+--------------|
  | Material    |            |              |
  |             | Fluid      |              |
  |             |            | Process (HC) |
  |             |            | Water        |
  |             |            | Chemicals    |
  |             |            | Utilities    |
  |             | Solids     |              |
  |             |            | Granulate    |
  |             |            | Brick        |
  |-------------+------------+--------------|
  | Energy      |            |              |
  |             | Mechanical |              |
  |             |            | Rotating     |
  |             |            | Reciprocing  |
  |             | Electrical |              |
  |             |            | EHV          |
  |             |            | HV           |
  |             |            | LV           |
  |             |            | <50V         |
  |             | Thermal    |              |
  |             |            | Liquid       |
  |             |            | Steam        |
  |             |            | Burner       |
  |             |            | Air          |
  |             |            | Electric     |
  |-------------+------------+--------------|
  | Force       |            |              |
  |             | Mechanical |              |
  |             |            | Support      |
  |             |            | Connect      |
  |             |            | Restrain     |
  |-------------+------------+--------------|
  | Information |            |              |
  |             | Electrical |              |
  |             |            | Wired        |
  |             |            | Bus          |
  |             | Optical    |              |
  |             |            | Digital      |
  |             | Wireless   |              |
  |             |            | Digital      |






** plantuml
#+NAME: plantuml-types-old
#+BEGIN_SRC plantuml :noweb yes :file out/img/imf-plantuml-types-old.png
<<plantuml-style>>

stereotype Type << Identified >>

abstract class ElementType << Type >> {
  notation : 0..1
  symbol : 0..1
}

class BlockType << Type >> {
}

class TerminalType << Type >>

class AttributeGroupType << Identified >> << Type >>

class AttributeType << Type >> {
.. constraints ..
 'legal values
 legal value range
 datatype
 regex
}

'Type <|-- ElementType
'Type <|-- AttributeType
ElementType <|-- BlockType
ElementType <|-- TerminalType

Type "*" --> "*" RDLItem : classifier

ElementType "*" --> "0..1" Aspect : hasAspect

TerminalType "*" --> "1" Medium : hasMedium
TerminalType "*" --> "0..1" Direction : hasDirection

BlockType o--> "*" TerminalType : hasTerminalType
(BlockType, TerminalType) .. _Constraint

class _Constraint {
 min : 0..1
 max : 0..1
 name : 0..1
 description : 0..1
}

ElementType "*" --> "*" AttributeGroupType : hasAttributeGroupType
(ElementType, AttributeGroupType) .. _Constraint

ElementType *--> "*" AttributeType : hasAttributeType
(ElementType, AttributeType) .. _Constraint

AttributeGroupType *--> "1..*" AttributeType : hasAttributeType

BlockType "0..1" <-- "*" Block : instanceOf
TerminalType "0..1" <-- "*" Terminal : instanceOf
AttributeType "0..1" <-- "*" Attribute : instanceOf
AttributeGroupType "0..1" <-- "*" AttributeGroup : instanceOf

enum ValueEnumeration << RDL >>
AttributeType --> ValueEnumeration : 0 .. 1
#+END_SRC
** +Example+                                                       :noexport:

The example demonstrates:

 1. Defining a IMF type -- using a spreadsheet with OTTR processing instructions

 2. Translating (expanding) the spreadsheet to SHACL format -- using the OTTR framework

 3. Translating the IMF type in SHACL format to OWL -- using a python
    script

 4. Validation of the type

 5. Extracting a prototype IMF element instance from the IMF type in
    SHACL format -- using a python script

 6. IMF data/instance validation ...
    1. ... against the IMF terms
    2. ... against the IMF grammar
    3. ... against its IMF type

*** Example data

The example data is taken from an example from the IMF manual:

[[./example/pumpingFunctionType.png]]

*** Defining an IMF type

The example is represented in the following Excel spreadsheet
[[./example/pumpingFunctionType.xlsx]]

The spreadsheet uses the basic OTTR template defined for Type,
TypeReference and PropertyConstraint.

*** IMF type as SHACL

The spreadsheet can be translated (called expanded) to SHACL shape
expressions using the OTTR framework and the OTTR template
definitions.

#+BEGIN_SRC sh :exports none :results raw :wrap src ttl
java -jar bin/lutra.jar -l out/ottr -L stottr -f -p out/.std-prefixes.ttl -I tabottr example/pumpingFunctionType.xlsx | rapper - -i turtle -o turtle -I 'http://base.com#' > example/pumpingFunctionType.xlsx.ttl
cat example/pumpingFunctionType.xlsx.ttl
#+END_SRC

#+RESULTS:
#+BEGIN_src ttl
rapper: Parsing file <stdin> with parser turtle and base URI http://base.com#
rapper: Serializing with serializer turtle and base URI http://base.com#
rapper: Parsing returned 152 triples
@base <http://base.com#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix imf: <http://ns.imfid.org/imf#> .
@prefix o-owl-rstr: <http://tpl.ottr.xyz/owl/restriction/0.1/> .
@prefix o-rdfs: <http://tpl.ottr.xyz/rdfs/0.2/> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix o-imf-t-o: <http://ns.imfid.org/templates/type/owl/> .
@prefix o-imf-t-s: <http://ns.imfid.org/templates/type/shacl/> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix o-imf: <http://ns.imfid.org/templates/> .
@prefix ottr: <http://ns.ottr.xyz/0.4/> .
@prefix o-owl-ma: <http://tpl.ottr.xyz/owl/macro/0.1/> .
@prefix vann: <http://purl.org/vocab/vann/> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix shsh: <http://www.w3.org/ns/shacl-shacl#> .
@prefix o-rdf: <http://tpl.ottr.xyz/rdf/0.1/> .
@prefix pca-plm: <http://rds.posccaesar.org/ontology/plm/rdl/> .
@prefix pav: <http://purl.org/pav/> .
@prefix ex: <http://example.com#> .
@prefix o-owl-dec: <http://tpl.ottr.xyz/owl/declaration/0.1/> .
@prefix o-owl-ax: <http://tpl.ottr.xyz/owl/axiom/0.1/> .
@prefix vs: <http://www.w3.org/2003/06/sw-vocab-status/ns#> .
@prefix dc: <http://purl.org/dc/elements/1.1/> .

<http://example.com/example/ApplicationStandardShape>
    a imf:AttributeType, sh:NodeShape ;
    sh:targetClass <http://example.com/example/ApplicationStandard> .

<http://example.com/example/ClientRequirementDocumentShape>
    a imf:AttributeType, sh:NodeShape ;
    sh:property [
	sh:in ("A"
	    "B"
	    "C"
	) ;
	sh:path imf:value
    ] ;
    sh:targetClass <http://example.com/example/ClientRequirementDocument> .

<http://example.com/example/ElectricPowerShape>
    a imf:AttributeType, sh:NodeShape ;
    sh:targetClass <http://example.com/example/ElectricPower> .

<http://example.com/example/FluidShape>
    a imf:AttributeType, sh:NodeShape ;
    sh:targetClass <http://example.com/example/Fluid> .

<http://example.com/example/LiquidPumpingShape>
    a imf:BlockType, sh:NodeShape ;
    sh:name "Pumping, liquid velocity" ;
    sh:property [
	sh:minCount "2"^^xsd:nonNegativeInteger ;
	sh:name "T1" ;
	sh:node <http://example.com/example/WaterPumpingTerminalShape> ;
	sh:path imf:hasInputTerminal
    ], [
	sh:minCount "1"^^xsd:nonNegativeInteger ;
	sh:name "T2" ;
	sh:node <http://example.com/example/MechanicalRotationInputShape> ;
	sh:path imf:hasInputTerminal
    ], [
	sh:minCount "0"^^xsd:nonNegativeInteger ;
	sh:node <http://example.com/example/NoiseRequirementStandardShape> ;
	sh:path imf:hasAttribute
    ], [
	sh:hasValue <http://example.com/rdl/Pumping> ;
	sh:path imf:classifier
    ], [
	sh:hasValue imf:functionAspect ;
	sh:path imf:hasAspect
    ], [
	sh:hasValue "SP402" ;
	sh:path imf:symbol
    ], [
	sh:minCount "1"^^xsd:nonNegativeInteger ;
	sh:name "T3" ;
	sh:node <http://example.com/example/WaterPumpingTerminalShape> ;
	sh:path imf:hasOutputTerminal
    ], [
	sh:hasValue "KR" ;
	sh:path skos:notation
    ], [
	sh:minCount "1"^^xsd:nonNegativeInteger ;
	sh:node <http://example.com/example/FluidShape> ;
	sh:path imf:hasAttribute
    ], [
	sh:minCount "1"^^xsd:nonNegativeInteger ;
	sh:node <http://example.com/example/PressureDeltaShape> ;
	sh:path imf:hasAttribute
    ], [
	sh:minCount "1"^^xsd:nonNegativeInteger ;
	sh:node <http://example.com/example/SuctionPressureShape> ;
	sh:path imf:hasAttribute
    ], [
	sh:minCount "1"^^xsd:nonNegativeInteger ;
	sh:node <http://example.com/example/PressureShape> ;
	sh:path imf:hasAttribute
    ], [
	sh:minCount "1"^^xsd:nonNegativeInteger ;
	sh:node <http://example.com/example/PumpingPowerShape> ;
	sh:path imf:hasAttribute
    ], [
	sh:minCount "0"^^xsd:nonNegativeInteger ;
	sh:node <http://example.com/example/ApplicationStandardShape> ;
	sh:path imf:hasAttribute
    ], [
	sh:minCount "0"^^xsd:nonNegativeInteger ;
	sh:node <http://example.com/example/ClientRequirementDocumentShape> ;
	sh:path imf:hasAttribute
    ] ;
    sh:targetClass <http://example.com/example/LiquidPumping> .

<http://example.com/example/MechanicalRotationInputShape>
    a imf:TerminalType, sh:NodeShape ;
    sh:property [
	sh:minCount "1"^^xsd:nonNegativeInteger ;
	sh:node <http://example.com/example/ElectricPowerShape> ;
	sh:path imf:hasAttribute
    ], [
	sh:minCount "1"^^xsd:nonNegativeInteger ;
	sh:node <http://example.com/example/RotationalVelocityShape> ;
	sh:path imf:hasAttribute
    ], [
	sh:minCount "1"^^xsd:nonNegativeInteger ;
	sh:node <http://example.com/example/MediaDatasheetShape> ;
	sh:path imf:hasAttribute
    ] ;
    sh:targetClass <http://example.com/example/MechanicalRotationInput> .

<http://example.com/example/MediaDatasheetShape>
    a imf:AttributeType, sh:NodeShape ;
    sh:targetClass <http://example.com/example/MediaDatasheet> .

<http://example.com/example/NoiseRequirementStandardShape>
    a imf:AttributeType, sh:NodeShape ;
    sh:targetClass <http://example.com/example/NoiseRequirementStandard> .

<http://example.com/example/PressureDeltaShape>
    a imf:AttributeType, sh:NodeShape ;
    sh:targetClass <http://example.com/example/PressureDelta> .

<http://example.com/example/PressureShape>
    a imf:AttributeType, sh:NodeShape ;
    sh:targetClass <http://example.com/example/Pressure> .

<http://example.com/example/PumpingPowerShape>
    a imf:AttributeType, sh:NodeShape ;
    sh:targetClass <http://example.com/example/PumpingPower> .

<http://example.com/example/RotationalVelocityShape>
    a imf:AttributeType, sh:NodeShape ;
    sh:targetClass <http://example.com/example/RotationalVelocity> .

<http://example.com/example/SuctionPressureShape>
    a imf:AttributeType, sh:NodeShape ;
    sh:targetClass <http://example.com/example/SuctionPressure> .

<http://example.com/example/VolumetricFlowrateShape>
    a imf:AttributeType, sh:NodeShape ;
    sh:property [
	sh:datatype xsd:integer ;
	sh:maxInclusive 1000 ;
	sh:minInclusive 10 ;
	sh:path imf:value
    ], [
	sh:class <http://example.com/rdl/FlowrateUoM> ;
	sh:path imf:uom
    ] ;
    sh:targetClass <http://example.com/example/VolumetricFlowrate> .

<http://example.com/example/WaterPumpingTerminalShape>
    a imf:TerminalType, sh:NodeShape ;
    sh:property [
	sh:minCount "1"^^xsd:nonNegativeInteger ;
	sh:node <http://example.com/example/PressureShape> ;
	sh:path imf:hasAttribute
    ], [
	sh:minCount "1"^^xsd:nonNegativeInteger ;
	sh:node <http://example.com/example/VolumetricFlowrateShape> ;
	sh:path imf:hasAttribute
    ], [
	sh:minCount "1"^^xsd:nonNegativeInteger ;
	sh:node <http://example.com/example/MediaDatasheetShape> ;
	sh:path imf:hasAttribute
    ], [
	sh:hasValue <http://example.com/rdl/RDS4233125> ;
	sh:path imf:classifier
    ], [
	sh:hasValue <http://example.com/rdl/WaterMedia> ;
	sh:path imf:medium
    ] ;
    sh:targetClass <http://example.com/example/WaterPumpingTerminal> .

#+END_src


*** IMF type as OWL class

#+BEGIN_SRC sh :results raw :wrap src ttl
python3 out/py/imftype-shacl2owl.py -i example/pumpingFunctionType.xlsx.ttl -o example/pumpingFunctionType.owl.ttl
cat example/pumpingFunctionType.owl.ttl
#+END_SRC

#+RESULTS:
#+BEGIN_src ttl
Traceback (most recent call last):
  File "/home/martige/repo/imf-lab/imf-ontology/out/py/imftype-shacl2owl.py", line 233, in <module>
    main(sys.argv[1:])
  File "/home/martige/repo/imf-lab/imf-ontology/out/py/imftype-shacl2owl.py", line 220, in main
    iG.parse(inputfile, format="ttl")
  File "/home/martige/.local/lib/python3.10/site-packages/rdflib/graph.py", line 1306, in parse
    source = create_input_source(
  File "/home/martige/.local/lib/python3.10/site-packages/rdflib/parser.py", line 404, in create_input_source
    ) = _create_input_source_from_location(
  File "/home/martige/.local/lib/python3.10/site-packages/rdflib/parser.py", line 456, in _create_input_source_from_location
    file = open(filename, "rb")
FileNotFoundError: [Errno 2] No such file or directory: '/home/martige/repo/imf-lab/example/pumpingFunctionType.xlsx.ttl'
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix imf: <http://ns.imfid.org/imf#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

<http://example.com/example/ApplicationStandard>
    a owl:Class ;
    rdfs:subClassOf imf:Attribute .

<http://example.com/example/ClientRequirementDocument>
    a owl:Class ;
    rdfs:subClassOf imf:Attribute, [
	a owl:Restriction ;
	owl:maxQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
	owl:minQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
	owl:onDataRange rdfs:Literal, [
	    a rdfs:Datatype ;
	    owl:oneOf ("A"
		"B"
		"C"
	    )
	] ;
	owl:onProperty imf:value
    ] .

<http://example.com/example/ElectricPower>
    a owl:Class ;
    rdfs:subClassOf imf:Attribute .

<http://example.com/example/Fluid>
    a owl:Class ;
    rdfs:subClassOf imf:Attribute .

<http://example.com/example/LiquidPumping>
    a owl:Class ;
    rdfs:label "Pumping, liquid velocity" ;
    rdfs:subClassOf imf:Block, _:N10cfa743bc8b47b7a64e5960ec9f77e7, _:N234ee73cc2894bc99f0c9441df7b52af, _:N27a1d5320f3d4b05888376c04b82b6c5, _:N34197ff7616a4f62a63af393b2eba494, _:N549d97916bc54acca1fbaa4103073280, _:N6a043f18bf6d40b88d26e3b8fd497409, _:N823866cef37d4d3cb7f9089d70aff430, _:N9829036e494d4b1d8c6dcb7f27510ee7, _:Nbd0f42b22aec4c69b82685dc6fb64fee, _:Nc242bdaf6afc41339864b43775dba692, _:Ndbb0ab2f56434d77a62565b3a0c705f4, _:Neb55d8e17d8a4ee488acdd3a2cebcab9, [
	a owl:Restriction ;
	owl:minQualifiedCardinality "0"^^xsd:nonNegativeInteger ;
	owl:onClass <http://example.com/example/ApplicationStandard> ;
	owl:onProperty imf:hasAttribute
    ], [
	a owl:Restriction ;
	owl:minQualifiedCardinality "0"^^xsd:nonNegativeInteger ;
	owl:onClass <http://example.com/example/ClientRequirementDocument> ;
	owl:onProperty imf:hasAttribute
    ], [
	a owl:Restriction ;
	owl:minQualifiedCardinality "0"^^xsd:nonNegativeInteger ;
	owl:onClass <http://example.com/example/NoiseRequirementStandard> ;
	owl:onProperty imf:hasAttribute
    ] .

<http://example.com/example/MechanicalRotationInput>
    a owl:Class ;
    rdfs:subClassOf imf:Terminal, _:N4a35f1290d9f4ffb8de6a3813553ddc9, _:N68c029d2b3d8477a9993d6459d1bea53, _:Na4e1c18f85864dba98e55ddf31348741 .

<http://example.com/example/MediaDatasheet>
    a owl:Class ;
    rdfs:subClassOf imf:Attribute .

<http://example.com/example/NoiseRequirementStandard>
    a owl:Class ;
    rdfs:subClassOf imf:Attribute .

<http://example.com/example/Pressure>
    a owl:Class ;
    rdfs:subClassOf imf:Attribute .

<http://example.com/example/PressureDelta>
    a owl:Class ;
    rdfs:subClassOf imf:Attribute .

<http://example.com/example/PumpingPower>
    a owl:Class ;
    rdfs:subClassOf imf:Attribute .

<http://example.com/example/RotationalVelocity>
    a owl:Class ;
    rdfs:subClassOf imf:Attribute .

<http://example.com/example/SuctionPressure>
    a owl:Class ;
    rdfs:subClassOf imf:Attribute .

<http://example.com/example/VolumetricFlowrate>
    a owl:Class ;
    rdfs:subClassOf imf:Attribute, _:N365b26f1c1e640b0ab247bd07370db34, _:N75fbaeab07fa466dbce36ac39dc876e5 .

<http://example.com/example/WaterPumpingTerminal>
    a owl:Class ;
    rdfs:subClassOf imf:Terminal, _:N0c13fd5ccabc4a54b47263686d8b6680, _:N259edde6c6524b5897a7a103b828a547, _:N6982b54069d84d84b90ea37e3c228fdd, _:Na0037339b9d24efcb1563d81648e40c6, _:Nf172df2a67524093a2992af69b59bfa3 .

_:N0c13fd5ccabc4a54b47263686d8b6680
    a owl:Restriction ;
    owl:minQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
    owl:onClass <http://example.com/example/Pressure> ;
    owl:onProperty imf:hasAttribute .

_:N10cfa743bc8b47b7a64e5960ec9f77e7
    a owl:Restriction ;
    owl:minQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
    owl:onClass <http://example.com/example/Pressure> ;
    owl:onProperty imf:hasAttribute .

_:N234ee73cc2894bc99f0c9441df7b52af
    a owl:Restriction ;
    rdfs:label "T2" ;
    owl:minQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
    owl:onClass <http://example.com/example/MechanicalRotationInput> ;
    owl:onProperty imf:hasInputTerminal .

_:N259edde6c6524b5897a7a103b828a547
    a owl:Restriction ;
    owl:hasValue <http://example.com/rdl/RDS4233125> ;
    owl:minQualifiedCardinality 0 ;
    owl:onProperty imf:classifier .

_:N27a1d5320f3d4b05888376c04b82b6c5
    a owl:Restriction ;
    rdfs:label "T1" ;
    owl:minQualifiedCardinality "2"^^xsd:nonNegativeInteger ;
    owl:onClass <http://example.com/example/WaterPumpingTerminal> ;
    owl:onProperty imf:hasInputTerminal .

_:N34197ff7616a4f62a63af393b2eba494
    a owl:Restriction ;
    owl:minQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
    owl:onClass <http://example.com/example/PressureDelta> ;
    owl:onProperty imf:hasAttribute .

_:N365b26f1c1e640b0ab247bd07370db34
    a owl:Restriction ;
    owl:maxQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
    owl:minQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
    owl:onDataRange [
	a rdfs:Datatype ;
	owl:onDatatype xsd:integer ;
	owl:withRestrictions ([
		xsd:minInclusive 10
	    ]
	    [
		xsd:maxInclusive 1000
	    ]
	)
    ] ;
    owl:onProperty imf:value .

_:N4a35f1290d9f4ffb8de6a3813553ddc9
    a owl:Restriction ;
    owl:minQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
    owl:onClass <http://example.com/example/MediaDatasheet> ;
    owl:onProperty imf:hasAttribute .

_:N549d97916bc54acca1fbaa4103073280
    a owl:Restriction ;
    owl:hasValue <http://example.com/rdl/Pumping> ;
    owl:minQualifiedCardinality 0 ;
    owl:onProperty imf:classifier .

_:N68c029d2b3d8477a9993d6459d1bea53
    a owl:Restriction ;
    owl:minQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
    owl:onClass <http://example.com/example/ElectricPower> ;
    owl:onProperty imf:hasAttribute .

_:N6982b54069d84d84b90ea37e3c228fdd
    a owl:Restriction ;
    owl:minQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
    owl:onClass <http://example.com/example/MediaDatasheet> ;
    owl:onProperty imf:hasAttribute .

_:N6a043f18bf6d40b88d26e3b8fd497409
    a owl:Restriction ;
    owl:minQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
    owl:onClass <http://example.com/example/SuctionPressure> ;
    owl:onProperty imf:hasAttribute .

_:N75fbaeab07fa466dbce36ac39dc876e5
    a owl:Restriction ;
    owl:maxQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
    owl:minQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
    owl:onClass owl:Thing ;
    owl:onProperty imf:uom .

_:N823866cef37d4d3cb7f9089d70aff430
    a owl:Restriction ;
    rdfs:label "T3" ;
    owl:minQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
    owl:onClass <http://example.com/example/WaterPumpingTerminal> ;
    owl:onProperty imf:hasOutputTerminal .

_:N9829036e494d4b1d8c6dcb7f27510ee7
    a owl:Restriction ;
    owl:hasValue "KR" ;
    owl:minQualifiedCardinality 0 ;
    owl:onProperty <http://www.w3.org/2004/02/skos/core#notation> .

_:Na0037339b9d24efcb1563d81648e40c6
    a owl:Restriction ;
    owl:hasValue <http://example.com/rdl/WaterMedia> ;
    owl:minQualifiedCardinality 0 ;
    owl:onProperty imf:medium .

_:Na4e1c18f85864dba98e55ddf31348741
    a owl:Restriction ;
    owl:minQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
    owl:onClass <http://example.com/example/RotationalVelocity> ;
    owl:onProperty imf:hasAttribute .

_:Nbd0f42b22aec4c69b82685dc6fb64fee
    a owl:Restriction ;
    owl:hasValue "SP402" ;
    owl:minQualifiedCardinality 0 ;
    owl:onProperty imf:symbol .

_:Nc242bdaf6afc41339864b43775dba692
    a owl:Restriction ;
    owl:minQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
    owl:onClass <http://example.com/example/PumpingPower> ;
    owl:onProperty imf:hasAttribute .

_:Ndbb0ab2f56434d77a62565b3a0c705f4
    a owl:Restriction ;
    owl:hasValue imf:functionAspect ;
    owl:minQualifiedCardinality 0 ;
    owl:onProperty imf:hasAspect .

_:Neb55d8e17d8a4ee488acdd3a2cebcab9
    a owl:Restriction ;
    owl:minQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
    owl:onClass <http://example.com/example/Fluid> ;
    owl:onProperty imf:hasAttribute .

_:Nf172df2a67524093a2992af69b59bfa3
    a owl:Restriction ;
    owl:minQualifiedCardinality "1"^^xsd:nonNegativeInteger ;
    owl:onClass <http://example.com/example/VolumetricFlowrate> ;
    owl:onProperty imf:hasAttribute .

[]
    a owl:Class ;
    rdfs:subClassOf <http://example.com/example/MechanicalRotationInput> ;
    owl:intersectionOf (_:N68c029d2b3d8477a9993d6459d1bea53
	_:Na4e1c18f85864dba98e55ddf31348741
	_:N4a35f1290d9f4ffb8de6a3813553ddc9
	imf:Terminal
    ) .

[]
    a owl:Class ;
    rdfs:subClassOf <http://example.com/example/LiquidPumping> ;
    owl:intersectionOf (_:N27a1d5320f3d4b05888376c04b82b6c5
	_:N234ee73cc2894bc99f0c9441df7b52af
	_:N549d97916bc54acca1fbaa4103073280
	_:Ndbb0ab2f56434d77a62565b3a0c705f4
	_:Nbd0f42b22aec4c69b82685dc6fb64fee
	_:N823866cef37d4d3cb7f9089d70aff430
	_:N9829036e494d4b1d8c6dcb7f27510ee7
	_:Neb55d8e17d8a4ee488acdd3a2cebcab9
	_:N34197ff7616a4f62a63af393b2eba494
	_:N6a043f18bf6d40b88d26e3b8fd497409
	_:N10cfa743bc8b47b7a64e5960ec9f77e7
	_:Nc242bdaf6afc41339864b43775dba692
	imf:Block
    ) .

[]
    a owl:Ontology ;
    owl:imports <https://imf-lab.gitlab.io/imf-ontology/out/owl/imf-ontology.owl.ttl> .

[]
    a owl:Class ;
    rdfs:subClassOf <http://example.com/example/WaterPumpingTerminal> ;
    owl:intersectionOf (_:N0c13fd5ccabc4a54b47263686d8b6680
	_:Nf172df2a67524093a2992af69b59bfa3
	_:N6982b54069d84d84b90ea37e3c228fdd
	_:N259edde6c6524b5897a7a103b828a547
	_:Na0037339b9d24efcb1563d81648e40c6
	imf:Terminal
    ) .

[]
    a owl:Class ;
    rdfs:subClassOf <http://example.com/example/VolumetricFlowrate> ;
    owl:intersectionOf (_:N365b26f1c1e640b0ab247bd07370db34
	_:N75fbaeab07fa466dbce36ac39dc876e5
	imf:Attribute
    ) .

#+END_src
*** Validation of IMF type against ...
**** IMF terms grammar

#+CALL: sh_jena_shacl_validate(data="example/pumpingFunctionType.xlsx.ttl", shapes="out/shacl/imf-terms-grammar.shacl.ttl")

#+RESULTS:
#+BEGIN_src ttl
Result of validating RDF data <example/pumpingFunctionType.xlsx.ttl> against SHACL shape <out/shacl/imf-terms-grammar.shacl.ttl>:
2023-08-08
Loading data file
org.apache.jena.riot.RiotNotFoundException: Not found: example/pumpingFunctionType.xlsx.ttl
	at org.apache.jena.riot.RDFParser.openTypedInputStream(RDFParser.java:409)
	at org.apache.jena.riot.RDFParser.parseURI(RDFParser.java:316)
	at org.apache.jena.riot.RDFParser.parse(RDFParser.java:310)
	at org.apache.jena.riot.RDFParserBuilder.parse(RDFParserBuilder.java:552)
	at org.apache.jena.riot.RDFDataMgr.parseFromURI(RDFDataMgr.java:737)
	at org.apache.jena.riot.RDFDataMgr.read(RDFDataMgr.java:193)
	at org.apache.jena.riot.RDFDataMgr.read(RDFDataMgr.java:135)
	at org.apache.jena.riot.RDFDataMgr.loadGraph(RDFDataMgr.java:352)
	at shacl.shacl_validate.load(shacl_validate.java:134)
	at shacl.shacl_validate.exec(shacl_validate.java:111)
	at org.apache.jena.cmd.CmdMain.mainMethod(CmdMain.java:92)
	at org.apache.jena.cmd.CmdMain.mainRun(CmdMain.java:58)
	at org.apache.jena.cmd.CmdMain.mainRun(CmdMain.java:45)
	at shacl.shacl_validate.main(shacl_validate.java:60)
	at shacl.shacl.main(shacl.java:81)
#+END_src

**** IMF types grammar

#+CALL: sh_jena_shacl_validate(data="example/pumpingFunctionType.xlsx.ttl", shapes="out/shacl/imf-types-grammar.shacl.ttl")

#+RESULTS:
#+BEGIN_src ttl
Result of validating RDF data <example/pumpingFunctionType.xlsx.ttl> against SHACL shape <out/shacl/imf-types-grammar.shacl.ttl>:
2023-06-28
Node=<http://example.com/example/VolumetricFlowrateShape>
  Path=<http://www.w3.org/ns/shacl#property>
  Value: _:Ba1da9abe6a813586fea81167e0741152
  Message: A property constraint may only specify one or more of the following: sh:minExclusive, sh:maxExclusive, sh:minInclusive, sh:maxInclusive, sh:pattern, if also sh:datatype is specified.
Node=<http://example.com/example/VolumetricFlowrateShape>
  Path=<http://www.w3.org/ns/shacl#property>
  Value: _:Ba1da9abe6a813586fea81167e0741152
  Message: A property constaint must specify exactly one of the following: sh:hasValue, sh:in, sh:node, sh:class, sh:datatype.
Node=<http://example.com/example/LiquidPumpingShape>
  Path=<http://www.w3.org/ns/shacl#property>
  Value: _:Bc75b1c29e63ef35b95480cb584c142d5
  Message: A property constraint may only specify one or more of the following: sh:minExclusive, sh:maxExclusive, sh:minInclusive, sh:maxInclusive, sh:pattern, if also sh:datatype is specified.
Node=<http://example.com/example/SuctionPressureShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/SuctionPressureShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/ClientRequirementDocumentShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/ApplicationStandardShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/ApplicationStandardShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/PressureDeltaShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/PressureDeltaShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/PressureShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/PressureShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/FluidShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/FluidShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/NoiseRequirementStandardShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/NoiseRequirementStandardShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/RotationalVelocityShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/RotationalVelocityShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/MediaDatasheetShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/MediaDatasheetShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/VolumetricFlowrateShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/VolumetricFlowrateShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/ElectricPowerShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/ElectricPowerShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/PumpingPowerShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
Node=<http://example.com/example/PumpingPowerShape>
  Path=<http://www.w3.org/ns/shacl#property>/<http://www.w3.org/ns/shacl#path>
  Message: AttributeType does not specify a predicate
#+END_src



**** IMF ontology

Check that the IMF type is consistent using an OWL reasoner.

#+BEGIN_SRC sh :results output
java -jar bin/HermiT.jar -l -k -U example/pumpingFunctionType.owl.ttl
#+END_SRC

#+RESULTS:
: http://www.w3.org/2002/07/owl#Thing is satisfiable.
: Classes equivalent to 'owl:Nothing':
:	owl:Nothing

*** IMF type prototype instance

#+BEGIN_SRC sh :results raw :wrap src ttl
python3 out/py/imftype-shacl2rdf.py -i example/pumpingFunctionType.xlsx.ttl -o example/pumpingFunctionPrototype.ttl
cat example/pumpingFunctionPrototype.ttl
#+END_SRC

#+RESULTS:
#+BEGIN_src ttl
@prefix imf: <http://ns.imfid.org/imf#> .
@prefix ns1: <http://www.w3.org/2004/02/skos/core#> .
@prefix x: <http://example.org/prototype#> .

x:id-1 a <http://example.com/example/ApplicationStandard>,
	imf:Attribute .

x:id-2 a <http://example.com/example/ClientRequirementDocument>,
	imf:Attribute ;
    imf:value x:id-3 .

x:id-38 a <http://example.com/example/MechanicalRotationInput>,
	imf:Terminal ;
    imf:hasAttribute x:id-39,
	x:id-40,
	x:id-41 .

x:id-4 a <http://example.com/example/ElectricPower>,
	imf:Attribute .

x:id-42 a <http://example.com/example/MediaDatasheet>,
	imf:Attribute .

x:id-43 a <http://example.com/example/NoiseRequirementStandard>,
	imf:Attribute .

x:id-44 a <http://example.com/example/PressureDelta>,
	imf:Attribute .

x:id-45 a <http://example.com/example/Pressure>,
	imf:Attribute .

x:id-46 a <http://example.com/example/PumpingPower>,
	imf:Attribute .

x:id-47 a <http://example.com/example/RotationalVelocity>,
	imf:Attribute .

x:id-48 a <http://example.com/example/SuctionPressure>,
	imf:Attribute .

x:id-49 a <http://example.com/example/VolumetricFlowrate>,
	imf:Attribute ;
    imf:uom x:id-51 ;
    imf:value x:id-50 .

x:id-5 a <http://example.com/example/Fluid>,
	imf:Attribute .

x:id-52 a <http://example.com/example/WaterPumpingTerminal>,
	imf:Terminal ;
    imf:classifier <http://example.com/rdl/RDS4233125> ;
    imf:hasAttribute x:id-53,
	x:id-54,
	x:id-57 ;
    imf:medium <http://example.com/rdl/WaterMedia> .

x:id-6 a <http://example.com/example/LiquidPumping>,
	imf:Block ;
    imf:classifier <http://example.com/rdl/Pumping> ;
    imf:hasAspect imf:functionAspect ;
    imf:hasAttribute x:id-23,
	x:id-30,
	x:id-31,
	x:id-32,
	x:id-33,
	x:id-34,
	x:id-35,
	x:id-36 ;
    imf:hasInputTerminal x:id-13,
	x:id-19,
	x:id-7 ;
    imf:hasOutputTerminal x:id-24 ;
    imf:symbol "SP402" ;
    ns1:editorialNote """SHACL Node shape description:
  - name: Pumping, liquid velocity
""" ;
    ns1:notation "KR" .

x:id-12 a <http://example.com/example/MediaDatasheet>,
	imf:Attribute .

x:id-13 a <http://example.com/example/WaterPumpingTerminal>,
	imf:Terminal ;
    imf:classifier <http://example.com/rdl/RDS4233125> ;
    imf:hasAttribute x:id-14,
	x:id-15,
	x:id-18 ;
    imf:medium <http://example.com/rdl/WaterMedia> .

x:id-14 a <http://example.com/example/Pressure>,
	imf:Attribute .

x:id-15 a <http://example.com/example/VolumetricFlowrate>,
	imf:Attribute ;
    imf:uom x:id-17 ;
    imf:value x:id-16 .

x:id-18 a <http://example.com/example/MediaDatasheet>,
	imf:Attribute .

x:id-19 a <http://example.com/example/MechanicalRotationInput>,
	imf:Terminal ;
    imf:hasAttribute x:id-20,
	x:id-21,
	x:id-22 .

x:id-20 a <http://example.com/example/ElectricPower>,
	imf:Attribute .

x:id-21 a <http://example.com/example/RotationalVelocity>,
	imf:Attribute .

x:id-22 a <http://example.com/example/MediaDatasheet>,
	imf:Attribute .

x:id-23 a <http://example.com/example/NoiseRequirementStandard>,
	imf:Attribute .

x:id-24 a <http://example.com/example/WaterPumpingTerminal>,
	imf:Terminal ;
    imf:classifier <http://example.com/rdl/RDS4233125> ;
    imf:hasAttribute x:id-25,
	x:id-26,
	x:id-29 ;
    imf:medium <http://example.com/rdl/WaterMedia> .

x:id-25 a <http://example.com/example/Pressure>,
	imf:Attribute .

x:id-26 a <http://example.com/example/VolumetricFlowrate>,
	imf:Attribute ;
    imf:uom x:id-28 ;
    imf:value x:id-27 .

x:id-29 a <http://example.com/example/MediaDatasheet>,
	imf:Attribute .

x:id-30 a <http://example.com/example/Fluid>,
	imf:Attribute .

x:id-31 a <http://example.com/example/PressureDelta>,
	imf:Attribute .

x:id-32 a <http://example.com/example/SuctionPressure>,
	imf:Attribute .

x:id-33 a <http://example.com/example/Pressure>,
	imf:Attribute .

x:id-34 a <http://example.com/example/PumpingPower>,
	imf:Attribute .

x:id-35 a <http://example.com/example/ApplicationStandard>,
	imf:Attribute .

x:id-36 a <http://example.com/example/ClientRequirementDocument>,
	imf:Attribute ;
    imf:value x:id-37 .

x:id-39 a <http://example.com/example/ElectricPower>,
	imf:Attribute .

x:id-40 a <http://example.com/example/RotationalVelocity>,
	imf:Attribute .

x:id-41 a <http://example.com/example/MediaDatasheet>,
	imf:Attribute .

x:id-53 a <http://example.com/example/Pressure>,
	imf:Attribute .

x:id-54 a <http://example.com/example/VolumetricFlowrate>,
	imf:Attribute ;
    imf:uom x:id-56 ;
    imf:value x:id-55 .

x:id-57 a <http://example.com/example/MediaDatasheet>,
	imf:Attribute .

x:id-7 a <http://example.com/example/WaterPumpingTerminal>,
	imf:Terminal ;
    imf:classifier <http://example.com/rdl/RDS4233125> ;
    imf:hasAttribute x:id-12,
	x:id-8,
	x:id-9 ;
    imf:medium <http://example.com/rdl/WaterMedia> .

x:id-8 a <http://example.com/example/Pressure>,
	imf:Attribute .

x:id-9 a <http://example.com/example/VolumetricFlowrate>,
	imf:Attribute ;
    imf:uom x:id-11 ;
    imf:value x:id-10 .

#+END_src

*** Validation of IMF data against ...
**** ... the IMF terms grammar

#+CALL: sh_jena_shacl_validate(data="example/pumpingFunctionPrototype.ttl", shapes="out/shacl/imf-terms-grammar.shacl.ttl")

#+RESULTS:
#+BEGIN_src ttl
Result of validating RDF data <example/pumpingFunctionPrototype.ttl> against SHACL shape <out/shacl/imf-terms-grammar.shacl.ttl>:
2023-06-27
Conforms
#+END_src

**** ... the IMF model grammar

#+CALL: sh_jena_shacl_validate(data="example/pumpingFunctionPrototype.ttl", shapes="out/shacl/imf-model-grammar.shacl.ttl")

#+RESULTS:
#+BEGIN_src ttl
Result of validating RDF data <example/pumpingFunctionPrototype.ttl> against SHACL shape <out/shacl/imf-model-grammar.shacl.ttl>:
2023-06-28
Node=<http://example.org/prototype#id-52>
  Path=<http://ns.imfid.org/imf#connectedTo>
  Message: The Terminal has no connection (to a different Terminal).
Node=<http://example.org/prototype#id-7>
  Path=<http://ns.imfid.org/imf#connectedTo>
  Message: The Terminal has no connection (to a different Terminal).
Node=<http://example.org/prototype#id-24>
  Path=<http://ns.imfid.org/imf#connectedTo>
  Message: The Terminal has no connection (to a different Terminal).
Node=<http://example.org/prototype#id-13>
  Path=<http://ns.imfid.org/imf#connectedTo>
  Message: The Terminal has no connection (to a different Terminal).
Node=<http://example.org/prototype#id-38>
  Path=<http://ns.imfid.org/imf#medium>
  Message: The Terminal has no medium.
Node=<http://example.org/prototype#id-38>
  Path=<http://ns.imfid.org/imf#connectedTo>
  Message: The Terminal has no connection (to a different Terminal).
Node=<http://example.org/prototype#id-19>
  Path=<http://ns.imfid.org/imf#medium>
  Message: The Terminal has no medium.
Node=<http://example.org/prototype#id-19>
  Path=<http://ns.imfid.org/imf#connectedTo>
  Message: The Terminal has no connection (to a different Terminal).
Node=<http://example.org/prototype#id-6>
  Path=^<http://ns.imfid.org/imf#hasElement>
  Message: Element is not contained in a Model.
Node=<http://example.org/prototype#id-52>
  Path=^<http://ns.imfid.org/imf#hasElement>
  Message: Element is not contained in a Model.
Node=<http://example.org/prototype#id-7>
  Path=^<http://ns.imfid.org/imf#hasElement>
  Message: Element is not contained in a Model.
Node=<http://example.org/prototype#id-24>
  Path=^<http://ns.imfid.org/imf#hasElement>
  Message: Element is not contained in a Model.
Node=<http://example.org/prototype#id-13>
  Path=^<http://ns.imfid.org/imf#hasElement>
  Message: Element is not contained in a Model.
Node=<http://example.org/prototype#id-38>
  Path=^<http://ns.imfid.org/imf#hasElement>
  Message: Element is not contained in a Model.
Node=<http://example.org/prototype#id-38>
  Path=<http://ns.imfid.org/imf#classifier>
  Message: Element has no classifier.
Node=<http://example.org/prototype#id-19>
  Path=^<http://ns.imfid.org/imf#hasElement>
  Message: Element is not contained in a Model.
Node=<http://example.org/prototype#id-19>
  Path=<http://ns.imfid.org/imf#classifier>
  Message: Element has no classifier.
Node=<http://example.org/prototype#id-6>
  Path=<http://ns.imfid.org/imf#hasAspect>
  Value: <http://ns.imfid.org/imf#functionAspect>
  Message: ClassConstraint[<http://ns.imfid.org/imf#Aspect>]: Expected class :<http://ns.imfid.org/imf#Aspect> for <http://ns.imfid.org/imf#functionAspect>
Node=<http://example.org/prototype#id-1>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-1>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-1>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-5>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-5>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-5>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-57>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-57>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-57>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-35>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-35>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-35>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-23>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-23>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-23>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-9>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-9>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-45>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-45>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-45>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-15>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-15>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-47>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-47>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-47>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-25>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-25>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-25>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-39>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-39>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-39>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-49>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-49>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-29>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-29>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-29>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-31>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-31>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-31>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-53>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-53>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-53>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-41>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-41>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-41>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-33>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-33>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-33>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-21>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-21>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-21>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-43>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-43>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-43>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-2>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-2>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-4>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-4>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-4>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-8>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-8>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-8>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-46>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-46>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-46>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-12>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-12>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-12>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-34>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-34>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-34>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-26>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-26>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-48>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-48>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-48>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-14>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-14>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-14>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-36>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-36>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-18>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-18>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-18>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-40>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-40>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-40>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-42>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-42>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-42>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-20>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-20>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-20>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-30>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-30>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-30>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-22>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-22>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-22>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-44>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-44>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-44>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-32>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-32>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://example.org/prototype#id-32>
  Path=<http://ns.imfid.org/imf#value>
  Message: Attribute has no value.
Node=<http://example.org/prototype#id-54>
  Path=<http://ns.imfid.org/imf#hasAttributeQualifier>
  Message: Attribute has no qualifier.
Node=<http://example.org/prototype#id-54>
  Path=<http://ns.imfid.org/imf#predicate>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
#+END_src

**** ... its IMF type

#+CALL: sh_jena_shacl_validate(data="example/pumpingFunctionPrototype.ttl", shapes="example/pumpingFunctionType.xlsx.ttl")

#+RESULTS:
#+BEGIN_src ttl
Result of validating RDF data <example/pumpingFunctionPrototype.ttl> against SHACL shape <example/pumpingFunctionType.xlsx.ttl>:
2023-06-27
Node=<http://example.org/prototype#id-52>
  Path=<http://ns.imfid.org/imf#hasAttribute>
  Value: <http://example.org/prototype#id-54>
  Message: Node[<http://example.com/example/VolumetricFlowrateShape>] at focusNode <http://example.org/prototype#id-54>
Node=<http://example.org/prototype#id-7>
  Path=<http://ns.imfid.org/imf#hasAttribute>
  Value: <http://example.org/prototype#id-9>
  Message: Node[<http://example.com/example/VolumetricFlowrateShape>] at focusNode <http://example.org/prototype#id-9>
Node=<http://example.org/prototype#id-24>
  Path=<http://ns.imfid.org/imf#hasAttribute>
  Value: <http://example.org/prototype#id-26>
  Message: Node[<http://example.com/example/VolumetricFlowrateShape>] at focusNode <http://example.org/prototype#id-26>
Node=<http://example.org/prototype#id-13>
  Path=<http://ns.imfid.org/imf#hasAttribute>
  Value: <http://example.org/prototype#id-15>
  Message: Node[<http://example.com/example/VolumetricFlowrateShape>] at focusNode <http://example.org/prototype#id-15>
Node=<http://example.org/prototype#id-2>
  Path=<http://ns.imfid.org/imf#value>
  Value: <http://example.org/prototype#id-3>
  Message: InConstraint["A", "B", "C"] : RDF term <http://example.org/prototype#id-3> not in expected values
Node=<http://example.org/prototype#id-36>
  Path=<http://ns.imfid.org/imf#value>
  Value: <http://example.org/prototype#id-37>
  Message: InConstraint["A", "B", "C"] : RDF term <http://example.org/prototype#id-37> not in expected values
Node=<http://example.org/prototype#id-54>
  Path=<http://ns.imfid.org/imf#uom>
  Value: <http://example.org/prototype#id-56>
  Message: ClassConstraint[<http://example.com/rdl/FlowrateUoM>]: Expected class :<http://example.com/rdl/FlowrateUoM> for <http://example.org/prototype#id-56>
Node=<http://example.org/prototype#id-54>
  Path=<http://ns.imfid.org/imf#value>
  Value: <http://example.org/prototype#id-55>
  Message: minInclusive[10] can't compare to http://example.org/prototype#id-55
Node=<http://example.org/prototype#id-54>
  Path=<http://ns.imfid.org/imf#value>
  Value: <http://example.org/prototype#id-55>
  Message: maxInclusive[1000] can't compare to http://example.org/prototype#id-55
Node=<http://example.org/prototype#id-54>
  Path=<http://ns.imfid.org/imf#value>
  Value: <http://example.org/prototype#id-55>
  Message: DatatypeConstraint[xsd:integer] : Not a literal
Node=<http://example.org/prototype#id-9>
  Path=<http://ns.imfid.org/imf#uom>
  Value: <http://example.org/prototype#id-11>
  Message: ClassConstraint[<http://example.com/rdl/FlowrateUoM>]: Expected class :<http://example.com/rdl/FlowrateUoM> for <http://example.org/prototype#id-11>
Node=<http://example.org/prototype#id-9>
  Path=<http://ns.imfid.org/imf#value>
  Value: <http://example.org/prototype#id-10>
  Message: minInclusive[10] can't compare to http://example.org/prototype#id-10
Node=<http://example.org/prototype#id-9>
  Path=<http://ns.imfid.org/imf#value>
  Value: <http://example.org/prototype#id-10>
  Message: maxInclusive[1000] can't compare to http://example.org/prototype#id-10
Node=<http://example.org/prototype#id-9>
  Path=<http://ns.imfid.org/imf#value>
  Value: <http://example.org/prototype#id-10>
  Message: DatatypeConstraint[xsd:integer] : Not a literal
Node=<http://example.org/prototype#id-26>
  Path=<http://ns.imfid.org/imf#uom>
  Value: <http://example.org/prototype#id-28>
  Message: ClassConstraint[<http://example.com/rdl/FlowrateUoM>]: Expected class :<http://example.com/rdl/FlowrateUoM> for <http://example.org/prototype#id-28>
Node=<http://example.org/prototype#id-26>
  Path=<http://ns.imfid.org/imf#value>
  Value: <http://example.org/prototype#id-27>
  Message: minInclusive[10] can't compare to http://example.org/prototype#id-27
Node=<http://example.org/prototype#id-26>
  Path=<http://ns.imfid.org/imf#value>
  Value: <http://example.org/prototype#id-27>
  Message: maxInclusive[1000] can't compare to http://example.org/prototype#id-27
Node=<http://example.org/prototype#id-26>
  Path=<http://ns.imfid.org/imf#value>
  Value: <http://example.org/prototype#id-27>
  Message: DatatypeConstraint[xsd:integer] : Not a literal
Node=<http://example.org/prototype#id-15>
  Path=<http://ns.imfid.org/imf#uom>
  Value: <http://example.org/prototype#id-17>
  Message: ClassConstraint[<http://example.com/rdl/FlowrateUoM>]: Expected class :<http://example.com/rdl/FlowrateUoM> for <http://example.org/prototype#id-17>
Node=<http://example.org/prototype#id-15>
  Path=<http://ns.imfid.org/imf#value>
  Value: <http://example.org/prototype#id-16>
  Message: minInclusive[10] can't compare to http://example.org/prototype#id-16
Node=<http://example.org/prototype#id-15>
  Path=<http://ns.imfid.org/imf#value>
  Value: <http://example.org/prototype#id-16>
  Message: maxInclusive[1000] can't compare to http://example.org/prototype#id-16
Node=<http://example.org/prototype#id-15>
  Path=<http://ns.imfid.org/imf#value>
  Value: <http://example.org/prototype#id-16>
  Message: DatatypeConstraint[xsd:integer] : Not a literal
Node=<http://example.org/prototype#id-49>
  Path=<http://ns.imfid.org/imf#uom>
  Value: <http://example.org/prototype#id-51>
  Message: ClassConstraint[<http://example.com/rdl/FlowrateUoM>]: Expected class :<http://example.com/rdl/FlowrateUoM> for <http://example.org/prototype#id-51>
Node=<http://example.org/prototype#id-49>
  Path=<http://ns.imfid.org/imf#value>
  Value: <http://example.org/prototype#id-50>
  Message: minInclusive[10] can't compare to http://example.org/prototype#id-50
Node=<http://example.org/prototype#id-49>
  Path=<http://ns.imfid.org/imf#value>
  Value: <http://example.org/prototype#id-50>
  Message: maxInclusive[1000] can't compare to http://example.org/prototype#id-50
Node=<http://example.org/prototype#id-49>
  Path=<http://ns.imfid.org/imf#value>
  Value: <http://example.org/prototype#id-50>
  Message: DatatypeConstraint[xsd:integer] : Not a literal
Node=<http://example.org/prototype#id-6>
  Path=<http://ns.imfid.org/imf#hasInputTerminal>
  Value: <http://example.org/prototype#id-7>
  Message: Node[<http://example.com/example/WaterPumpingTerminalShape>] at focusNode <http://example.org/prototype#id-7>
Node=<http://example.org/prototype#id-6>
  Path=<http://ns.imfid.org/imf#hasInputTerminal>
  Value: <http://example.org/prototype#id-13>
  Message: Node[<http://example.com/example/WaterPumpingTerminalShape>] at focusNode <http://example.org/prototype#id-13>
Node=<http://example.org/prototype#id-6>
  Path=<http://ns.imfid.org/imf#hasInputTerminal>
  Value: <http://example.org/prototype#id-19>
  Message: Node[<http://example.com/example/WaterPumpingTerminalShape>] at focusNode <http://example.org/prototype#id-19>
Node=<http://example.org/prototype#id-6>
  Path=<http://ns.imfid.org/imf#hasAttribute>
  Value: <http://example.org/prototype#id-36>
  Message: Node[<http://example.com/example/ClientRequirementDocumentShape>] at focusNode <http://example.org/prototype#id-36>
Node=<http://example.org/prototype#id-6>
  Path=<http://ns.imfid.org/imf#hasOutputTerminal>
  Value: <http://example.org/prototype#id-24>
  Message: Node[<http://example.com/example/WaterPumpingTerminalShape>] at focusNode <http://example.org/prototype#id-24>
#+END_src

**** ... the IMF ontology

Check that the IMF instance data is not inconsistent using an OWL reasoner.

#+BEGIN_SRC sh :results output
java -jar bin/HermiT.jar -l -k -U example/pumpingFunctionPrototype.ttl
#+END_SRC

#+RESULTS:
: http://www.w3.org/2002/07/owl#Thing is satisfiable.
: Classes equivalent to 'owl:Nothing':
:	owl:Nothing
** OTTR templates
*** +Suggested use of the type patterns+                           :noexport:

The diagram below displays a suggested use of the type patterns.

#+BEGIN_SRC plantuml :noweb yes :file out/img/imf-plantuml-type-patterns.png
<<plantuml-style>>

metaclass ElementType << Type >> {
  [metadata]
  aspect: SimpleValue
  notation: SimpleValue
  symbol: SimpleValue/s
}

metaclass BlockType << Type >>  {

}

metaclass TerminalType << Type >>  {
  direction: SimpleValue
  medium: SimpleValue/s
}

metaclass AttributeType << Type >>  {
  property : SimpleValue/s
  value : ComplexValues
  uom : SimpleValue/s
  qualifier : SimpleValues
}

ElementType <|-- BlockType
ElementType <|-- TerminalType

ElementType --> AttributeType : TypeReference
BlockType --> TerminalType : TypeReference
AttributeGroupType --> AttributeType : TypeReference

circle element

element -left-> ElementType : type

#+END_SRC

#+RESULTS:
[[file:out/img/imf-plantuml-type-patterns.png]]

*** +OWL OTTR Templates Translation+                               :noexport:
**** Types -> OWL Classes

#+NAME: sparql_shaclClass
#+BEGIN_SRC ttl
SELECT
  ?class
  ?imfClass
  ?name
  ?description
  ?severity
  ?message
WHERE {
  OPTIONAL { ?n sh:targetClass ?class }
  OPTIONAL { ?n a ?imfTypeClass .
	     FILTER(STRSTARTS(STR(?imfTypeClass), "http://ns.imfid.org"))
	     BIND(IRI(REPLACE(STR(?imfTypeClass), "Type", "")) AS ?imfClass)}
  OPTIONAL { ?n sh:name ?name }
  OPTIONAL { ?n sh:description ?description }
  OPTIONAL { ?n sh:severity ?severity }
  OPTIONAL { ?n sh:message ?message }
}
#+END_SRC

#+BEGIN_SRC ttl :noweb strip-export :XXXtangle out/ottr/imf-type-owl1.stottr :mkdirp yes
<<prefixes>>

o-imf-t-o:TypeClass[
  owl:Class ?id,
  ? owl:Class ?imfClass,
  !? xsd:string ?name,
  !? xsd:string ?description,
  ? xsd:string ?severity,
  ? xsd:string ?message
] :: {
  o-owl-dec:Class(?id, ?name, ?description, none, none),
  o-owl-ax:SubClassOf(?id, ?imfClass)
} .
#+END_SRC

**** Property Constraints -> OWL Class Restrictions

#+NAME: sparql_shaclObjectPropertyConstraint
#+BEGIN_SRC ttl
SELECT
  ?class
  ?path
  ?name
  ?description
  ?minCount
  ?maxCount
  ?nodeTargetClass
  ?hasValue
  ?in
  #?datatype
  #?minExclusive
  #?minInclusive
  #?maxExclusive
  #?maxInclusive
  #?minLength
  #?maxLength
  #?pattern
  #?flags
WHERE {
  ?n sh:targetClass ?class .
  ?n sh:property ?p .
  ?p sh:path ?path .
  OPTIONAL { ?p sh:name ?name }
  OPTIONAL { ?p sh:description ?description }
  OPTIONAL { ?p sh:minCount ?minCount }
  OPTIONAL { ?p sh:maxCount ?maxCount }
  OPTIONAL { ?p sh:node [ sh:targetClass ?nodeTargetClass ] }
  OPTIONAL { ?p sh:class ?class }
  OPTIONAL { ?p sh:hasValue ?hasValue
    FILTER (!isLiteral(?hasValue))
  }
  OPTIONAL { ?p sh:in ?in }
  #OPTIONAL { ?p sh:datatype ?datatype }
  #OPTIONAL { ?p sh:minExclusive ?minExclusive }
  #OPTIONAL { ?p sh:minInclusive ?minInclusive }
  #OPTIONAL { ?p sh:maxExclusive ?maxExclusive }
  #OPTIONAL { ?p sh:maxInclusive ?maxInclusive }
  #OPTIONAL { ?p sh:minLength ?minLength }
  #OPTIONAL { ?p sh:maxLength ?maxLength }
  #OPTIONAL { ?p sh:pattern ?pattern }
  #OPTIONAL { ?p sh:flags ?flags }
  FILTER ( ?path IN (
imf:classifier,
imf:hasAspect,
imf:hasAttribute,
imf:hasAttributeQualifier,
imf:hasInputTerminal,
imf:hasOutputTerminal,
imf:hasTerminal,
imf:hasTerminalQualifier,
imf:medium,
imf:predicate,
#imf:symbol,
imf:uom
#imf:value,
#skos:notation,
) )
}
#+END_SRC

#+NAME: sparql_shaclDatatypePropertyConstraint
#+BEGIN_SRC ttl
SELECT
  ?class
  ?path
  ?name
  ?description
  ?minCount
  ?maxCount
  #?nodeTargetClass
  ?hasValue
  ?in
  ?datatype
  #?minExclusive
  #?minInclusive
  #?maxExclusive
  #?maxInclusive
  #?minLength
  #?maxLength
  #?pattern
  #?flags
WHERE {
  ?n sh:targetClass ?class .
  ?n sh:property ?p .
  ?p sh:path ?path .
  OPTIONAL { ?p sh:name ?name }
  OPTIONAL { ?p sh:description ?description }
  OPTIONAL { ?p sh:minCount ?minCount }
  OPTIONAL { ?p sh:maxCount ?maxCount }
  #OPTIONAL { ?p sh:node [ sh:targetClass ?nodeTargetClass ] }
  #OPTIONAL { ?p sh:class ?class }
  OPTIONAL { ?p sh:hasValue ?hasValue
    FILTER (isLiteral(?hasValue))
  }
  OPTIONAL { ?p sh:in ?in }
  OPTIONAL { ?p sh:datatype ?datatype }
  #OPTIONAL { ?p sh:minExclusive ?minExclusive }
  #OPTIONAL { ?p sh:minInclusive ?minInclusive }
  #OPTIONAL { ?p sh:maxExclusive ?maxExclusive }
  #OPTIONAL { ?p sh:maxInclusive ?maxInclusive }
  #OPTIONAL { ?p sh:minLength ?minLength }
  #OPTIONAL { ?p sh:maxLength ?maxLength }
  #OPTIONAL { ?p sh:pattern ?pattern }
  #OPTIONAL { ?p sh:flags ?flags }
  FILTER ( ?path IN (
#imf:classifier
#imf:hasAspect
#imf:hasAttribute
#imf:hasAttributeQualifier
#imf:hasInputTerminal
#imf:hasOutputTerminal
#imf:hasTerminal
#imf:hasTerminalQualifier
#imf:medium
#imf:predicate
imf:symbol,
#imf:uom
imf:value,
skos:notation
) )
}
#+END_SRC

**** _SPARQL queries
#+XXXCALL: py_run_sparql(query=sparql_shaclClass, data="example/pumpingFunctionType.xlsx.ttl")

#+RESULTS:
| ~class~                         | ~imfClass~      | ~name~                     | ~description~ | ~severity~ | ~message~ |
|---------------------------------+-----------------+----------------------------+---------------+------------+-----------|
| ~ns1:ApplicationStandard~       | ~imf:Attribute~ |                            |               |            |           |
| ~ns1:ClientRequirementDocument~ | ~imf:Attribute~ |                            |               |            |           |
| ~ns1:ElectricPower~             | ~imf:Attribute~ |                            |               |            |           |
| ~ns1:Fluid~                     | ~imf:Attribute~ |                            |               |            |           |
| ~ns1:LiquidPumping~             | ~imf:Block~     | ~Pumping, liquid velocity~ |               |            |           |
| ~ns1:MechanicalRotationInput~   | ~imf:Terminal~  |                            |               |            |           |
| ~ns1:MediaDatasheet~            | ~imf:Attribute~ |                            |               |            |           |
| ~ns1:NoiseRequirementStandard~  | ~imf:Attribute~ |                            |               |            |           |
| ~ns1:PressureDelta~             | ~imf:Attribute~ |                            |               |            |           |
| ~ns1:Pressure~                  | ~imf:Attribute~ |                            |               |            |           |
| ~ns1:PumpingPower~              | ~imf:Attribute~ |                            |               |            |           |
| ~ns1:RotationalVelocity~        | ~imf:Attribute~ |                            |               |            |           |
| ~ns1:SuctionPressure~           | ~imf:Attribute~ |                            |               |            |           |
| ~ns1:VolumetricFlowrate~        | ~imf:Attribute~ |                            |               |            |           |
| ~ns1:WaterPumpingTerminal~      | ~imf:Terminal~  |                            |               |            |           |

#+XXXCALL: py_run_sparql(query=sparql_shaclObjectPropertyConstraint, data="example/pumpingFunctionType.xlsx.ttl")

#+RESULTS:
| ~class~                       | ~path~                  | ~name~ | ~description~ | ~minCount~ | ~maxCount~ | ~nodeTargetClass~               | ~hasValue~           | ~in~ |
|-------------------------------+-------------------------+--------+---------------+------------+------------+---------------------------------+----------------------+------|
| ~ns1:LiquidPumping~           | ~imf:hasInputTerminal~  | ~T1~   |               | ~2~        |            | ~ns1:WaterPumpingTerminal~      |                      |      |
| ~ns1:LiquidPumping~           | ~imf:hasInputTerminal~  | ~T2~   |               | ~1~        |            | ~ns1:MechanicalRotationInput~   |                      |      |
| ~ns1:LiquidPumping~           | ~imf:hasAttribute~      |        |               | ~0~        |            | ~ns1:NoiseRequirementStandard~  |                      |      |
| ~ns1:LiquidPumping~           | ~imf:classifier~        |        |               |            |            |                                 | ~ns2:Pumping~        |      |
| ~ns1:LiquidPumping~           | ~imf:hasAspect~         |        |               |            |            |                                 | ~imf:functionAspect~ |      |
| ~ns1:LiquidPumping~           | ~imf:hasOutputTerminal~ | ~T3~   |               | ~1~        |            | ~ns1:WaterPumpingTerminal~      |                      |      |
| ~ns1:LiquidPumping~           | ~imf:hasAttribute~      |        |               | ~1~        |            | ~ns1:Fluid~                     |                      |      |
| ~ns1:LiquidPumping~           | ~imf:hasAttribute~      |        |               | ~1~        |            | ~ns1:PressureDelta~             |                      |      |
| ~ns1:LiquidPumping~           | ~imf:hasAttribute~      |        |               | ~1~        |            | ~ns1:SuctionPressure~           |                      |      |
| ~ns1:LiquidPumping~           | ~imf:hasAttribute~      |        |               | ~1~        |            | ~ns1:Pressure~                  |                      |      |
| ~ns1:LiquidPumping~           | ~imf:hasAttribute~      |        |               | ~1~        |            | ~ns1:PumpingPower~              |                      |      |
| ~ns1:LiquidPumping~           | ~imf:hasAttribute~      |        |               | ~0~        |            | ~ns1:ApplicationStandard~       |                      |      |
| ~ns1:LiquidPumping~           | ~imf:hasAttribute~      |        |               | ~0~        |            | ~ns1:ClientRequirementDocument~ |                      |      |
| ~ns1:MechanicalRotationInput~ | ~imf:hasAttribute~      |        |               | ~1~        |            | ~ns1:ElectricPower~             |                      |      |
| ~ns1:MechanicalRotationInput~ | ~imf:hasAttribute~      |        |               | ~1~        |            | ~ns1:RotationalVelocity~        |                      |      |
| ~ns1:MechanicalRotationInput~ | ~imf:hasAttribute~      |        |               | ~1~        |            | ~ns1:MediaDatasheet~            |                      |      |
| ~ns1:VolumetricFlowrate~      | ~imf:uom~               |        |               |            |            |                                 |                      |      |
| ~ns1:WaterPumpingTerminal~    | ~imf:hasAttribute~      |        |               | ~1~        |            | ~ns1:Pressure~                  |                      |      |
| ~ns1:WaterPumpingTerminal~    | ~imf:hasAttribute~      |        |               | ~1~        |            | ~ns1:VolumetricFlowrate~        |                      |      |
| ~ns1:WaterPumpingTerminal~    | ~imf:hasAttribute~      |        |               | ~1~        |            | ~ns1:MediaDatasheet~            |                      |      |
| ~ns1:WaterPumpingTerminal~    | ~imf:classifier~        |        |               |            |            |                                 | ~ns2:RDS4233125~     |      |
| ~ns1:WaterPumpingTerminal~    | ~imf:medium~            |        |               |            |            |                                 | ~ns2:WaterMedia~     |      |

#+XXXCALL: py_run_sparql(query=sparql_shaclDataPropertyConstraint, data="example/pumpingFunctionType.xlsx.ttl")

#+RESULTS:
| ~class~                         | ~path~          | ~name~ | ~description~ | ~minCount~ | ~maxCount~ | ~hasValue~ | ~in~                                    | ~datatype~ | ~minExclusive~ | ~minInclusive~ | ~maxExclusive~ | ~maxInclusive~ | ~pattern~ |
|---------------------------------+-----------------+--------+---------------+------------+------------+------------+-----------------------------------------+------------+----------------+----------------+----------------+----------------+-----------|
| ~ns1:ClientRequirementDocument~ | ~imf:value~     |        |               |            |            |            | ~_:na5f020712cff4aa9a19acd79447e9a7db2~ |            |                |                |                |                |           |
| ~ns1:LiquidPumping~             | ~imf:symbol~    |        |               |            |            | ~SP402~    |                                         |            |                |                |                |                |           |
| ~ns1:LiquidPumping~             | ~skos:notation~ |        |               |            |            | ~KR~       |                                         |            |                |                |                |                |           |
| ~ns1:VolumetricFlowrate~        | ~imf:value~     |        |               |            |            |            |                                         |            |                | ~10~           |                | ~1000~         |           |


#+BEGIN_SRC ttl :noweb strip-export :XXXtangle out/ottr/imf-type-owl2.stottr :mkdirp yes
<<prefixes>>

o-imf-t-o:PropertyConstraint[
  ottr:IRI ?constraint,
  owl:Class ?class,
  ottr:IRI ?path,
  ? xsd:string ?name,
  ? xsd:string ?description,
  xsd:nonNegativeInteger ?minCount="0"^^xsd:nonNegativeInteger,
  ? xsd:nonNegativeInteger ?maxCount,
  ? rdfs:Resource ?hasValue
] :: {
  o-rdfs:SubClassOf(?class, ?constraint),

  o-rdfs:TypedResourceDescription(?constraint, owl:Restriction, ?name, ?description, none, none),
  ottr:Triple(?constraint, owl:onProperty, ?path),

  ottr:Triple(?constraint, owl:minQualifiedCardinality, ?minCount),
  ottr:Triple(?constraint, owl:maxQualifiedCardinality, ?maxCount),

  ottr:Triple(?constraint, owl:hasValue, ?hasValue)
} .

o-imf-t-o:ObjectPropertyConstraint[
  owl:Class ?class,
  owl:ObjectProperty ?path,
  ? xsd:string ?name,
  ? xsd:string ?description,
  ? xsd:nonNegativeInteger ?minCount,
  ? xsd:nonNegativeInteger ?maxCount,
  owl:Class ?nodeTargetClass = owl:Thing,
  ? owl:NamedIndividual ?hasValue,
  ? NEList<owl:NamedIndividual> ?in
] :: {
  o-imf-t-o:PropertyConstraint(_:C, ?class, ?path, ?name, ?description, ?minCount, ?maxCount, ?hasValue),
  ottr:Triple(_:C, owl:onClass, ?nodeTargetClass),
  o-rdf:Type(?path, owl:ObjectProperty), # can drop this if we import

  o-imf-t-o:ObjectAllValuesFromOneOf(_:C, ?in)


} .

o-imf-t-o:ObjectAllValuesFromOneOf[
  ottr:IRI ?constraint,
  NEList<owl:NamedIndividual> ?in
] :: {
  ottr:Triple(?constraint, owl:allValuesFrom, _:oneOfClass),
  o-owl-rstr:ObjectOneOf(_:oneOfClass, ?in)
} .

o-imf-t-o:DatatypePropertyConstraint[
  owl:Class ?class,
  owl:DatatypeProperty ?path,
  ? xsd:string ?name,
  ? xsd:string ?description,
  ? xsd:nonNegativeInteger ?minCount,
  ? xsd:nonNegativeInteger ?maxCount,
  #? owl:Class ?nodeTargetClass,
  ? rdfs:Literal ?hasValue,
  ? List<rdfs:Literal> ?in,
  rdfs:Datatype ?targetDatatype = rdfs:Literal
  #? ?minExclusive,
  #? ?minInclusive,
  #? ?maxExclusive,
  #? ?maxInclusive,
  #? xsd:integer ?minLength,
  #? xsd:integer ?maxLength,
  #? xsd:string ?pattern
  #? xsd:string ?flags
] :: {
  o-imf-t-o:PropertyConstraint(_:C, ?class, ?path, ?name, ?description, ?minCount, ?maxCount, ?hasValue),
  ottr:Triple(_:C, owl:onDataRange, ?targetDatatype),
  o-rdf:Type(?path, owl:DatatypeProperty), # can drop this if we import

  #zipMin | o-imf-t-o:onRestrictedDataRange(_:C, ?targetDatatype,
  #  ++(owl:minExclusive, owl:minInclusive, owl:maxExclusive, owl:maxInclusive, owl:pattern),
  #  ++(?minExclusive, ?minInclusive, ?maxExclusive, ?maxInclusive, ?pattern)
  #)
}
.

o-imf-t-o:onRestrictedDataRange[
  ottr:IRI ?constraint,
  rdfs:Datatype ?datatype,
  ! ottr:IRI ?facet,
  ?value
] :: {
  ottr:Triple(?constraint, owl:onDataRange, _:range)
  o-rdf:Type(_:range, rdfs:Datatype),
  ottr:Triple(_:range, owl:onDatatype, ?datatype),
  ottr:Triple(_:range, owl:withRestrictions, (_:facet)),
  ottr:Triple(_:facet, ?facet, ?value)
} .



#+END_SRC

#+BEGIN_SRC ttl

o-imf-t-o:_Constraint[
  ottr:IRI ?constraint,
  ottr:IRI ?property,
  ? xsd:string ?name,
  ? xsd:description ?description
] :: {
} .

o-imf-t-o:_CardinalityConstraint[
  ottr:IRI ?constraint = _:C,
  xsd:nonNegativeInteger ?min="0"^^xsd:nonNegativeInteger,
  ? xsd:nonNegativeInteger ?max,
  ? owl:Class ?targetClass,
  ? rdfs:Datatype ?targetDatatype
] :: {
  ottr:Triple(?constraint, owl:minQualifiedCardinality, ?min),
  ottr:Triple(?constraint, owl:maxQualifiedCardinality, ?max),
  ottr:Triple(?constraint, owl:onClass, ?targetClass),
  ottr:Triple(?constraint, owl:onDataRange, ?targetDatatype)
}

o-imf-t-o:_ValueConstraint[
  ottr:IRI ?constraint = _:C,
  ottr:IRI ?property,
  ?value
] :: {

}


o-imf-t-o:DataPropertyConstraint[
  owl:Class ?class,
  owl:DatatypeProperty ?path,
  ? xsd:string ?name,
  ? xsd:description ?description,
  ? xsd:nonNegativeInteger ?minCount,
  ? xsd:nonNegativeInteger ?maxCount,
  ? rdfs:Literal ?hasValue,
  ? List<rdfs:Literal> ?in,
  ? rdfs:Datatype ?datatype,
  ? ?minExclusive,
  ? ?minInclusive,
  ? ?maxExclusive,
  ? ?maxInclusive,
  ? xsd:integer ?minLength,
  ? xsd:integer ?maxLength,
  ? xsd:string ?pattern,
  ? xsd:string ?flags
] :: {
  o-imf-t-o:PropertyConstraint(?class, ?path, ?name, ?description),
  o-owl-ax:SubDataHasValue(?class, ?path, ?hasValue),
  zipMin | o-imf-t-o:SubDataAllValuesFromDatatypeFacet(?class, ?path, ?datatype,
    ++(owl:minExclusive, owl:minInclusive, owl:maxExclusive, owl:maxInclusive, owl:minLength, owl:maxLength, owl:pattern),
    ++(?minExclusive, ?minInclusive, ?maxExclusive, ?maxInclusive, ?minLength, ?maxLength, ?pattern)
  )
} .

o-imf-t-o:SubDataAllValuesFromDatatypeFacet[
  owl:Class ?class,
  owl:DatatypeProperty ?prop,
  rdfs:Datatype ?datatype,
  ! ottr:IRI ?facet,
  ?value
] :: {
  o-owl-ax:SubDataAllValuesFrom(?class, ?prop, _:restriction),
  o-imf-t-o:DatatypeRestriction(_:restriction, ?datatype, ?facet, ?value)
} .


#+END_SRC

https://stackoverflow.com/questions/36008786/proper-way-to-describe-string-literal-in-owl

**** bOTTR map

#+BEGIN_SRC ttl :noweb yes :XXXtangle out/bottr/types.bottr :mkdirp yes
<<prefixes>>

_:data a ottr:RDFFileSource ;
  ottr:sourceURL "../../example/pumpingFunctionType.xlsx.ttl" .

### For testing
[] a ottr:XXXInstanceMap ;
  ottr:source _:data ;
  ottr:query """
    SELECT ?s ?p ?o
    WHERE { ?s ?p ?o }
    LIMIT 1
  """;
  ottr:template ottr:Triple .

[] a ottr:InstanceMap ;
  ottr:template o-imf-t-o:TypeClass ;
  ottr:source _:data ;
  ottr:query """
<<sparql_shaclClass>>
"""
.

[] a ottr:InstanceMap ;
  ottr:template o-imf-t-o:ObjectPropertyConstraint ;
  ottr:source _:data ;
  ottr:query """
<<sparql_shaclObjectPropertyConstraint>>
"""
.

[] a ottr:InstanceMap ;
  ottr:template o-imf-t-o:DatatypePropertyConstraint ;
  ottr:source _:data ;
  ottr:query """
<<sparql_shaclDatatypePropertyConstraint>>
"""
.

#+END_SRC

*** +RDF prototype: imftype-shacl2rdf.py+                          :noexport:

The following python script translates IMF types in SHACL format to an
prototypical RDF instance.

#+NAME: py_prototype_from_shacl
#+BEGIN_SRC python :XXXtangle out/py/imftype-shacl2rdf.py :mkdirp yes
import sys, getopt
import rdflib
from rdflib import Graph, URIRef, BNode, Literal
from rdflib.namespace import NamespaceManager, SH, RDFS, RDF, SKOS, OWL
from rdflib.collection import Collection

# input graph containing SHACL IMF types
iG = rdflib.Graph()

# output graph to contain RDF IMF model prototype
oG = rdflib.Graph()

nsPrototype = "http://example.org/prototype#"
nsIMF = "http://ns.imfid.org/imf#"
oG.bind("x", nsPrototype)
oG.bind("imf", nsIMF)

# list and function for storing constraint data as an editorialNote
shPs = [
  'name',
  'description',
  'class',
  'datatype',
  'minCount',
  'maxCount',
  'minExclusive',
  'minInclusive',
  'maxExclusive',
  'maxInclusive',
  'minLength',
  'maxLength',
  'pattern',
  'flags'
]

# list of IMF classes that have associated Types
types = ['Block', 'Terminal', 'Attribute']

idN = 0

# function to generate new resources
def newId():
#return BNode()
  global idN
  idN += 1
  return URIRef(nsPrototype + "id-" + str(idN))


def copyConstraintAsNote(shapeId, protoId, noteHeading):
  note = ""
  # single value properties
  for p in shPs:
    for o in iG.objects(shapeId, SH[p], None):
      note += "  - " + p + ": " + o + "\n"

  # list value property
  for o in iG.objects(shapeId, SH['in'], None):
    note += "  - in (values): " + ", ".join(Collection(iG, o)) + "\n"

  if note != "":
    oG.add((protoId, SKOS.editorialNote, Literal(noteHeading + ":\n" + note)))


def nodeShape(nodeId, protoId):

  for t in types:
    if (nodeId, RDF.type, URIRef(nsIMF + t + "Type")) in iG: # get the type class
      oG.add((protoId, RDF.type, URIRef(nsIMF + t))) # add the class

  for o in iG.objects(nodeId, SH.targetClass, None):
    oG.add((protoId, RDF.type, o))

  copyConstraintAsNote(nodeId, protoId, "SHACL Node shape description")

  for o in iG.objects(nodeId, SH.property, None):
    propShape(protoId, o)

def propShape(protoId, propId):

  path = iG.value(propId, SH.path, None)

  # if property shape has hasValue then add the value ...
  if (propId, SH.hasValue, None) in iG:
    for o in iG.objects(propId, SH.hasValue, None):
      oG.add((protoId, path, o))

  # ... otherwise, for each minCount > 1, create a placeholder resource annotated with constraint info
  else:
    for n in range(max(1, int(iG.value(propId, SH.minCount, None, default=1)))):
      new = newId()
      oG.add((protoId, path, new))
      #copyConstraintAsNote(propId, new, "SHACL Property shape specification")
      if (propId, SH.node, None) in iG:
	nodeShape(iG.value(propId, SH.node, None), new)

def main(argv):
  inputfile = ''
  shapeIRI = ''
  outputfile = ''
  opts, args = getopt.getopt(argv,"hi:o:n:",["ifile=","ofile=","nodeShapeIRI="])

  for opt, arg in opts:
    if opt == '-h':
      print (sys.argv[0] + " -i <inputfile> -o <outputfile>")
      sys.exit()
    elif opt in ("-i", "--ifile"):
      inputfile = arg
    elif opt in ("-o", "--ofile"):
      outputfile = arg
    elif opt in ("-n", "--nodeShapeIRI"):
      shapeIRI = arg

  if inputfile == '' or outputfile == '':
    print("Error: missing options!")
    print("Usage: " + sys.argv[0] + " -i <inputfile> [-n <nodeShapeIRI>] -o <outputfile>")
    sys.exit()

  # Read input
  iG.parse(inputfile, format="ttl")

  if shapeIRI == '':
    for s in iG.subjects(RDF.type, SH.NodeShape):
      nodeShape(s, newId())
  else:
    nodeShape(URIRef(shapeIRI), newId())

  oG.serialize(destination=outputfile)

if __name__ == "__main__":
   main(sys.argv[1:])
#+END_SRC


*** +OWL class representation: imftype-shacl2owl.py+               :noexport:

The following python script translates IMF types in SHACL format to an
OWL Class representation.

#+BEGIN_SRC python :XXXtangle out/py/imftype-shacl2owl.py :mkdirp yes
import sys, getopt
import rdflib
from rdflib import Graph, URIRef, BNode, Literal
from rdflib.namespace import NamespaceManager, XSD, SH, RDFS, RDF, SKOS, OWL
from rdflib.collection import Collection

def newId():
  return BNode()

# input graph containing SHACL IMF types
iG = rdflib.Graph()


nsIMF = "http://ns.imfid.org/imf#"

# IMF vocabulary
ontIMF = rdflib.Graph()
iriIMF = "https://imf-lab.gitlab.io/imf-ontology/out/owl/imf-ontology.owl.ttl"
ontIMF.parse(iriIMF, format="ttl")
ontIMF.bind("imf", nsIMF)

# output graph
oG = rdflib.Graph()
oG.bind("imf", nsIMF)

# list of IMF classes that have associated Types
types = ['Block', 'Terminal', 'Attribute']

# map of type classes to IMF classes
mapC = { URIRef(nsIMF + t + "Type"): URIRef(nsIMF + t) for t in types }

# map SHACL to OWL
map = {
  SH.name: RDFS.label,
  SH.description: RDFS.comment,
  SH.path: OWL.onProperty,
  SH.hasValue: OWL.hasValue,
  SH.minCount: OWL.minQualifiedCardinality,
  SH.maxCount: OWL.maxQualifiedCardinality,
  SH.datatype: OWL.onDataRange,
  SH.minExclusive: XSD.minExclusive,
  SH.minInclusive: XSD.minInclusive,
  SH.maxExclusive: XSD.maxExclusive,
  SH.maxInclusive: XSD.maxInclusive,
  SH.minLength: XSD.minLength,
  SH.maxLength: XSD.maxLength ,
  SH.pattern: XSD.pattern
  #SH.flags:
}

# selection of properties
mapP = [
  SH.name,
  SH.description,
  SH.path,
  SH.hasValue,
  SH.minCount,
  SH.maxCount
]

# selection of facets
mapF = [
  SH.minExclusive,
  SH.minInclusive,
  SH.maxExclusive,
  SH.maxInclusive,
  SH.minLength,
  SH.maxLength,
  SH.pattern
  #SH.flags
]

def copyObjects(sourceS, sourceP, targetS, targetP, defaultO=None):
  if (sourceS, sourceP, None) in iG:
    for o in iG.objects(sourceS, sourceP, None):
      oG.add((targetS, targetP, o))
  elif defaultO != None:
    oG.add((targetS, targetP, defaultO))

# add a list to output graph as RDF list
def addCollection(targetS, targetP, collection):
  size = len(collection)
  head = newId()
  oG.add((targetS, targetP, head))
  for i in range(size):
    newHead = newId()
    oG.add((head, RDF.first, collection[i]))
    if (i == size-1):
      oG.add((head, RDF.rest, RDF.nil))
    else:
      oG.add((head, RDF.rest, newHead))
      head = newHead

### Create a class of the node shape, adding propertyShapes as class restrictions.
def nodeShape(nShape):

  # get IRI
  classId = iG.value(nShape, SH.targetClass, None)
  oG.add((classId, RDF.type, OWL.Class))

  # translate classification
  superclasses = []
  for key in mapC:
    if (nShape, RDF.type, key) in iG:
      oG.add((classId, RDFS.subClassOf, mapC[key]))
      superclasses.append(mapC[key])

  # translate SH properties to OWL
  for key in mapP:
    copyObjects(nShape, key, classId, map[key])

  # collect class restriction resources for each SH property shape:
  restrictions = []

  for pShape in iG.objects(nShape, SH.property, None):
    rstr = newId()
    oG.add((classId, RDFS.subClassOf, rstr))
    if propShape(rstr, pShape): # collect only non-vacuous restrictions
      restrictions.append(rstr)

  if len(restrictions) > 1:
    restrictions.extend(superclasses)
    _equivs = newId()
    oG.add((_equivs, RDFS.subClassOf, classId))
    oG.add((_equivs, RDF.type, OWL.Class))
    addCollection(_equivs, OWL.intersectionOf, restrictions)

### Create class restrictions of property shape.
def propShape(rstr, pShape):

  oG.add((rstr, RDF.type, OWL.Restriction))

  # translate SH properties to OWL
  for key in mapP:
    copyObjects(pShape, key, rstr, map[key])

  # add target class/datatype if not a hasValue
  if (rstr, OWL.hasValue, None) not in oG:

    # add default min card if not set
    if (rstr, OWL.minQualifiedCardinality, None) not in oG:
      oG.add((rstr, OWL.minQualifiedCardinality, Literal(0, datatype=XSD.nonNegativeInteger)))

    # is path a data property or object property; let's ask the IMF ontology.
    property = iG.value(pShape, SH.path, None)
    if (property, RDF.type, OWL.ObjectProperty) in ontIMF:
      targetProperty = OWL.onClass
      targetClassifier = OWL.Class
    else:
      targetProperty = OWL.onDataRange
      targetClassifier = RDFS.Datatype

    # SH.in, copy list
    for o in iG.objects(pShape, SH['in']):
      _oneOf = newId()
      oG.add((rstr, targetProperty, _oneOf))
      oG.add((_oneOf, RDF.type, targetClassifier))
      addCollection(_oneOf, OWL.oneOf, Collection(iG, o))


    if targetProperty == OWL.onClass: # ObjectProperty

      # add SH.node -> SH.targetClasses as OWL.onClass
      for nShape in iG.objects(pShape, SH.node):
	for targetClass in iG.objects(nShape, SH.targetClass):
	  oG.add((rstr, OWL.onClass, targetClass))

      if (rstr, OWL.onClass, None) not in oG:
	oG.add((rstr, OWL.onClass, OWL.Thing))

    else: # not ObjectProperty

      # get datatype, defaulting to RDFS.Literal
      datatype = iG.value(pShape, SH.datatype, None, RDFS.Literal)

      # collect any facets
      facetTriples = []
      for key in mapF:
	if (pShape, key, None) in iG:
	  facetTriples.append((newId(), map[key], iG.value(pShape, key, None)))

      # create a wrapping datatype for the facets
      if len(facetTriples) > 0:
	_datatype = newId()
	facetS = [t[0] for t in facetTriples]
	oG.add((rstr, OWL.onDataRange, _datatype))
	oG.add((_datatype, RDF.type, RDFS.Datatype))
	oG.add((_datatype, OWL.onDatatype, datatype))
	for t in facetTriples:
	  oG.add(t)
	addCollection(_datatype, OWL.withRestrictions, facetS)

      # if no facets, add datatype
      else:
	oG.add((rstr, map[SH.datatype], datatype))

  # return True if include in intersectionOf axioms on class, avoiding vacuous statements
  return (rstr, OWL.hasValue, None) in oG or oG.value(rstr, OWL.minQualifiedCardinality, None, Literal(0)) > Literal(0)

def main(argv):
  inputfile = ''
  outputfile = ''
  opts, args = getopt.getopt(argv,"hi:o:",["ifile=","ofile="])

  for opt, arg in opts:
    if opt == '-h':
      print (sys.argv[0] + " -i <inputfile> -o <outputfile>")
      sys.exit()
    elif opt in ("-i", "--ifile"):
      inputfile = arg
    elif opt in ("-o", "--ofile"):
      outputfile = arg

  if inputfile == '' or outputfile == '':
    print("Error: missing options!")
    print("Usage: " + sys.argv[0] + " -i <inputfile> -o <outputfile>")
    sys.exit()

  # Read input
  iG.parse(inputfile, format="ttl")

  # Translate all node shapes
  for x in iG.subjects(RDF.type, SH.NodeShape):
    nodeShape(x)

  # Add ontology import
  _ont = newId()
  oG.add((_ont, RDF.type, OWL.Ontology))
  oG.add((_ont, OWL.imports, URIRef(iriIMF)))
  oG.serialize(destination=outputfile)

if __name__ == "__main__":
   main(sys.argv[1:])
#+END_SRC

#+RESULTS: py_types_owl_from_shacl
[[file:None]]



** Introduction                                                      :update:
*** TODO IMF IT Document Overview

**** Version 2

#+BEGIN_SRC dot :file out/img/plantuml-specifications-v2.png :exports results :noweb yes
digraph {
 rankdir = TB;
 newrank=true;

 <<graphviz-style>>

 IMF_Manual ->  Vocabulary, Grammar, Semantics;

 DataModel, Vocabulary -> OWL;
 DataModel, Grammar -> SHACL;
 Semantics -> ISO15926_14;

 DataModel -> OTTR -> RDFdata;

 OWL, SHACL -> RDFdata [dir=back];

 OTTR -> SHACLtypes, OWLclasses;

 SHACLtypes -> RDFdata [dir=back, constraint=false];
 OWLclasses -> RDFdata [dir=back, constraint=false, style=dotted];

 ISO15926_14 -> OWLclasses;

}

#+END_SRC

#+RESULTS:
[[file:out/img/plantuml-specifications-v2.png]]

**** Version 1

Todos:
 - collapse data and types whereever approprioate

/This is loosely inspired by the OWL 2 Web Ontology Language Document Overview [[https://www.w3.org/TR/2012/REC-owl2-plantuml-20121211/]]./


This document defines the following:

 - A structural specification of IMF, or IMF datamodel, including IMF
   Data (2) and IMF Types (3) based on the formal abstract
   specification of IMF (1).
 - The IMF Vocabulary (9) and IMF Grammar (10) are an implementation
   of (parts of) the Structural specification (2+3).
 - IMF Data (2) is represented in different forms:
   - The IMF Data exchange format (7) is RDF as specified by the IMF
     grammar (10), specified in the form of a set of SHACL shapes, and
     uses the IMF vocabulary (9), specified in the form of an OWL
     ontology.
   - OTTR templates represent an implementation of the structural
     specification of IMF Data, and may be used to generate the IMF
     Data exchange format (7) and OWL instances as according to the
     ISO 15926-14 ontology (11).
 - IMF types (3) are represented in different formats:
   - An exchange format for IMF types (6) should be specified.
   - SHACL shapes (8) capture the constraint nature of IMF types and
     may be used validate the IMF Data Exchange format (7).
   - OWL class definitions (12) following the ISO 15926-14 OWL ontology
     capture the semantics of the types and may be used for semantic
     validation of the types and their instances.
   - OTTR templates (5) represent an implementation of the structural
     specification of types, and allow for a succinct definition of
     the translation into SHACL shapes (8) and OWL class definitions
     (12).
   - It should be possible to define a grammar (10b) for IMF Type
     SHACL constraints, in the form of a subset or dialect of the
     SHACL standard.

 The (generated) diagram below illustrates the main relations between
 the parts of the specification. Green boxes indicates a single
 "schematic" specifications. Blue boxes indicate specification of
 multiple multiple occurrences.

#+BEGIN_SRC dot :file out/img/plantuml-specifications-v1.png :exports results :noweb yes
digraph {
 rankdir = BT;
 newrank=true;

 <<graphviz-style>>

     IMFdataAbsSpec [label="IMF (1)\nAbstract spec.", fillcolor=lightyellow]

     IMFdataAbsSpec -> IMFdataSpec;
     IMFdataAbsSpec -> IMFtypeSpec [style=dashed];

     IMFdataSpec [label="IMF Data (2)\nStructural spec.", fillcolor=pink]
     IMFtypeSpec [label="IMF Type (3)\nStructural spec.", fillcolor=pink]

     IMFdataSpec -> data [arrowhead=none, constraint=false, color=gray];
     IMFdataSpec -> data_patterns [arrowhead=none, color=gray];
     IMFdataSpec -> p14_data [arrowhead=none, constraint=false, color=gray] ;

     IMFdataSpec -> IMFtypeSpec [constraint=false];

     IMFtypeSpec -> types [arrowhead=none, constraint=false, color=gray];
     IMFtypeSpec -> type_patterns [arrowhead=none, color=gray];
     IMFtypeSpec -> type_syntax [arrowhead=none, color=gray];
     IMFtypeSpec -> p14_types [arrowhead=none, constraint=false, color=gray];

    { rank="same"
    voc [label="IMF Vocabulary (9)\nOWL", fillcolor=darkseagreen2];
    grammar [label="IMF Grammar (10)\nSHACL", fillcolor=darkseagreen2];
    typegrammar [style="dashed,filled", label="IMF Type Grammar (10b)\nSHACL", fillcolor=darkseagreen];
    }

    { rank="same"
    data [label="IMF Data (7)\nExchange format\nRDF",fillcolor=darkslategray2];
    types [label="IMF Types (8)\nConstraints\nSHACL",fillcolor=darkslategray2];
    }

     types -> grammar [style="dashed", label="\"restricts\""];
     data -> voc [label = "uses"];
     grammar -> voc [label = "uses", constraint=false];
     typegrammar -> types [label = "validates", constraint=false];

     data -> grammar [dir="back", label = "validates"];
     data -> types [dir="back", constraint=false, label="validates"];


    { rank="same"
    data_patterns [label="IMF Data (4)\nTemplate\nOTTR", fillcolor=darkseagreen2];
    type_patterns [label="IMF Type (5)\nTemplate\nOTTR", fillcolor=darkseagreen2];
    type_syntax [style="filled,dashed", label="IMF Type (6)\nExchange format\n??", fillcolor=darkseagreen];
    }

    type_patterns -> data_patterns [style=dotted, arrowhead=none, constraint=false];


  subgraph cluster_p14 {

    p14 [label="ISO 15926-14 (14)\nOWL"]
    rdl [label="PCA RDL (13)\nOWL"]
    p14_types [label="IMF Types (12)\nSemantics\nOWL classes", fillcolor=darkslategray3];
    p14_data [label="IMF Data (11)\nSemantics\nOWL instances", fillcolor=darkslategray3];

   rdl -> p14;
  }


 ##### edges

 data_patterns -> data  [label="expands"];
 type_patterns -> types [label="expands"];

 type_patterns -> p14_types [label="expands", constraint=false];
 data_patterns -> p14_data  [label="expands", constraint=false];

 p14_data -> p14_types [label="inst. of"];
 p14_types -> rdl;
 #types -> rdl [style="dashed", constraint=false];
 p14_types -> IMFtypeSpec [constraint=false, label = "verifiy"];


}
#+END_SRC

#+RESULTS:
[[file:out/img/plantuml-specifications.png]]

*** TODO W3C technology

[Explain and motivate the use of semantic technologies?]

**** RDF

RDF is an abstract data model defined as an open standard by the W3C.

RDF may be serialised in different serialisation formats such as
RDF/XML (based on XML), JSON-LD (based on JSON), Turtle (a favourite
amongst many familiar with RDF due to its ease of reading and
writing), or N-Triples (a very simple format only appropriate for
software).
