#+TITLE: IMF Language v2.1
#+DATE: Editor: Martin G. Skj√¶veland
#+AUTHOR:
#+EMAIL:

#+OPTIONS: ':nil *:t -:t ::t <:t H:4 \n:nil ^:t arch:headline
#+OPTIONS: author:t broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:t todo:t |:t
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport QA update old
#+EXPORT_FILE_NAME: index.html

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [12pt]
#+LATEX_HEADER: \usepackage{fullpage,parskip,times}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \usepackage[zerostyle=d]{newtxtt} %% Various versions of zeros available. See documentation for details
 

* Introduction                                                       :update:
** TODO IMF IT Document Overview

*** Version 2

#+BEGIN_SRC dot :file out/img/overview-specifications-v2.png :exports results :noweb yes
digraph {
 rankdir = TB;
 newrank=true;
 
 <<graphviz-style>>

 IMF_Manual ->  Vocabulary, Grammar, Semantics;

 DataModel, Vocabulary -> OWL;
 DataModel, Grammar -> SHACL;
 Semantics -> ISO15926_14;

 DataModel -> OTTR -> RDFdata;

 OWL, SHACL -> RDFdata [dir=back];

 OTTR -> SHACLtypes, OWLclasses;

 SHACLtypes -> RDFdata [dir=back, constraint=false];
 OWLclasses -> RDFdata [dir=back, constraint=false, style=dotted];

 ISO15926_14 -> OWLclasses;

}

#+END_SRC

#+RESULTS:
[[file:out/img/overview-specifications-v2.png]]

*** Version 1

Todos:
 - collapse data and types whereever approprioate

/This is loosely inspired by the OWL 2 Web Ontology Language Document Overview [[https://www.w3.org/TR/2012/REC-owl2-overview-20121211/]]./


This document defines the following:

 - A structural specification of IMF, or IMF datamodel, including IMF
   Data (2) and IMF Types (3) based on the formal abstract
   specification of IMF (1).
 - The IMF Vocabulary (9) and IMF Grammar (10) are an implementation
   of (parts of) the Structural specification (2+3).
 - IMF Data (2) is represented in different forms:
   - The IMF Data exchange format (7) is RDF as specified by the IMF
     grammar (10), specified in the form of a set of SHACL shapes, and
     uses the IMF vocabulary (9), specified in the form of an OWL
     ontology.
   - OTTR templates represent an implementation of the structural
     specification of IMF Data, and may be used to generate the IMF
     Data exchange format (7) and OWL instances as according to the
     ISO 15926-14 ontology (11).
 - IMF types (3) are represented in different formats:
   - An exchange format for IMF types (6) should be specified.
   - SHACL shapes (8) capture the constraint nature of IMF types and
     may be used validate the IMF Data Exchange format (7).
   - OWL class definitions (12) following the ISO 15926-14 OWL ontology
     capture the semantics of the types and may be used for semantic
     validation of the types and their instances.
   - OTTR templates (5) represent an implementation of the structural
     specification of types, and allow for a succinct definition of
     the translation into SHACL shapes (8) and OWL class definitions
     (12).
   - It should be possible to define a grammar (10b) for IMF Type
     SHACL constraints, in the form of a subset or dialect of the
     SHACL standard.

 The (generated) diagram below illustrates the main relations between
 the parts of the specification. Green boxes indicates a single
 "schematic" specifications. Blue boxes indicate specification of
 multiple multiple occurrences.

#+BEGIN_SRC dot :file out/img/overview-specifications-v1.png :exports results :noweb yes
digraph {
 rankdir = BT;
 newrank=true;
 
 <<graphviz-style>>

     IMFdataAbsSpec [label="IMF (1)\nAbstract spec.", fillcolor=lightyellow]

     IMFdataAbsSpec -> IMFdataSpec;
     IMFdataAbsSpec -> IMFtypeSpec [style=dashed];

     IMFdataSpec [label="IMF Data (2)\nStructural spec.", fillcolor=pink]
     IMFtypeSpec [label="IMF Type (3)\nStructural spec.", fillcolor=pink]

     IMFdataSpec -> data [arrowhead=none, constraint=false, color=gray];
     IMFdataSpec -> data_patterns [arrowhead=none, color=gray];
     IMFdataSpec -> p14_data [arrowhead=none, constraint=false, color=gray] ;

     IMFdataSpec -> IMFtypeSpec [constraint=false];

     IMFtypeSpec -> types [arrowhead=none, constraint=false, color=gray];
     IMFtypeSpec -> type_patterns [arrowhead=none, color=gray];
     IMFtypeSpec -> type_syntax [arrowhead=none, color=gray];
     IMFtypeSpec -> p14_types [arrowhead=none, constraint=false, color=gray];

    { rank="same"
    voc [label="IMF Vocabulary (9)\nOWL", fillcolor=darkseagreen2];
    grammar [label="IMF Grammar (10)\nSHACL", fillcolor=darkseagreen2];
    typegrammar [style="dashed,filled", label="IMF Type Grammar (10b)\nSHACL", fillcolor=darkseagreen];
    }

    { rank="same"
    data [label="IMF Data (7)\nExchange format\nRDF",fillcolor=darkslategray2];
    types [label="IMF Types (8)\nConstraints\nSHACL",fillcolor=darkslategray2];
    }

     types -> grammar [style="dashed", label="\"restricts\""];
     data -> voc [label = "uses"];
     grammar -> voc [label = "uses", constraint=false];
     typegrammar -> types [label = "validates", constraint=false];

     data -> grammar [dir="back", label = "validates"];
     data -> types [dir="back", constraint=false, label="validates"];


    { rank="same"
    data_patterns [label="IMF Data (4)\nTemplate\nOTTR", fillcolor=darkseagreen2];
    type_patterns [label="IMF Type (5)\nTemplate\nOTTR", fillcolor=darkseagreen2];
    type_syntax [style="filled,dashed", label="IMF Type (6)\nExchange format\n??", fillcolor=darkseagreen];
    }

    type_patterns -> data_patterns [style=dotted, arrowhead=none, constraint=false];

 
  subgraph cluster_p14 {

    p14 [label="ISO 15926-14 (14)\nOWL"]
    rdl [label="PCA RDL (13)\nOWL"]
    p14_types [label="IMF Types (12)\nSemantics\nOWL classes", fillcolor=darkslategray3];
    p14_data [label="IMF Data (11)\nSemantics\nOWL instances", fillcolor=darkslategray3];

   rdl -> p14;
  }


 ##### edges

 data_patterns -> data  [label="expands"];
 type_patterns -> types [label="expands"];

 type_patterns -> p14_types [label="expands", constraint=false];
 data_patterns -> p14_data  [label="expands", constraint=false];

 p14_data -> p14_types [label="inst. of"];
 p14_types -> rdl;
 #types -> rdl [style="dashed", constraint=false];
 p14_types -> IMFtypeSpec [constraint=false, label = "verifiy"];


}
#+END_SRC

#+RESULTS:
[[file:out/img/overview-specifications.png]]

** TODO W3C technology

[Explain and motivate the use of semantic technologies?]

*** RDF

RDF is an abstract data model defined as an open standard by the W3C.

RDF may be serialised in different serialisation formats such as
RDF/XML (based on XML), JSON-LD (based on JSON), Turtle (a favorite
amongst many familiar with RDF due to its ease of reading and
writing), or N-Triples (a very simple format only appropriate for
software).


* IMF Ontology
** Design                                                          :noexport:
*** Diagram legend

The specification consists of a series of partially overlapping
diagrams. The combined diagram is presented in Figure ...

The diagrams are UML class diagrams are drawn using [[https://plantuml.com/][PlantUML]]
restricted to the following elements:

 - Classes, marked with the icon "C". Classes may have "fields" that
   can hold values, fields are not used to represent relationships.
 - Abstract classes, marked with an icon "A", are classes that are not
   intended to be instantiated.
 - Enumerations, marked with the icon "E", are used to represent UML
   classes with a limited list of instantiations and where the
   instantiations are defined in the IMF language.
 - Stereotypes, marked with an icon "S" are used to represent a class
   structure that is not intended to be explictly represented in the
   language, but represents a tag and a convenient repetative
   structure. Classes that use stereotypes indicate this with ~<<
   stereotype >>~ above the class name.
 - Subclass relationships between classes, which are drawn using
   directed relations with an open arrow.
 - Directed associations (relations) between classes, which are marked
   with a name and possibly a cardinality. If no cardinality is given,
   then the cardinality is 0--many.
 - Composition relations, drawn with a filled diamond as arrow,
   indicates a strong dependency to the target of the relationship;
   the target is considered as a part of the source and cannot exist
   independently of the source of the relationship.
 - Composition relations, drawn with a open diamond as arrow,
   indicates a weak dependency to the target of the relationship than
   to that of a composition relation, the target is considered as part
   of the sourec but can exist independently of the source of the
   relationship.

 Here is an example:

#+NAME: overview-diagram-legend
#+BEGIN_SRC plantuml :noweb yes :file out/img/plantuml-legend.png
<<plantuml-style>>

abstract class AbstractConcept1

class Concept2 {
 field1
 field2
}

AbstractConcept1 <|-- Concept2
Concept2 <|-- SubConcept3

Concept2 -left-> Concept4 : 1..* hasRelationA

enum EnumeratedConcept5 {
 element1
 element2
}

Concept2 -right-> EnumeratedConcept5 : 1 hasRelationB

Concept4 --o SubConcept3

Concept4 --> Item

class Item << RDL >>
#+END_SRC

#+RESULTS: overview-diagram-legend
[[file:out/img/plantuml-legend.png]]

Note: The structural specification is described by a series of
diagrams, each focus on a specific part. In the case that a class is
used in multiple diagrams, only one diagram contains the full
specification of the class, while the other diagrams only contain the
class name. The diagram that contains the complete specification
combines all diagrams and contains all information.


** Ontology header

#+NAME: owl-imf-ontology
#+BEGIN_SRC ttl :noweb strip-export :tangle out/owl/imf-ontology.owl.wottr.ttl :mkdirp yes
<<prefixes>>

imf:IMFOntology a owl:Ontology ;
    owl:versionIRI <http://ns.imfid.org/20230630/imf-ontology.owl.ttl> ;
    owl:versionInfo "0.2.0" ;
    owl:priorVersion <https://ns.imfid.org/20221118/imf-vocabulary.owl.ttl> ;
    skos:prefLabel "Information Modelling Framework: Ontology" ;
    skos:altLabel "The IMF Ontology" ;
    vann:preferredNamespacePrefix "imf" ;
    vann:preferredNamespaceUri imf: ;
    pav:createdOn "2023-06-30T00:00:00"^^xsd:dateTime ;
    pav:createdBy _:mgs ;
    pav:contributedBy _:mgs, _:aw, _:ef ;
    foaf:depiction <imf-ontology.png> ;
    dc:description """
The IMF ontology is designed to meet the following functional requirements:

 - The users of the IMG language should be subject matter experts (SME). This means that the IMF language must be easy to learn and simple to use, hence it must contain a limited set of vocabulary terms and grammar rules.

 - The language shall provide incremental value, and hence must support modelling in an incremental manner.

 - The language shall be scalable across disciplines, work processes, and the value chain. This means that the IMF language must: 
    - Enable SMEs from a range of disciplines to fully express their design using the same modelling principles. 
    - Enable SMEs to express different levels of precision as part of iterations of their design. 
    - Enable use in different phases of a project (concept, detail engineering, manufacturing, etc.).

 - The language shall have the precision of machine interpretation to allow automated verification. This means that the IMF language must be precise and unambiguous, and allow translation into other ontology languages and be able to exploit semantic descriptions in external ontologies and reference data libraries.
    """ ;
    skos:changeNote 
      """0.2.0 :: Change summary:

 - Change: minor naming adjustments to some IRIs. 
 - Added metadata descriptions, including definitions and statuses.

Generated changelog that only checks the occurrence of IRIs in the IMF namespace between this and the previous version of the ontology:

<<py_iri_rdf_diff(v2="out/owl/imf-ontology.owl.ttl", v1="https://ns.imfid.org/20221118/imf-vocabulary.owl.ttl")>>

""" ;
    # cc:licence 
    # skos:scopeNote ## add description of ontology

    skos:scopeNote 
      """On statuses. All terms in the ontology are given a status using the `vs:term_status` property from the ['Term-centric Semantic Web Vocabulary Annotations' vocabulary](https://www.w3.org/2003/06/sw-vocab-status/note.html), and one of the values 'unstable', 'testing', 'stable' and 'archaic'. In this version of the ontology the highest status is 'testing'. Terms that are 'unstable' contain also this word in their label. 

External vocabularies used by this ontology:

 - [SKOS](https://www.w3.org/TR/skos-primer/)
 - [VANN](https://vocab.org/vann/)
 - [PAV](https://pav-ontology.github.io/pav/)

On naming conventions. 

 - Classes use UpperCamelCase;
 - Properties use lowerCamelCase, with additional rules:
    - object properties between IMF Classes usually start with a verb, e.g., 'has',
    - object properties for reified properties start with 'the',
    - object properties to external libraries, datatype properties, and annotation properties do not start with a verb;
 - Individuals use lowerCamelCase. 

On definitions. When referring to terms in the ontology, the following format is used: [prefLabel], where prefLabel is set by the property `skos:prefLabel`. 

On publishing. Versions of this ontology and other semantic web resources for IMF are published at an URL following this schema: `http://ns.imfid.org/[yyyy-mm-dd]/[resource-name]`.
""" ;

    sh:suggestedShapesGraph <http://ns.imfid.org/20230630/imf-model-grammar.shacl.ttl> ;
    sh:shapesGraph 
      <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl> ,
      <http://ns.imfid.org/20230630/imf-ontology-grammar.shacl.ttl> ,
      <http://ns.imfid.org/20230630/imf-terms-grammar.shacl.ttl> ;

    skos:editorialNote """Result of validation against specified sh:shapesGraph:
<<sh_jena_shacl_validate(shapes="http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl", data="out/owl/imf-ontology.owl.ttl")>>

<<sh_jena_shacl_validate(shapes="out/shacl/imf-terms-grammar.shacl.ttl", data="out/owl/imf-ontology.owl.ttl")>>

<<sh_jena_shacl_validate(shapes="out/shacl/imf-ontology-grammar.shacl.ttl", data="out/owl/imf-ontology.owl.ttl")>>
    """
    .

_:mgs foaf:name "Martin G. Skj√¶veland" .
_:aw  foaf:name "Arild Waaler" .
_:ef  foaf:name "Erlend Fj√∏sna" .

<<owl-imf-ontology-all-includes>>
#+END_SRC

*** _includes                                                      :noexport:
#+NAME: owl-imf-ontology-all-includes
#+BEGIN_SRC ttl :noweb yes

<<owl-model-model>>

<<owl-main-genericrelations>>

<<owl-elements-element>>

<<owl-elements-block>>

<<owl-elements-terminal>>

<<owl-elements-direction>>

<<owl-elements-inputoutputTerminal>>

<<owl-elements-annotations>>

<<owl-elements-relations-partof>>

<<owl-elements-relations-connectedTo>>

<<owl-elements-relations-classifier>>

<<owl-elements-relations-hasmedium>>

<<owl-elements-reifieds-breakdownpoint>>

<<owl-elements-reifieds-connectionpoint>>

<<owl-aspects-aspectelement>>

<<owl-aspects-aspect>>

<<py_aspect_ottr_instances_aspects()>>

<<owl-aspects-relations>>

<<owl-attributes-value>>

#<<owl-attributes-group>>

<<owl-attributes-qualifier>>

<<py_aspect_ottr_qualifiers()>>

#+END_SRC

** Model

#+NAME: overview-model-versioning
#+BEGIN_SRC plantuml :noweb yes :file out/owl/imf-ontology-model.png
<<plantuml-style>>

class Model
abstract class Element

Model o--> "*" Element
#+END_SRC

#+NAME: owl-model-model
#+BEGIN_SRC ttl
imf:Model a owl:Class ;
  skos:prefLabel "Model (unstable)" ;
  vs:term_status "unstable" ;
  skos:definition "A [Model] is a collection of [Element]s. " ;
  skos:scopeNote """A [Model] is a construct for organising [Element]s into an identified collection, which is useful for, e.g., provenance, exchange and integration. 

The set of [Element]s of a [Model] is expressed using the property [has Element]. A [Model] can contain any number of [Element]s. 

[Model] has the status 'unstable'; more detailed use cases and experience is required to work out its details.""" ;
  skos:editorialNote "TODOs: Can an [Element] belong to multiple [Model]s, if so, should it have one 'owner'?" ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "model" ;
  foaf:depiction <./imf-ontology-model.png> ;
. 

imf:hasElement a owl:ObjectProperty ;
  skos:prefLabel "has element (unstable)" ;
  vs:term_status "unstable" ;
  skos:definition "[has element] is a relation from a [Model] *M* to an [Element] *E* to specify that *M* contains *E*." ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "model" ;
  rdfs:domain imf:Model ;
  rdfs:range imf:Element .
#+END_SRC

#+NAME: shacl-model-model
#+BEGIN_SRC ttl
imf:ModelShape a sh:NodeShape ;
  sh:targetClass imf:Model ;
  sh:targetSubjectsOf imf:hasElement ;
  sh:property 
    [ sh:path imf:hasElement ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "The Model contains no Elements." ] .
#+END_SRC



** Structural relations

The following scope note is put on all following top-level relations:
#+NAME: owl-genericrelation-scope-note
#+BEGIN_SRC ttl
    skos:scopeNote "This is a generic property that is not intended to be used directly, rather use one of its subproperties. Generic properites like this are introduced to add structure to the properties of the ontology, and to be able to express generic class constraints." ;
#+END_SRC

#+NAME: owl-main-genericrelations
#+BEGIN_SRC ttl :noweb yes

imf:externalReference a owl:ObjectProperty ;
    skos:prefLabel "external reference" ;
    vs:term_status "testing" ;
    skos:definition "[external reference] is a generic relation that relates a resource *X* to a resource in an external ontology or reference data library for added semantic description of *X*." ;
<<owl-genericrelation-scope-note>>
    skos:changeNote 
      "0.2.0 :: Added" ;
    vann:termGroup "generic relations" ;
.

imf:hierarchicalRelation a owl:ObjectProperty ;
    skos:prefLabel "hierarchical relation";
    vs:term_status "testing" ;
    skos:definition "[hierarchical relation] is a generic relation that relates resources in a hierarchical or tree-shaped structure." ;
    rdfs:seeAlso <https://en.wikipedia.org/wiki/Tree_(data_structure)> ;
<<owl-genericrelation-scope-note>>
    skos:changeNote 
      "0.1.0 :: Added" ;
    vann:termGroup "generic relations" ;
    a owl:IrreflexiveProperty ;
    rdfs:subPropertyOf skos:semanticRelation ;
    .

imf:associativeRelation a owl:ObjectProperty ;
    skos:prefLabel "associative relation";
    vs:term_status "testing" ;
    skos:definition "[associative relation] is a generic relation that relates resources in an associative (or non-hierarchical) structure." ;
<<owl-genericrelation-scope-note>>
    skos:changeNote 
      "0.1.0 :: Added" ;
    vann:termGroup "generic relations" ;
    rdfs:subPropertyOf skos:related ;
    owl:propertyDisjointWith imf:hierachicalRelation ;
    .
#+END_SRC

** Elements

#+NAME: overview-instances
#+BEGIN_SRC plantuml :noweb yes :file out/owl/imf-ontology-elements.png
<<plantuml-style>>

abstract class Element {
  notation : 0..1 
  symbol : 0..1
}

class Block
class Terminal

class RDLItem << RDL >>
class Medium << RDL >>

enum TerminalQualifier {
 inputFlow
 outputFlow
}

Element "*" --> "*" RDLItem : classifier

' subclasses
Element <|-- Block
Element <|-- Terminal

' relations
Block "1" --> "*" Terminal : hasTerminal
Terminal "*" --> "0..1" Medium : medium
Terminal "*" --> "0..*" TerminalQualifier : hasTerminalQualifier

Element "1" <-- "*" Element : partOf
Terminal "1" --> "1" Terminal : connectedTo
#+END_SRC

#+ATTR_LATEX: :width 8cm
#+RESULTS: overview-instances
[[file:out/owl/imf-ontology-elements.png]]

*** ~Element~

#+NAME: owl-elements-element
#+BEGIN_SRC ttl
imf:Element a owl:Class ;
  skos:prefLabel "Element" ;
  vs:term_status "testing" ;
  skos:definition "An [Element] is a general object for modelling systems and system elements. An [Element] is described by its relations to other [Element]s and by its [Attribute]s (through the property [has attribute])." ;
  skos:scopeNote "[Element] is a very generic concept and direct instantiation of [Element] is probably a mistake. A better option is to use a subclass of [Element] that specifies, e.g., if the [Element] is either a [Block] or [Terminal], and its [Aspect], e.g., [FunctionBlock]." ;
  skos:note """An [Element] should be expressed with the following metadata:
 
 - a preferred label (using `skos:prefLabel`); 
 - optionally additional alternative labels (using `skos:altLabel`); 
 - a (textual) description (using `dc:description`); 
 - optionally a source of origin from which information about the element is taken (using `dc:source`); 
 - a version number (using `pav:version`); 
 - a created timestamp (using `pav:createdOn`); 
 - its creator, i.e., person (using `createdBy`); 
 - optionally contributors to its creation (using `pav:contributedBy`); 
 - optionally the time of latest update (using `pav:lastUpdateOn`).""" ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  foaf:depiction <./imf-ontology-elements.png> ;
. 
#+END_SRC

#+NAME: shacl-elements-annotations
#+BEGIN_SRC ttl
imf:ElementShape a sh:NodeShape ;
  sh:targetClass imf:Element , imf:Block , imf:Terminal ;
  sh:property 
    [ sh:path skos:prefLabel ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "Element has no prefLabel." ] ,
    [ sh:path dc:description ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "Element has no description." ] ,
    [ sh:path pav:version ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "Element has no version number." ] ,
    [ sh:path pav:createdOn ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "Element has created timestamp." ] ,
    [ sh:path pav:createdBy ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "Element has creator." ] ,

    [ sh:path imf:classifier ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "Element has no classifier." ] ,
    [ sh:path imf:partOf ; sh:maxCount 1 ; sh:message "Elements cannot be part of multiple Elements."  ] ,

    [ sh:path [ sh:inversePath imf:hasElement ] ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "Element is not contained in a Model." ]
.
#+END_SRC


*** Metadata properties

#+NAME: owl-elements-annotations
#+BEGIN_SRC ttl
skos:notation a owl:DatatypeProperty ;
  skos:scopeNote "From the SKOS reference: 'A notation is a string of characters such as \"T58.5\" or \"303.4833\" used to uniquely identify a concept within the scope of a given concept scheme.' Use skos:notation to set a RDS string."
  .

imf:symbol a owl:ObjectProperty ;
  skos:prefLabel "symbol" ;
  vs:term_status "testing" ;
  skos:definition "[symbol] is an [external reference] that associates a resource *X* with a typical graphical representation of *X*." ;
  skos:changeNote "0.2.0 :: Added" ;
  vann:termGroup "aspects" ;
  rdfs:subPropertyOf imf:externalReference ;
  .
#+END_SRC

*** ~partOf~ / ~hasPart~

#+NAME: owl-elements-relations-partof
#+BEGIN_SRC ttl
imf:partOf a owl:ObjectProperty;
  skos:prefLabel "part of" ;
  skos:altLabel "has parent" ;
  vs:term_status "testing" ;
  skos:definition "[part of] is a [hierarchical relation] and an [intra-aspect relation] that relates an [Element] *E1* and an [Element] *E2* to specify that *E1* is part of *E2*, or equivalently that *E2* has *E1* as a part. [part of] is used to specify a breakdown hierarchy of [Element]s." ;
  skos:scopeNote """[part of]/[has part] is used for describing an [Element] *E* by splitting *E* into parts *Es*, which again can be broken down into parts, to form a tree-shaped breakdown structure. 

Formally this is expressed by specifying [part of] as a functional and irreflexive property. This means that any [Element] may only be part of one other [Element], that is: an [Element] may not be part of multiple [Element]s and it may not be part of itself. 

[part of] is visualised with an arrow pointing from the child (the part) to the parent (the whole).""" ; 
  foaf:depiction <partOf.png> ;
  skos:changeNote 
    "0.1.0 :: Added" ,
    "0.2.0 :: Changed: IRI from imf:isPartOf to imf:partOf." ;
  vann:termGroup "elements" ;
  a owl:FunctionalProperty ;
  a owl:IrreflexiveProperty ;
  rdfs:subPropertyOf imf:intraAspectRelation, imf:hierarchicalRelation, skos:broader ;
  rdfs:domain imf:Element ;
  rdfs:range imf:Element ;
  .

imf:hasPart a owl:ObjectProperty ;
  skos:prefLabel "has part";
  skos:altLabel "has child";
  vs:term_status "testing" ;
  skos:definition "[has part] is a [hierarchical relation] and an [intra-aspect relation] that is the inverse relation of [part of]. See also [part of]." ;
  skos:scopeNote "Use [has part] when you want to specify the [Element]s that are part of an [Element] *E* \"on *E*\", rather than using the inverse property [part of] to state that the [part of] relationship to *E* for every [Element] that is part of *E*." ;
  skos:changeNote 
    "0.1.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subPropertyOf imf:intraAspectRelation, imf:hierarchicalRelation, skos:narrower ;
  owl:inverseOf imf:partOf ;
  .
#+END_SRC

*** ~classifier~

#+NAME: owl-elements-relations-classifier
#+BEGIN_SRC ttl
imf:classifier a owl:ObjectProperty ;
  skos:prefLabel "classifier" ;
  vs:term_status "testing" ;
  skos:definition "[classifier] is an [external reference] that relates an [Element] *E* to a resource *X* in an external ontology or reference data library such that *X* classifies *E* -- or equivalently, *E* is an instance of *X*." ;
  skos:example "[classifier] is used to relate a [Block] that is stated to perform a pumping function to the external resource PUMPING <https://data.posccaesar.org/rdl/RDS9657917>. We then say that the [Block] is classified by PUMPING, or that the [Block] is an instance of PUMPING." ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subPropertyOf imf:externalReference ;
  .
#+END_SRC

*** ~Block~

#+NAME: owl-elements-block
#+BEGIN_SRC ttl
imf:Block a owl:Class ;
  skos:prefLabel "Block" ;
  vs:term_status "testing" ;
  skos:definition "A [Block] represents an abstraction over a system or a system element as per ISO/IEC/IEEE 15288." ;
  skos:scopeNote """A [Block] is a basic building block of the IMF language. A [Block] can represent anything which is of interest and which is deemed convenient to treat as a system or system element. A [Block] sets the boundaries of what it abstracts over---at any granularity level. This could be a whole industry plant, a pump system, a measuring function, or a location of interest. 

A [Block] interfaces with other [Block]s via its [Terminal]s (expressed with the property [has terminal]). A [Block] can have any number of [Terminal]s. 

A [Block] is visualised as a rectangular box.""" ;
  foaf:depiction <block.png> ;
  skos:changeNote 
    "0.1.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subClassOf imf:Element ;
  .

[] ottr:of o-owl-ax:SubObjectAllValuesFrom ;
   ottr:values (imf:Block imf:partOf imf:Block) .
#+END_SRC

#+NAME: shacl-elements-block
#+BEGIN_SRC ttl
imf:BlockShape a sh:NodeShape ;
  sh:targetClass imf:Block ;
  sh:targetSubjectsOf imf:hasTerminal ;
  sh:property 
    [ sh:path imf:hasTerminal ; sh:class imf:Terminal ] ,
    [ sh:path imf:hasTerminal ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "The Block has no Terminals." ] ,     
    [ sh:path imf:partOf ; sh:class imf:Block ; sh:message "Blocks can only be part of Blocks." ] ,
    [ sh:path imf:hasPart ; sh:class imf:Block ; sh:message "Blocks can only have Blocks as parts." ]
.
#+END_SRC

*** ~Terminal~

#+NAME: owl-elements-terminal
#+BEGIN_SRC ttl
imf:Terminal a owl:Class ;
  skos:prefLabel "Terminal" ;
  skos:altLabel "Port", "Channel", "Input/Output" ;
  vs:term_status "testing" ;
  skos:definition """A [Terminal] is an [Element] that represents a point of interaction or communication for exactly one [Block] (through the relation [has terminal]), and hence specifies an input and/or output that the [Block] produces and/or receives. A [Terminal] may be qualified by [Terminal Qualifier]s.

A [Terminal] is visualised as a square with rounded corners containing a plus sign, attacted to its [Block]. An [Input Terminal] is placed to the left of its [Block], while an [Output Terminal] is placed to the right of its [Block].""" ;
  foaf:depiction <terminal.png> ;
  skos:changeNote 
    "0.1.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subClassOf imf:Element ;
  .

[] ottr:of o-owl-ax:SubObjectAllValuesFrom ;
   ottr:values (imf:Terminal imf:partOf imf:Terminal) .

imf:hasTerminal a owl:ObjectProperty ;
  skos:prefLabel "has terminal" ;
  vs:term_status "testing" ;
  skos:definition "[has terminal] is an [associative relation] and an [intra-aspect relation] that relates a [Block] *B* to a [Terminal] *T* to specify that *T* is a terminal of, or belongs to, *B*. [has terminal] is an inverse functional property which means that a [Terminal] may only belong to one [Block]." ;
  skos:changeNote 
    "0.1.0 :: Added" ;
  vann:termGroup "elements" ;
  a owl:InverseFunctionalProperty ;
  rdfs:subPropertyOf imf:intraAspectRelation , imf:associativeRelation ;
  rdfs:domain imf:Block ;
  rdfs:range imf:Terminal ;
  .

[] ottr:of o-owl-ax:SubObjectSomeValuesFrom ;
   ottr:values (imf:Terminal [ owl:inverseOf imf:hasTerminal ] imf:Block ) .
#+END_SRC

#+NAME: shacl-elements-terminal
#+BEGIN_SRC ttl
imf:TerminalShape a sh:NodeShape ;
  sh:targetClass imf:Terminal , imf:InputTerminal , imf:OutputTerminal ;
  sh:targetSubjectsOf imf:connectedTo , imf:medium , imf:hasTerminalQualifier ;
  sh:targetObjectsOf imf:hasTerminal, imf:connectedTo ;
  sh:property 
    [ sh:path imf:partOf ; sh:maxCount 1 ; sh:class imf:Terminal ] ,
    [ sh:path imf:connectedTo ; sh:maxCount 1 ; sh:class imf:Terminal ] ,
    [ sh:path imf:connectedTo ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "The Terminal has no connection (to a different Terminal)." ] , 
    [ sh:path imf:hasTerminalQualifier ; sh:maxCount 1 ; sh:in ( imf:inputFlow imf:outputFlow ) ] ,
    [ sh:path imf:medium ; sh:maxCount 1 ]  ,
    [ sh:path imf:medium ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "The Terminal has no medium." ]
.
#+END_SRC

*** ~medium~

#+NAME: owl-elements-relations-hasmedium
#+BEGIN_SRC ttl
imf:medium a owl:ObjectProperty  ;
  skos:prefLabel "medium" ;
  vs:term_status "testing" ;
  skos:definition "[medium] is an [external reference] that relates a [Terminal] *T* to a resource *X* to specify that *X* is the medium that flows through *T*." ;
  skos:example """[medium] is typically used to relate a [Terminal] to a resource that specifies one of the following:
 - Material (Fluid, Solids),
 - Energy (Mechanical, Electrical, Thermal),
 - Force (Mechanical),
 - Information(Electrical, Optical, Wireless)
""" ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subPropertyOf imf:externalReference ;
  rdfs:domain imf:Terminal ;
  .
#+END_SRC

*** ~connectedTo~

#+NAME: owl-elements-relations-connectedTo
#+BEGIN_SRC ttl
imf:connectedTo a owl:ObjectProperty ;
  skos:prefLabel "connected to" ;
  vs:term_status "testing" ;
  skos:definition "[connected to] is an [associative relation] and an [intra-aspect relation] that relates a [Terminal] *T1* to a [Terminal] *T2* to specify that *T1* is connected to *T2*. [connected to] specifies a topology of [Element]s by relating the [Terminal]s of [Block]s.";
  skos:scopeNote """[connected to] is used for describing how [Block]s are interconnected and indicates how they interact, i.e., how the [medium] of the connected [Terminal] flows between [Block]s. 

[connected to] is a 1-1 relationship: a [Terminal] may only be [connected to] one other [Terminal], that is, a [Terminal] may not be [connected to] multiple [Terminal]s and it may not be [connected to] itself. 

[connected to] is visualised with a line between the [Terminal]s.
""" ;
  foaf:depiction <connectedTo.png> ;
  skos:changeNote 
    "0.1.0 :: Added" ,
    "0.2.0 :: Changed IRI from imf:isConnectedTo to imf:connectedTo." ;
  skos:editorialNote "Should connectedTo be symmetric?" ;
  vann:termGroup "elements" ;
  a owl:FunctionalProperty ;
  a owl:InverseFunctionalProperty ;
  a owl:IrreflexiveProperty ; 
  rdfs:subPropertyOf imf:intraAspectRelation , imf:associativeRelation ;
  rdfs:domain imf:Terminal ;
  rdfs:range imf:Terminal ;
  .
#+END_SRC

*** TerminalQualifier

#+NAME: owl-elements-direction
#+BEGIN_SRC ttl
imf:TerminalQualifier a owl:Class ;
  skos:prefLabel "Terminal Qualifier" ;
  vs:term_status "testing" ;
  skos:definition "[Terminal Qualifier] is a feature or characteristic of a [Terminal]." ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  .

imf:inputFlow a owl:NamedIndividual, imf:TerminalQualifier ;
  skos:prefLabel "input flow" ;
  vs:term_status "testing" ;
  skos:definition "[input flow] is a [Terminal Qualifier] that indicates that the flow is incoming to the [Terminal] it qualifies." ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
.

imf:outputFlow a owl:NamedIndividual, imf:TerminalQualifier ;
  skos:prefLabel "output flow" ;
  vs:term_status "testing" ;
  skos:definition "[output flow] is a [Terminal Qualifier] that indicates that the flow is outgoing from the [Terminal] it qualifies." ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  .

[] ottr:of o-owl-ax:DifferentIndividuals ;
   ottr:values ( ( imf:inputFlow imf:outputFlow ) ) .

imf:hasTerminalQualifier a owl:ObjectProperty ;
  skos:prefLabel "has terminal qualifier" ;
  vs:term_status "testing" ;
  skos:definition "[has terminal qualifier] relates a [Terminal] *T* to a [Terminal Qualifier] *Q* to specify that *T* has the qualifier *Q*." ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:domain imf:Terminal ;
  rdfs:range imf:TerminalQualifier .
#+END_SRC

*** ~Input/OutputTerminal~

#+NAME: owl-elements-inputoutputTerminal
#+BEGIN_SRC ttl
imf:InputTerminal a owl:Class ;
  skos:prefLabel "Input Terminal" ;
  skos:altLabel "Input" ;
  vs:term_status "testing" ;
  skos:definition "An [Input Terminal] is a [Terminal] that accepts input (and not output)." ;
  skos:scopeNote "An [Input Terminal] is equivalent to a [Terminal] that has the [Terminal Qualifier] [input flow].";
  skos:changeNote 
    "0.1.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subClassOf imf:Terminal ;
  .

[] ottr:of o-owl-ax:EquivHasValue ;
   ottr:values ( imf:InputTerminal imf:hasTerminalQualifier imf:inputFlow ) .

imf:OutputTerminal a owl:Class ;
  skos:prefLabel "Output Terminal" ;
  skos:altLabel "Output" ;
  vs:term_status "testing" ;
  skos:definition "An [Output Terminal] is a [Terminal] that accepts output (and not input)." ;
  skos:scopeNote "An [Output Terminal] is equivalent to a [Terminal] that has the [Terminal Qualifier] [output flow].";
  skos:changeNote 
    "0.1.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subClassOf imf:Terminal ;
  .

[] ottr:of o-owl-ax:EquivHasValue ;
   ottr:values ( imf:OutputTerminal imf:hasTerminalQualifier imf:outputFlow ) .

imf:hasInputTerminal a owl:ObjectProperty ;
  skos:prefLabel "has input terminal" ;
  vs:term_status "testing" ;
  skos:definition "[has input terminal] specialises the [has terminal] property to relate [Block]s to [InputTerminal]s." ;
  skos:changeNote 
    "0.1.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subPropertyOf imf:hasTerminal ;
  rdfs:range imf:InputTerminal ;
  .

imf:hasOutputTerminal a owl:ObjectProperty ;
  skos:prefLabel "has output terminal" ;
  vs:term_status "testing" ;
  skos:definition "[has output terminal] specialises the [has terminal] property to relate [Block]s to [Output Terminal]s." ;
  skos:changeNote 
    "0.1.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subPropertyOf imf:hasTerminal ;
  rdfs:range imf:OutputTerminal ;
  .
#+END_SRC

*** Association Points
**** Overview

#+NAME: overview-instances-w-reified
#+BEGIN_SRC plantuml :noweb yes :file out/img/imf-ontology-elements-w-reified.png
<<overview-instances>>

' reified relations
class BreakdownPoint
(Element, Element) .. BreakdownPoint
Element "1" <-- "1" BreakdownPoint : thePart
Element "1" <-- "1" BreakdownPoint : theWhole

class ConnectionPoint
(Terminal, Terminal) .. ConnectionPoint
Terminal "1" <-- "1" ConnectionPoint : theInput
Terminal "1" <-- "1" ConnectionPoint : theOutput
#+END_SRC

#+RESULTS: overview-instances-w-reified
[[file:out/img/imf-ontology-elements-w-reified.png]]

**** ~BreakdownPoint~

#+NAME: owl-elements-reifieds-breakdownpoint
#+BEGIN_SRC ttl

imf:BreakdownPoint a owl:Class ;
  skos:prefLabel "Breakdown Point (unstable)" ;
  vs:term_status "unstable" ;
  skos:scopeNote "A [Breakdown Point] represents a reified [has part]/[part of] property instance, using the properties [the whole] and [the part] to relate to the [Element]s that are related by the [has part]/[part of] property. [Breakdown Point] has the status 'unstable'; its details are yet to be worked out." ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subClassOf imf:Element ;
  .

imf:thePart a owl:ObjectProperty ;
  skos:prefLabel "the part (unstable)" ;
  vs:term_status "unstable" ;
  skos:scopeNote "See [Breakdown Point]." ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  a owl:FunctionalProperty ;
  rdfs:subPropertyOf imf:intraAspectRelation, imf:associativeRelation ;
  skos:editorialNote "Is [thePart] and [theWhole] associative, hierachical or none?" ; 
  rdfs:domain imf:BreakdownPoint ;
  rdfs:range imf:Element .

imf:theWhole a owl:ObjectProperty ;
  skos:prefLabel "the whole (unstable)" ;
  vs:term_status "unstable" ;
  skos:scopeNote "See [Breakdown Point]." ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  a owl:FunctionalProperty ;
  rdfs:subPropertyOf imf:intraAspectRelation, imf:associativeRelation ;
  rdfs:domain imf:BreakdownPoint ;
  rdfs:range imf:Element .

[] ottr:of o-owl-ax:SubObjectSomeValuesFrom ;
   ottr:values ( imf:BreakdownPoint imf:thePart imf:Element ) .
[] ottr:of o-owl-ax:SubObjectSomeValuesFrom ;
   ottr:values ( imf:BreakdownPoint imf:theWhole imf:Element ) .

### Problem: gives non-simple property
#imf:partOf a owl:ObjectProperty ;
#  owl:propertyChainAxiom ( [ owl:inverseOf imf:thePart ] imf:theWhole ) .
#+END_SRC

#+NAME: shacl-elements-breakdownpoint
#+BEGIN_SRC ttl
imf:BreakdownPointShape a sh:NodeShape ;
  sh:targetClass imf:BreakdownPoint ;
  sh:targetSubjectsOf imf:thePart , imf:theWhole ;
  sh:property 
    [ sh:path imf:thePart  ; sh:minCount 1 ; sh:maxCount 1 ; sh:class imf:Element ] ,
    [ sh:path imf:theWhole ; sh:minCount 1 ; sh:maxCount 1 ; sh:class imf:Element ] 
.
#+END_SRC

**** ~ConnectionPoint~

#+NAME: owl-elements-reifieds-connectionpoint
#+BEGIN_SRC ttl

imf:ConnectionPoint a owl:Class ;
  skos:prefLabel "Connection Point (unstable)" ;
  vs:term_status "unstable" ;
  skos:scopeNote "A [Connection Point] represents a reified [connected to] property instance, using the property [the connected] or subpropertes [the input]/[the output] to relate to the [Terminal]s that are related by the [connected to] property. [Connection Point] has the status 'unstable'; its details are yet to be worked out." ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subClassOf imf:Element ;
  .

imf:theConnected a owl:ObjectProperty ;
  skos:prefLabel "the connected (unstable)" ;
  vs:term_status "unstable" ;
  skos:scopeNote "See [Connection Point]." ;
  rdfs:subPropertyOf imf:intraAspectRelation, imf:associativeRelation ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:domain imf:ConnectionPoint ;
  rdfs:range imf:Terminal . 

[] ottr:of o-owl-ax:SubObjectExactCardinality ;
   ottr:values( imf:ConnectionPoint "2"^^xsd:nonNegativeInteger imf:theConnected imf:Element ) .
[] ottr:of o-owl-ax:SubObjectMaxCardinality ;
   ottr:values( imf:ConnectionPoint "1"^^xsd:nonNegativeInteger imf:theInput imf:Element ) .
[] ottr:of o-owl-ax:SubObjectMaxCardinality ;
   ottr:values( imf:ConnectionPoint "1"^^xsd:nonNegativeInteger imf:theOutput imf:Element ) .

imf:theInput a owl:ObjectProperty ;
  skos:prefLabel "the input (unstable)" ;
  vs:term_status "unstable" ;
  skos:scopeNote "See [Connection Point]." ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subPropertyOf imf:theConnected ;
  rdfs:range imf:OutputTerminal . 

imf:theOutput a owl:ObjectProperty ;
  skos:prefLabel "the output (unstable)" ;
  vs:term_status "unstable" ;
  skos:scopeNote "See [Connection Point]." ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "elements" ;
  rdfs:subPropertyOf imf:theConnected ;
  rdfs:range imf:InputTerminal .

### Problem: gives non-simple property
#imf:connectedTo a owl:ObjectProperty ;
#  owl:propertyChainAxiom ( imf:theOutput [ owl:inverseOf imf:theInput ] ) .
#+END_SRC

#+NAME: shacl-elements-connectionpoint
#+BEGIN_SRC ttl
imf:ConnectionPointShape a sh:NodeShape ;
  sh:targetClass imf:ConnectionPoint ;
  sh:targetSubjectsOf imf:theConnected , imf:theInput , imf:theOutput ;
  sh:property 
    [ sh:path imf:theInput  ; sh:maxCount 1 ; sh:class imf:Element ] ,
    [ sh:path imf:theOutput ; sh:maxCount 1 ; sh:class imf:Element ] ,
    [ sh:path imf:theConnected ; sh:maxCount 2 ; sh:class imf:Element ] 
.
#+END_SRC

** Aspects

#+NAME: overview-aspect-element
#+BEGIN_SRC plantuml :noweb yes :file out/owl/imf-ontology-aspects.png
<<plantuml-style>>

abstract class AspectElement
abstract class Element

Element <|-- AspectElement

enum Aspect {
  Function
  Location
  Product
  Installed
}

AspectElement "*" --> "1" Aspect : hasAspect

Element --> Element : intraAspectRelation
Element --> Element : interAspectRelation
#+END_SRC

#+ATTR_LATEX: :width 6cm
#+RESULTS: overview-aspect-element
[[file:out/owl/imf-ontology-aspects.png]]

*** ~AspectElement~

#+NAME: owl-aspects-aspectelement
#+BEGIN_SRC ttl
imf:AspectElement a owl:Class ;
  skos:prefLabel "Aspect Element";
  skos:definition "An [Aspect Element] is an [Element] that has exactly one [Aspect]." ;
  skos:scopeNote """Avoid direct instantiation of [Aspect Element], use instead one of its subclasses.

The [Aspect] of an [Aspect Element] is visualised by filling the shape of the [Element] with the color of the [Aspect].
""" ;
  vs:term_status "testing" ;
  foaf:depiction <./imf-ontology-aspects.png> ;
  skos:changeNote 
    "0.1.0 :: Added" ;
  vann:termGroup "aspects" ;

  # an aspect element is an element with an aspect:
  owl:equivalentClass [
    rdf:type owl:Class ;
    owl:intersectionOf ( 
      imf:Element
      [ rdf:type owl:Restriction ;
        owl:onProperty imf:hasAspect ;
        owl:qualifiedCardinality "1"^^xsd:nonNegativeInteger ;
        owl:onClass imf:Aspect 
      ]
  ) ] 
  .

imf:hasAspect a owl:ObjectProperty ;
  skos:prefLabel "has aspect" ;
  vs:term_status "testing" ;
  skos:definition "[has aspect] is a relation from an [Element] *E* to an [Aspect] *A* that specfies that *E* has the [Aspect] *A*." ;
  skos:changeNote 
    "0.1.0 :: Added" ;
  vann:termGroup "aspects" ;
  rdfs:domain imf:Element ;
  rdfs:range imf:Aspect .
#+END_SRC

#+NAME: shacl-aspect-aspectelement
#+BEGIN_SRC ttl
imf:AspectElementShape a sh:NodeShape ;
  sh:targetClass imf:AspectElement ;
  sh:targetSubjectsOf imf:hasAspect ;
  sh:property 
    [ sh:path imf:hasAspect ; sh:minCount 1 ; sh:maxCount 1 ; sh:class imf:Aspect ] 
.
#+END_SRC

*** ~Aspect~

#+NAME: owl-aspects-aspect
#+BEGIN_SRC ttl
imf:Aspect a owl:Class ;
  skos:prefLabel "Aspect" ;
  vs:term_status "testing" ;
  skos:definition """An [Aspect] describes a context for interpreting [Element]s. An [Aspect] specifies a *perspective*, an *interest*, and a *modality*. 

 - *Perspective* refers to from which viewpoint the [Element] is interpreted.
 - *Interest* refers to the scope for which the information is intended used.
 - *Modality* refers to the form in which information is recorded.
""" ;
  skos:note "Aspect is a core concept of ISO/IEC 81346 and the IMF ontology includes aspects that are found in ISO/IEC 81346: function, location and product. We anticipate that more aspects will be added to support future modelling needs." ;
  skos:example "For examples, see the instances of [Aspect] defined in this ontology, e.g., [function aspect]." ;
  skos:changeNote 
    "0.1.0 :: Added" ;
  vann:termGroup "aspects" ;
  .

imf:prefix a owl:AnnotationProperty ;
  skos:prefLabel "prefix" ;
  vs:term_status "testing" ;
  skos:definition "[prefix] is a relation from an [Aspect] *A* to a string *s* to specify that *s* is the prefix associated with *A*. Such prefix strings are typically used for identifying the aspect when constructing reference designation system (RDS) identifiers." ;
  skos:example "For examples, see the instances of [Aspect] defined in this ontology, e.g., [function aspect]." ;
  skos:changeNote 
    "0.1.0 :: Added" ;
  vann:termGroup "aspects" ;
  rdfs:domain imf:Aspect ;
  rdfs:range xsd:string ;
  .

imf:color a owl:AnnotationProperty ;
  skos:prefLabel "color" ;
  vs:term_status "testing" ;
  skos:definition "[color] is a relation from a resource *X* to a string identifying a hexadecimal color *c* to specify that the *c* is a color that is associated with *A*.";
  skos:scopeNote "[Aspect]s are often associated with a distinct color, which is used in graphical presentations of IMF models." ;
  skos:example "For examples, see the instances of [Aspect] defined in this ontology, e.g., [function aspect]." ;
  skos:changeNote 
    "0.1.0 :: Added" ;
  vann:termGroup "aspects" ;
  rdfs:range xsd:string
  .

#+END_SRC

#+NAME: owl-aspects-relations
#+BEGIN_SRC ttl
imf:intraAspectRelation a owl:ObjectProperty ;
  skos:prefLabel "intra-aspect relation" ;
  skos:definition "[intra-aspect relation] a generic relation between [Element]s *E1* and *E2* such that *E1* and *E2* share at least one [Aspect]." ;
  skos:scopeNote "[intra-aspect relations] is not used directly, rather use one of its subproperties. An [intra-aspect relation] is used to relate [Element]s that represent different (but related) systems/system elements within the same [Aspect]." ;
  vs:term_status "testing" ;
  skos:changeNote 
    "0.1.0 :: Added" ;
  vann:termGroup "aspects" ;
  rdfs:domain imf:Element ;
  rdfs:range imf:Element ;
  .

#[] ottr:of o-owl-ax:SubObjectAllValuesFrom ;
#   ottr:values ( imf:AspectElement imf:intraAspectRelation imf:AspectElement ) .

imf:interAspectRelation a owl:ObjectProperty ;
  skos:prefLabel "inter-aspect relation" ;
  skos:definition "[inter-aspect relation] a generic relation between [Element]s *E1* and *E2* such that *E1* and *E2* do not share any [Aspect]s." ;
  skos:scopeNote "[inter-aspect relations] is not used directly, rather use one of its subproperties. An [inter-aspect relation] is used to relate [Element]s that represent the same system/system element, but in different [Aspect]s." ;
  vs:term_status "testing" ;
  skos:changeNote 
    "0.1.0 :: Added" ;
  vann:termGroup "aspects" ;
  rdfs:domain imf:Element ;
  rdfs:range imf:Element ;
  owl:propertyDisjointWith imf:intraAspectRelation ;
  .
#+END_SRC

*** Aspects

This is the current list of aspects:

#+NAME: tbl-aspects
| Aspect, IRIs        | Prefix, string | Color, string | Definition                                                                                                                                                                                                                                                 |
|---------------------+----------------+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| imf:functionAspect  | '='            | '#FFFF00'     | '[function aspect] is an [Aspect] about the intended activity of [Element]s, i.e., the activity an [Element] perfoms or is designed to bring about. [function aspect] has *perspective* \"Activity\", *interest* \"System design\", and *modality* \"Specification\".' |
| imf:locationAspect  | '+'            | '#FF00FF'     | '[location aspect] is an [Aspect] about the spatial envelope (e.g., geometry, size and shape) of [Element]s. [location aspect] has *perspective* \"Location\", *interest* \"Geometry and Position\", and *modality* \"Specification\".'           |
| imf:productAspect   | '-'            | '#00FFFF'     | '[product aspect] is an [Aspect] about the specification of a (physical) solution/implementation of [Element]s. [product aspect] has *perspective* \"Artefact\", *interest* \"Built\", and *modality* \"Specification\".'                          |
| imf:installedAspect | '::'           | '#0000FF'     | '[installed aspect] is an [Aspect] about the information of [element] instances. [installed aspect] has *perspective* \"Artefact\", *interest* \"Built\", and *modality* \"Description of individual\".'                                         |

**** Processing                                                          :QA:

#+BEGIN_SRC ttl :noweb strip-export :tangle out/ottr/imf/aspects.stottr :mkdirp yes
<<prefixes>>

## This creates an individual for each of the aspects in the table.
o-imf:Aspect [owl:NamedIndividual ?aspect, xsd:string ?label, xsd:string ?symbol, xsd:string ?color, xsd:string ?definition] :: {
  o-rdf:Type(?aspect, imf:Aspect) ,
  o-rdf:Type(?aspect, owl:NamedIndividual) ,
  ottr:Triple(?aspect, imf:prefix, ?symbol),
  ottr:Triple(?aspect, imf:color, ?color),
  ottr:Triple(?aspect, skos:prefLabel, ?label),
  ottr:Triple(?aspect, skos:definition, ?definition),
  ottr:Triple(?aspect, vs:term_status, "testing"),
  ottr:Triple(?aspect, skos:changeNote, "0.1.0 :: Added"),
  ottr:Triple(?aspect, skos:changeNote, "0.2.0 :: Changed: use lowerCamelCase for localname of IRI.")
  ottr:Triple(?aspect, vann:termGroup, "aspects")
} .

o-imf:AspectClass [owl:Class ?class, xsd:string ?label, owl:NamedIndividual ?aspect] :: {
  o-owl-ax:SubClassOf(?class, imf:AspectElement),  
  ottr:Triple(?class, skos:prefLabel, ?label),
  o-owl-ax:EquivObjectHasValue(?class, imf:hasAspect, ?aspect),
  o-owl-ax:SubObjectAllValuesFrom(?class, imf:intraAspectRelation, ?class),
  o-imf:GeneratedNote(?class)
} .

o-imf:AspectElementClass [owl:Class ?class, xsd:string ?label, owl:Class ?aspectClass, owl:Class ?elementClass] :: {
  o-owl-ax:EquivObjectIntersectionOf(?class, ( ?aspectClass, ?elementClass ) )
  ottr:Triple(?class, skos:prefLabel, ?label),
  o-owl-ax:SubClassOf(?class, ?aspectClass),
  o-owl-ax:SubClassOf(?class, ?elementClass),
  o-imf:GeneratedNote(?class)
} .

o-imf:InterAspectRelation [owl:ObjectProperty ?property, xsd:string ?label, owl:Class ?aspectClass] :: {
  o-rdf:Type(?property, owl:ObjectProperty),
  ottr:Triple(?property, skos:prefLabel, ?label),
  o-owl-ax:SubPropertyOf(?property, imf:interAspectRelation),  
  o-rdfs:Range(?property, ?aspectClass),
  o-imf:GeneratedNote(?property)
} .

o-imf:GeneratedNote [ottr:IRI ?resource] :: {
  ottr:Triple(?resource, skos:note, "This resource is programatically generated. Please consult its defining resources for a textual descriptions."),
  ottr:Triple(?resource, vs:term_status, "testing"),
  ottr:Triple(?resource, vann:termGroup, "aspects")
} .
#+END_SRC

#+NAME: py_aspect_ottr_instances_aspects
#+BEGIN_SRC python :results raw :wrap src ttl :var table=tbl-aspects :exports none
output = ""

instance = "[] ottr:of {} ;\n   ottr:values( {} ) . \n"

## aspects
for row in table[0:]:
  aspectName = row[0].replace("imf:", "", ).replace('Aspect', ' aspect')
  row.insert(1, "'" + aspectName + "'")
  output += instance.format("o-imf:Aspect", " ".join(f'{w}' for w in row))

output += "\n"

all_aspects = list(zip(*table[0:]))[0]
all_systemelements = [ 'Block', 'Terminal' ]

## aspects are different
output += instance.format("o-owl-ax:DifferentIndividuals", "( " + " ".join(all_aspects) + " )")

output += "\n"

## Create a class that represents all elements of a given aspect
for aspect in all_aspects:
  aspectName = aspect.replace("imf:", "", ).replace('Aspect', '').capitalize()
  output += instance.format("o-imf:AspectClass", "imf:" + aspectName + "Element '" + aspectName + " Element' " + aspect)

output += "\n"

## create a class of each aspect, element type combination, e.g., FunctionBlock.
for aspect in all_aspects:
  for element in all_systemelements:
    aspectName = aspect.replace("imf:", "", ).replace('Aspect', '').capitalize()
    output += instance.format("o-imf:AspectElementClass", "imf:" + aspectName + element + " '" + aspectName + " " + element + "' imf:" + aspectName  + "Element imf:" + element)

output += "\n"

## Create a object property for each aspect
for aspect in all_aspects:
  aspectName = aspect.replace("imf:", "", ).replace('Aspect', '').capitalize()
  output += instance.format("o-imf:InterAspectRelation", "imf:as" + aspectName + " 'as " + aspectName.lower() + "' imf:" + aspectName + "Element")

output += "\n"

return output
#+END_SRC

#+RESULTS: py_aspect_ottr_instances_aspects
#+BEGIN_src ttl
[] ottr:of o-imf:Aspect ;
   ottr:values( imf:functionAspect 'function aspect' '=' '#FFFF00' '[function aspect] is an [Aspect] about the intended activity of [Element]s, i.e., the activity an [Element] perfoms or is designed to bring about. [function aspect] has /perspective/ \"Activity\", /interest/ \"System design\", and /modality/ \"Specification\".' ) . 
[] ottr:of o-imf:Aspect ;
   ottr:values( imf:locationAspect 'location aspect' '+' '#FF00FF' '[location aspect] is an [Aspect] about the spatial envelope (e.g., geometry, size and shape) of [Element]s. [location aspect] has /perspective/ \"Location\", /interest/ \"Geometry and Position\", and /modality/ \"Specification\".' ) . 
[] ottr:of o-imf:Aspect ;
   ottr:values( imf:productAspect 'product aspect' '-' '#00FFFF' '[product aspect] is an [Aspect] about the specification of a (physical) solution/implementation of [Element]s. [product aspect] has /perspective/ \"Artefact\", /interest/ \"Built\", and /modality/ \"Specification\".' ) . 
[] ottr:of o-imf:Aspect ;
   ottr:values( imf:installedAspect 'installed aspect' '::' '#0000FF' '[installed aspect] is an [Aspect] about the information of [element] instances. [installed aspect] has /perspective/ \"Artefact\", /interest/ \"Built\", and /modality/ \"Description of individual\".' ) . 

[] ottr:of o-owl-ax:DifferentIndividuals ;
   ottr:values( ( imf:functionAspect imf:locationAspect imf:productAspect imf:installedAspect ) ) . 

[] ottr:of o-imf:AspectClass ;
   ottr:values( imf:FunctionElement 'Function Element' imf:functionAspect ) . 
[] ottr:of o-imf:AspectClass ;
   ottr:values( imf:LocationElement 'Location Element' imf:locationAspect ) . 
[] ottr:of o-imf:AspectClass ;
   ottr:values( imf:ProductElement 'Product Element' imf:productAspect ) . 
[] ottr:of o-imf:AspectClass ;
   ottr:values( imf:InstalledElement 'Installed Element' imf:installedAspect ) . 

[] ottr:of o-imf:AspectElementClass ;
   ottr:values( imf:FunctionBlock 'Function Block' imf:FunctionElement imf:Block ) . 
[] ottr:of o-imf:AspectElementClass ;
   ottr:values( imf:FunctionTerminal 'Function Terminal' imf:FunctionElement imf:Terminal ) . 
[] ottr:of o-imf:AspectElementClass ;
   ottr:values( imf:LocationBlock 'Location Block' imf:LocationElement imf:Block ) . 
[] ottr:of o-imf:AspectElementClass ;
   ottr:values( imf:LocationTerminal 'Location Terminal' imf:LocationElement imf:Terminal ) . 
[] ottr:of o-imf:AspectElementClass ;
   ottr:values( imf:ProductBlock 'Product Block' imf:ProductElement imf:Block ) . 
[] ottr:of o-imf:AspectElementClass ;
   ottr:values( imf:ProductTerminal 'Product Terminal' imf:ProductElement imf:Terminal ) . 
[] ottr:of o-imf:AspectElementClass ;
   ottr:values( imf:InstalledBlock 'Installed Block' imf:InstalledElement imf:Block ) . 
[] ottr:of o-imf:AspectElementClass ;
   ottr:values( imf:InstalledTerminal 'Installed Terminal' imf:InstalledElement imf:Terminal ) . 

[] ottr:of o-imf:InterAspectRelation ;
   ottr:values( imf:asFunction 'as function' imf:FunctionElement ) . 
[] ottr:of o-imf:InterAspectRelation ;
   ottr:values( imf:asLocation 'as location' imf:LocationElement ) . 
[] ottr:of o-imf:InterAspectRelation ;
   ottr:values( imf:asProduct 'as product' imf:ProductElement ) . 
[] ottr:of o-imf:InterAspectRelation ;
   ottr:values( imf:asInstalled 'as installed' imf:InstalledElement ) . 

#+END_src

*** Inter-aspect Relations

#+NAME: overview-aspect-element-interaspect
#+BEGIN_SRC plantuml :noweb yes :file out/img/overview-aspect-element-interaspect.png
<<plantuml-style>>

<<py_aspectelement_interaspect_rels()>>
#+END_SRC

#+RESULTS: overview-aspect-element-interaspect
[[file:out/img/overview-aspect-element-interaspect.png]]


*** ~AspectElement~ specialisations

#+NAME: overview-aspect-element-subs
#+BEGIN_SRC plantuml :noweb yes :file out/img/imf-overview-aspect-element-subs.png
<<plantuml-style>>

<<py_aspectelement_interaspect_rels()>>
<<py_aspectelement_subs()>>
#+END_SRC

#+RESULTS: overview-aspect-element-subs
[[file:out/img/imf-overview-aspect-element-subs.png]]

**** Processing                                                          :QA:

#+NAME: py_aspectelement_interaspect_rels
#+BEGIN_SRC python :var table=tbl-aspects :exports none
output = ""

for row in table:
  aspect = row[0].replace("imf:","").replace("Aspect", "").capitalize()
  color = row[2].replace("'","").replace("#","")

  ae = aspect + "Element"

  output += "class " + ae + " #back:" + color + "\n"
  output += "AspectElement --> " + ae + " : as" + aspect + "\n"
  output += "AspectElement <|-- " + ae + " \n"

return output
#+END_SRC

#+RESULTS: py_aspectelement_interaspect_rels
#+begin_example
class FunctionElement #back:FFFF00
AspectElement --> FunctionElement : asFunction
AspectElement <|-- FunctionElement 
class LocationElement #back:FF00FF
AspectElement --> LocationElement : asLocation
AspectElement <|-- LocationElement 
class ProductElement #back:00FFFF
AspectElement --> ProductElement : asProduct
AspectElement <|-- ProductElement 
class InstalledElement #back:0000FF
AspectElement --> InstalledElement : asInstalled
AspectElement <|-- InstalledElement
#+end_example


#+NAME: py_aspectelement_subs
#+BEGIN_SRC python :var table=tbl-aspects :exports none
output = ""

for row in table:
  aspect = row[0].replace("imf:","").replace("Aspect", "").capitalize()
  color = row[2].replace("'","").replace("#","")

  for element in ['Block', 'Terminal']:
    ae = aspect + element

    output += "class " + ae + " #back:" + color + "\n"
    output += element + " <|-- " + ae + "\n" 
    output += aspect + "Element <|-- " + ae + "\n" 

output += "\n"
return output
#+END_SRC

#+RESULTS: py_aspectelement_subs
#+begin_example
class FunctionBlock #back:FFFF00
Block <|-- FunctionBlock
FunctionElement <|-- FunctionBlock
class FunctionTerminal #back:FFFF00
Terminal <|-- FunctionTerminal
FunctionElement <|-- FunctionTerminal
class LocationBlock #back:FF00FF
Block <|-- LocationBlock
LocationElement <|-- LocationBlock
class LocationTerminal #back:FF00FF
Terminal <|-- LocationTerminal
LocationElement <|-- LocationTerminal
class ProductBlock #back:00FFFF
Block <|-- ProductBlock
ProductElement <|-- ProductBlock
class ProductTerminal #back:00FFFF
Terminal <|-- ProductTerminal
ProductElement <|-- ProductTerminal
class InstalledBlock #back:0000FF
Block <|-- InstalledBlock
InstalledElement <|-- InstalledBlock
class InstalledTerminal #back:0000FF
Terminal <|-- InstalledTerminal
InstalledElement <|-- InstalledTerminal
#+end_example

** Attributes
*** Overview

#+NAME: overview-attribute
#+BEGIN_SRC plantuml :noweb yes :file out/owl/imf-ontology-attributes.png
<<plantuml-style>>

abstract class Element

Element *--> "*" Attribute : hasAttribute

'Element *--> "*" AttributeGroup : hasAttributeGroup

'AttributeGroup *--> "*" Attribute : hasAttribute

'
'class AttributeGroup {
' name : 0..1
' description : 0..1
'}


class Attribute {
 name : 0..1
 description : 0..1
 value : 1..*
}

class UoM << RDL >>
class RDLItem <<RDL >>

Attribute "*" --> "0..1" UoM : uom
Attribute "*" --> "1" RDLItem : predicate

Attribute "*" --> "0..1" Provenance : hasAttributeQualifier
Attribute "*" --> "0..1" Range : hasAttributeQualifier
Attribute "*" --> "0..1" Regularity : hasAttributeQualifier
Attribute "*" --> "0..1" Scope : hasAttributeQualifier

''' Qualifiers

class AttributeQualifier

AttributeQualifier <|-- Provenance
AttributeQualifier <|-- Range
AttributeQualifier <|-- Regularity
AttributeQualifier <|-- Scope

enum Provenance {
  calculated
  measured
  specified
}
enum Range {
  average
  maximum
  minimum
  nominal
  normal
}
enum Regularity {
  absolute
  continuous
}
enum Scope {
  design
  operating
}
#+END_SRC

#+ATTR_LATEX: :width 12cm
#+RESULTS: overview-attribute
[[file:out/owl/imf-overview-attribute.png]]

*** ~Attribute~

#+NAME: owl-attributes-value
#+BEGIN_SRC ttl
imf:Attribute a owl:Class ;
  skos:prefLabel "Attribute" ;
  vs:term_status "testing" ;
  skos:definition "An [Attribute] describes a quality, property or characteristic of a resource by setting a [predicate], a [value], and optionally a [unit of measure]. An [Attribute] may be qualified by [Attribute Qualifier]s." ;
  skos:example "Specified color: red." , "Measured weight: 1250 kg." , "Maximum ambient operating temperature: 120 K." ;
  foaf:depiction <./imf-ontology-attributes.png> ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "attributes" ;
  .

imf:hasAttribute a owl:ObjectProperty ;
  skos:prefLabel "has attribute" ;
  vs:term_status "testing" ;
  skos:definition "[has attribute] is a relation between an [Element] *E* and an [Attribute] *A* that specifies that *E* has the attribute *A*." ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "attributes" ;
  rdfs:domain imf:Element ;
  rdfs:range  imf:Attribute .

imf:predicate a owl:ObjectProperty ;
  skos:prefLabel "predicate" ;
  vs:term_status "testing" ;
  skos:definition "[predicate] is an [external reference] that relates an [Attribute] *A* to a resource *X* to specify that *A* has the predicate *X*." ;
  skos:example "The [predicate] of an [Attribute] \"Weight: 1250 kg\" could be expressed as WEIGTH <http://data.posccaesar.org/rdl/RDS356894>." ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "attributes" ;
  rdfs:subPropertyOf imf:externalReference ;
  rdfs:domain imf:Attribute .

imf:uom a owl:ObjectProperty ;
  skos:prefLabel "unit of measure" ;
  skos:altLabel "uom" ;
  vs:term_status "testing" ;
  skos:definition "[unit of measure] is an [external reference] that relates an [Attribute] *A* to a resource *X* to specify that *A* has the unit of measure *X*." ;
  skos:example "The [unit of measure] of an [Attribute] \"Weight: 1250 kg\" could be expressed as KILOGRAM <http://data.posccaesar.org/rdl/RDS1328669>." ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "attributes" ;
  rdfs:subPropertyOf imf:externalReference ;
  rdfs:domain imf:Attribute .

imf:value a owl:DatatypeProperty ;
  skos:prefLabel "value" ;
  vs:term_status "testing" ;
  skos:definition "[value] relates an [Attribute] *A* to literal value *v* to specify that *A* has the value *v*." ;
  skos:example "The [value] of an [Attribute] \"Weight: 1250 kg\" could be expressed as the literal \"1250\"^^xsd:integer (or using a different appropriate literal datatype)." ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "attributes" ;
  rdfs:domain imf:Attribute 
.
#+END_SRC

#+NAME: shacl-attributes-value
#+BEGIN_SRC ttl
imf:AttributeShape a sh:NodeShape ;
  sh:targetClass imf:Attribute ;
  sh:targetObjectsOf imf:hasAttribute ;
  sh:targetSubjectsOf imf:predicate, imf:uom, imf:hasAttributeQualifier ;
  sh:property 
    [ sh:path imf:predicate ; sh:minCount 1 ; sh:maxCount 1 ] ,
    [ sh:path imf:value ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "Attribute has no value." ] ,
    [ sh:path imf:uom ; sh:maxCount 1 ] , 
    [ sh:path imf:hasAttributeQualifier ; sh:maxCount 1 ; sh:class imf:RegularityQualifier ] , 
    [ sh:path imf:hasAttributeQualifier ; sh:maxCount 1 ; sh:class imf:RangeQualifier ] , 
    [ sh:path imf:hasAttributeQualifier ; sh:maxCount 1 ; sh:class imf:ProvenenceQualifier ] , 
    [ sh:path imf:hasAttributeQualifier ; sh:maxCount 1 ; sh:class imf:ScopeQualifier ] ,
    [ sh:path imf:hasAttributeQualifier ; sh:minCount 1 ; sh:severity sh:Warning ; sh:message "Attribute has no qualifier." ] 
.
#+END_SRC

*** ~AttributeGroup~                                               :noexport:

#+NAME: owl-attributes-group
#+BEGIN_SRC ttl
imf:AttributeGroup a owl:Class ;
  skos:prefLabel "Attribute Group" ;
  vs:term_status "testing" ;
  skos:definition "An [Attribute Group] is a collection of [Attribute]s which are typically grouped for convenience as they describe closely related features or characteristics of a resource." ;
  skos:example "The physical dimensions of a product, e.g., its length, width and height, could be grouped by an [Attribute Group]." ;
  skos:editorialNote "Does an [Attribute Group] add any semantics? -- what is the difference from an [Attribute Group] and an [Element] with [Attribute]s?" ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  .

imf:hasAttributeGroup a owl:ObjectProperty ;
  skos:prefLabel "has attribute group" ;
  vs:term_status "testing" ;
  skos:definition "[has attribute group] is a relation between a resource *X* and an [Attribute Group] *A* that specifies that *X* has the attribute group *A*." ;
  skos:editorialNote "See comment on [Attribute Group], does [has attribute group] represent a \"long-hand property\" meaning that attaching the Attributes of the Attribute Group directly is equivalent? Perhaps the functionality of [Attribute Group]s is best realised as aspect-less-types?" ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  rdfs:range imf:AttributeGroup .
#+END_SRC

#+NAME: shacl-attributes-group
#+BEGIN_SRC ttl
imf:AttributeGroupShape a sh:NodeShape ;
  sh:targetClass imf:AttributeGroup ;
  sh:targetObjectsOf imf:hasAttributeGroup ;
  sh:property 
    [ sh:path imf:hasAttribute ; sh:minCount 1 ; sh:message "AttributeGroup has no Attributes." ]
.
#+END_SRC


*** ~AttributeQualifier~

#+NAME: owl-attributes-qualifier
#+BEGIN_SRC ttl
imf:AttributeQualifier a owl:Class ;
  skos:prefLabel "Attribute Qualifier" ;
  vs:term_status "testing" ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "attributes" ;
  .

imf:hasAttributeQualifier a owl:ObjectProperty ;
  skos:prefLabel "has attribute qualifier" ;
  vs:term_status "testing" ;
  skos:definition "[has attribute qualifier] is a relation between an [Attribute] *A* and an [Attribute Qualifier] *Q* to specify that *A* is qualified by *Q*." ;
  skos:changeNote 
    "0.2.0 :: Added" ;
  vann:termGroup "attributes" ;
  rdfs:domain imf:Attribute ;
  rdfs:range  imf:AttributeQualifier .
#+END_SRC

*** Attribute Qualifiers

#+NAME: tbl-qualifiers
| Qualifier               | Instance                |
|-------------------------+-------------------------|
| imf:ProvenanceQualifier | imf:calculatedQualifier |
| imf:ProvenanceQualifier | imf:measuredQualifier   |
| imf:ProvenanceQualifier | imf:specifiedQualifier  |
| imf:RangeQualifier      | imf:averageQualifier    |
| imf:RangeQualifier      | imf:maximumQualifier    |
| imf:RangeQualifier      | imf:minimumQualifier    |
| imf:RangeQualifier      | imf:nominalQualifier    |
| imf:RangeQualifier      | imf:normalQualifier     |
| imf:RegularityQualifier | imf:absoluteQualifier   |
| imf:RegularityQualifier | imf:continuousQualifier |
| imf:ScopeQualifier      | imf:designQualifier     |
| imf:ScopeQualifier      | imf:operatingQualifier  |

**** Processing                                                          :QA:

#+BEGIN_SRC ttl :noweb strip-export :tangle out/ottr/imf/attributes.stottr :mkdirp yes
<<prefixes>>

o-imf:AttributeQualifier [owl:Class ?qualifierClass, NEList<owl:NamedIndividual> ?qualifierInstances] :: {
  o-rdf:Type(?qualifierClass, owl:Class) ,
  o-owl-ax:SubClassOf(?qualifierClass, imf:AttributeQualifier) ,
  o-owl-ax:SubObjectMaxCardinality(imf:Attribute, "1"^^xsd:nonNegativeInteger, imf:hasAttributeQualifier, ?qualifierClass),
  cross | o-rdf:Type(++?qualifierInstances, ?qualifierClass),
  cross | o-rdf:Type(++?qualifierInstances, owl:NamedIndividual),
  o-owl-ax:EquivObjectOneOf(?qualifierClass, ?qualifierInstances),
  o-owl-ax:DifferentIndividuals(?qualifierInstances)
} .
#+END_SRC

#+NAME: py_aspect_ottr_qualifiers
#+BEGIN_SRC python :results raw :wrap src ttl :var table=tbl-qualifiers :exports none
output = ""
instance = "[] ottr:of {} ;\n   ottr:values( {} ) . \n"

qfc = '{} a owl:Class ;\n  skos:prefLabel "{}" ;\n  vs:term_status "testing" ;\n  #skos:definition "";\n  skos:changeNote\n     "0.2.0 :: Added" ;\n  vann:termGroup "attributes";\n.\n\n'
qf = '{} a owl:NamedIndividual ;\n  skos:prefLabel "{}" ;\n  vs:term_status "testing" ;\n  #skos:definition "";\n  skos:changeNote\n     "0.2.0 :: Added" ;\n  vann:termGroup "attributes";\n.\n\n'

qualifiers = list(set(list(zip(*table[0:]))[0]))
qualifiers.sort()

for qualifier in qualifiers:
  instances = []
  output += qfc.format(qualifier, qualifier.replace('imf:', '').replace('Qualifier', ' Qualifier'))
  for row in table[0:]:
    if row[0] == qualifier :
      instances.append(row[1])

  for i in instances :
      output += qf.format(i, i.replace('imf:', '').replace('Qualifier', ' qualifier'))

  output += instance.format("o-imf:AttributeQualifier", qualifier + " (" + " ".join(instances) + ")")
  output += "\n"

output += "\n"

##all_qualifier_instances = list(zip(*table[0:]))[1]
output += instance.format("o-owl-ax:DisjointClasses", "( " + " ".join(qualifiers) + " )")

return output
#+END_SRC

** Compile and verify
*** RDF validate tangled file

#+CALL: sh_jena_validate_rdf(files="out/owl/imf-ontology.owl.wottr.ttl")

#+RESULTS:
: file:///home/martige/repo/imf-lab/imf-ontology/out/owl/imf-ontology.owl.wottr.ttl : 0.22 sec : 317 Triples : 1,454.13 per second

#+CALL: sh_jena_shacl_std_validate(data="out/owl/imf-ontology.owl.wottr.ttl")

#+RESULTS:
#+BEGIN_src ttl
Conforms
#+END_src

*** Expand OTTR instances

#+CALL: lutra-expand(in="out/owl/imf-ontology.owl.wottr.ttl", out="out/owl/imf-ontology.owl.ttl")

*** RDF validate final file

#+CALL: sh_jena_validate_rdf(files="out/owl/imf-ontology.owl.ttl")

#+RESULTS:
: file:///home/martige/repo/imf-lab/imf-ontology/out/owl/imf-ontology.owl.ttl : 0.21 sec : 355 Triples : 1,674.53 per second

#+CALL: sh_jena_shacl_std_validate(data="out/owl/imf-ontology.owl.ttl")

#+RESULTS:
#+BEGIN_src ttl
Conforms
#+END_src

#+CALL: sh_jena_shacl_validate(shapes="out/shacl/imf-ontology-grammar.shacl.ttl", data="out/owl/imf-ontology.owl.ttl")

#+RESULTS:
#+BEGIN_src ttl
Node=<http://ns.imfid.org/imf#continuousQualifier>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#minimumQualifier>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#RegularityQualifier>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#BreakdownPoint>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#theInput>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#measuredQualifier>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#normalQualifier>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#operatingQualifier>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#ProvenanceQualifier>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#theConnected>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#calculatedQualifier>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#specifiedQualifier>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#absoluteQualifier>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#averageQualifier>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#ConnectionPoint>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#RangeQualifier>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#nominalQualifier>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#ScopeQualifier>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#theWhole>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#designQualifier>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#thePart>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#theOutput>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#AttributeQualifier>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
Node=<http://ns.imfid.org/imf#maximumQualifier>
  Path=<http://www.w3.org/2004/02/skos/core#definition>
  Message: minCount[1]: Invalid cardinality: expected min 1: Got count = 0
#+END_src

*** Diagram
#+CALL: rdfvizler(rules="out/rdfvizler/ontology-overview.rule", data="out/owl/imf-ontology.owl.wottr.ttl", output="out/owl/imf-overview.svg")

#+RESULTS:

[[./out/owl/imf-overview.svg]]


* SHACL Shape graphs
** IMF Terms

#+BEGIN_SRC ttl :noweb yes :tangle out/shacl/imf-terms-grammar.shacl.wottr.ttl :mkdirp yes
<<prefixes>>

imf:IMFTermsGrammar a owl:Ontology ;
    owl:versionIRI <http://ns.imfid.org/20230630/imf-terms-grammar.shacl.ttl> ;
    owl:versionInfo "0.2.0" ;
    skos:prefLabel "Information Modelling Framework: IMF Terms Grammar" ;
    dc:description "This shapes graph can be used to validate RDF data against correct use of IMF terms, IRIs only." ;
    pav:createdBy [ foaf:name "Martin G. Skj√¶veland" ] ;
    pav:createdOn "2023-06-30T00:00:00"^^xsd:dateTime ;
    sh:shapesGraph 
      <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl> ,
      <http://www.w3.org/ns/shacl-shacl#> ;
    skos:editorialNote """Result of validation against specified sh:shapesGraph:
<<sh_jena_shacl_validate(shapes="http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl", data="out/shacl/imf-terms-grammar.shacl.ttl")>>

<<sh_jena_shacl_validate(shapes="http://www.w3.org/ns/shacl-shacl#", data="out/shacl/imf-terms-grammar.shacl.ttl")>>
    """
.

<<shacl_imf-vocabulary-elements-check>>
#+END_SRC

*** IMF vocabulary elements

#+NAME: shacl_imf-vocabulary-elements-check
#+BEGIN_SRC ttl :noweb yes
[] a sh:NodeShape ;
    sh:message "Unrecognised IMF vocabulary element. Check spelling." ;
    sh:name "IMF vocabulary element." ;
    sh:sparql [ a sh:SPARQLConstraint ;
            sh:select """
	      PREFIX imf: <http://ns.imfid.org/imf#>
	      SELECT DISTINCT ?value 
	      WHERE { { ?value ?p ?o }
	        UNION { ?s ?value ?o }
	        UNION { ?s ?p ?value }
	      FILTER (isIRI(?value) 
	        && STRSTARTS(STR(?value), 'http://ns.imfid.org/imf#'))
	      FILTER (?value NOT IN (<<py_list_iris()>>)) }""" ] ;
    sh:targetNode <http://shipshape.dyreriket.xyz#ANY_NODE> .
#+END_SRC

** IMF Model Grammar

#+BEGIN_SRC ttl :noweb yes :tangle out/shacl/imf-model-grammar.shacl.wottr.ttl :mkdirp yes
<<prefixes>>

imf:IMFModelGrammar a owl:Ontology ;
    owl:versionIRI <http://ns.imfid.org/20230630/imf-model-grammar.shacl.ttl> ;
    owl:versionInfo "0.2.0" ;
    owl:priorVersion <https://ns.imfid.org/20221118/imf-grammar.shacl.ttl> ;
    skos:prefLabel "Information Modelling Framework: IMF Model Grammar" ;
    dc:description "This shapes graph can be used to validate IMF Model RDF data against the grammar for IMF Models." ;
    pav:createdBy [ foaf:name "Martin G. Skj√¶veland" ] ;
    pav:createdOn "2023-06-30T00:00:00"^^xsd:dateTime ;
    sh:shapesGraph 
      <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl> ,
      <http://www.w3.org/ns/shacl-shacl#> ,
      <http://ns.imfid.org/20230630/imf-terms-grammar.shacl.ttl> ;
    skos:editorialNote """Result of validation against specified sh:shapesGraph:
<<sh_jena_shacl_validate(shapes="http://www.w3.org/ns/shacl-shacl#", data="out/shacl/imf-ontology-grammar.shacl.ttl")>>

<<sh_jena_shacl_validate(shapes="http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl", data="out/shacl/imf-model-grammar.shacl.ttl")>>

<<sh_jena_shacl_validate(shapes="out/shacl/imf-terms-grammar.shacl.ttl", data="out/shacl/imf-ontology-grammar.shacl.ttl")>>
    """
.

<<shacl-model-model>>
<<shacl-elements-annotations>>
<<shacl-elements-block>>
<<shacl-elements-terminal>>
<<shacl-elements-breakdownpoint>>
<<shacl-elements-connectionpoint>>
<<shacl-aspect-aspectelement>>
<<shacl-attributes-value>>
#<<shacl-attributes-group>>
#+END_SRC



** IMF Ontology Grammar

#+BEGIN_SRC ttl :noweb yes :tangle out/shacl/imf-ontology-grammar.shacl.wottr.ttl :mkdirp yes
<<prefixes>>

imf:IMFOntologyGrammar a owl:Ontology ;
    owl:versionIRI <http://ns.imfid.org/20230630/imf-ontology-grammar.shacl.ttl> ;
    skos:prefLabel "Information Modelling Framework: IMF Ontology Grammar" ;
    dc:description "This shapes graph can be used to validate the IMF Ontology." ;
    pav:createdBy [ foaf:name "Martin G. Skj√¶veland" ] ;
    pav:createdOn "2023-06-30T00:00:00"^^xsd:dateTime ;
    sh:shapesGraph 
      <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl> ,
      <http://www.w3.org/ns/shacl-shacl#> ,
      <http://ns.imfid.org/20230630/imf-terms-grammar.shacl.ttl> ;
    skos:editorialNote """Result of validation against specified sh:shapesGraph:
<<sh_jena_shacl_validate(shapes="http://www.w3.org/ns/shacl-shacl#", data="out/shacl/imf-ontology-grammar.shacl.ttl")>>

<<sh_jena_shacl_validate(shapes="http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl", data="out/shacl/imf-ontology-grammar.shacl.ttl")>>

<<sh_jena_shacl_validate(shapes="out/shacl/imf-terms-grammar.shacl.ttl", data="out/shacl/imf-ontology-grammar.shacl.ttl")>>
    """
.


_:TermMetadata a sh:NodeShape ;
  sh:target [
    a sh:SPARQLTarget ;
    sh:select """
<<vocabulary-checks-select-query>>
      """ 
  ] ;
  sh:property 
    [ sh:path vs:term_status ; sh:minCount 1 ; sh:maxCount 1 ; sh:in ( "unstable" "testing" "stable" "archaic" ) ] ,
    [ sh:path vann:termGroup ; sh:minCount 1 ; sh:maxCount 1 ; sh:in ( "elements" "aspects" "attributes" "generic relations" "model" ) ] ,
    [ sh:path skos:prefLabel ; sh:minCount 1 ; sh:maxCount 1 ; sh:datatype xsd:string ] ,
    [ sh:path skos:definition ; sh:minCount 1 ; sh:maxCount 1 ; sh:datatype xsd:string  ] ,
    [ sh:path skos:changeNote ; sh:minCount 1 ; sh:pattern "^[0-9].[0-9].[0-9] :: [Added|Changed:]" ] ,
    [ sh:path skos:scopeNote ; sh:minCount 1 ; sh:severity sh:Warning ] 
.

#+END_SRC

*** SPARQL query

#+NAME: vocabulary-checks-select-query
#+BEGIN_SRC ttl
      PREFIX owl:   <http://www.w3.org/2002/07/owl#> 
      PREFIX skos:  <http://www.w3.org/2004/02/skos/core#>
      SELECT ?this { 
        ?this a ?type 
	FILTER (STRSTARTS(STR(?this), 'http://ns.imfid.org'))
        FILTER (isIRI(?this))
        #FILTER (?type IN ( owl:Class, owl:NamedIndividual, owl:ObjectProperty, owl:DatatypeProperty, owl:AnnotationProperty ))
        FILTER (?type != owl:Ontology)
        FILTER NOT EXISTS { 
	  ?this skos:note ?note .
	  FILTER (STRSTARTS(STR(?note), 'This resource is programatically generated.'))
	}
      }
      ## ORDER BY ?this
#+END_SRC


#+CALL: sh_jena_sparql(query=vocabulary-checks-select-query, "out/owl/imf-ontology.owl.ttl")

* Summary
** Overview

All diagrams combined.

#+BEGIN_SRC plantuml :noweb yes :file out/owl/imf-ontology.png
<<plantuml-style>>

'<<overview-model-versioning>>

<<overview-aspect-element>>

'<<overview-instances>>
<<overview-instances-w-reified>>

<<overview-attribute>>

#+END_SRC

#+RESULTS:
[[file:out/img/imf-ontology.png]]

** Vocabulary

Report of the vocabulary used by the IMF ontology.

*** IMF Vocabulary

#+NAME: sparql_all_imf_iris
#+BEGIN_SRC ttl
SELECT DISTINCT 
 ?iri ?label ?group ?type ?status ?definition ?scopeNotes ?examples ?notes ?eds ?image
{
  { ?iri ?x1 ?x2 }
  UNION
  { ?x3 ?iri ?x4 }
  UNION
  { ?x5 ?x5 ?iri }
  #FILTER(!isBlank(?iri))
  FILTER(STRSTARTS(STR(?iri), "http://ns.imfid.org"))

  ?iri a ?type 
  FILTER(?type IN (
      #owl:Ontology, 
      owl:Class, 
      owl:ObjectProperty,
      owl:DatatypeProperty,
      owl:AnnotationProperty,
      owl:NamedIndividual
      ))
  
  OPTIONAL {
    ?iri vann:termGroup ?group }
  OPTIONAL {
    ?iri skos:prefLabel ?label }
  OPTIONAL {
    ?iri vs:term_status ?status }
  OPTIONAL {
    ?iri skos:definition ?definition }
  OPTIONAL {
    ?iri foaf:depiction ?image }

  { SELECT ?iri 
      (GROUP_CONCAT(?x1; SEPARATOR=" ") AS ?scopeNotes) 
    { ?iri vann:termGroup ?l1 .
      OPTIONAL { ?iri skos:scopeNote ?x1 } }
    GROUP BY ?iri ?l1
  }

  { SELECT ?iri 
      (GROUP_CONCAT(?x2; SEPARATOR=" ") AS ?examples) 
    { ?iri vann:termGroup ?l2 .
      OPTIONAL { ?iri skos:example ?x2 } }
    GROUP BY ?iri ?l2
  }

  { SELECT ?iri 
      (GROUP_CONCAT(?x3; SEPARATOR=" ") AS ?eds) 
    { ?iri vann:termGroup ?l3 .
      OPTIONAL { ?iri skos:editorialNote ?x3 } }
    GROUP BY ?iri ?l3
  }

  { SELECT ?iri 
      (GROUP_CONCAT(?x4; SEPARATOR=" ") AS ?notes) 
    { ?iri vann:termGroup ?l4 .
      OPTIONAL { ?iri skos:note ?x4 } }
    GROUP BY ?iri ?l4
  }


}
ORDER BY DESC(?group) ?status ?type ?iri
#+END_SRC

#+CALL: py_run_sparql(query=sparql_all_imf_iris)
 
*** IRIs

#+NAME: sparql_all_iris
#+BEGIN_SRC ttl
SELECT DISTINCT ?iri ?type
{
  { ?iri ?x1 ?x2 }
  UNION
  { ?x3 ?iri ?x4 }
  UNION
  { ?x5 ?x5 ?iri }
  FILTER(!isBlank(?iri))

  OPTIONAL { 
    ?iri a ?type 
    FILTER(?type IN (
      owl:Ontology, 
      owl:Class, 
      owl:ObjectProperty,
      owl:DatatypeProperty,
      owl:AnnotationProperty,
      owl:NamedIndividual
      ))
  }
}
ORDER BY ?type ?iri
#+END_SRC

#+CALL: py_run_sparql(query=sparql_all_iris)

*** Classes

#+NAME: sparql_class
#+BEGIN_SRC ttl
SELECT ?class ?prefLabel ?superclasses
{
  ?class a owl:Class.
  FILTER (!isBlank(?class))

  OPTIONAL { ?class skos:prefLabel ?prefLabel }

  { SELECT ?class 
      (GROUP_CONCAT(?superclass; SEPARATOR=", ") AS ?superclasses) 
    {
      OPTIONAL { ?class rdfs:subClassOf ?superclass. FILTER (!isBlank(?superclass)) }
    } GROUP BY ?superclasses ?class
  }
}
ORDER BY ?superclasses ?class
#+END_SRC

#+CALL: py_run_sparql(query=sparql_class)

*** Properties

#+NAME: sparql_property
#+BEGIN_SRC ttl
SELECT ?type ?property ?prefLabel ?domain ?range ?characteristics ?superproperties
{
  ?property a ?type.
  FILTER (?type = owl:ObjectProperty || ?type = owl:DatatypeProperty || ?type = owl:AnnotationProperty )
  FILTER (!isBlank(?property))

  OPTIONAL { ?property skos:prefLabel ?prefLabel }
  OPTIONAL { ?property rdfs:domain ?domain }
  OPTIONAL { ?property rdfs:range ?range }

  { SELECT ?property 
      (GROUP_CONCAT(?superproperty; SEPARATOR=", ") AS ?superproperties) 
      (GROUP_CONCAT(?characteristic; SEPARATOR=", ") AS ?characteristics) 
    {
      OPTIONAL { ?property rdfs:subPropertyOf ?superproperty }
      OPTIONAL { ?property a ?characteristic .
          FILTER (?characteristic != owl:ObjectProperty && ?characteristic != owl:DatatypeProperty && ?characteristic != owl:AnnotationProperty )
      }
      OPTIONAL { ?property skos:altLabel ?altLabel }
    } GROUP BY ?property
  }
  
}
ORDER BY ?type ?property
#+END_SRC

#+CALL: py_run_sparql(query=sparql_property)



** Grammar
*** IMF Vocabulary

#+NAME: sparql_all_imf_pathShapes
#+BEGIN_SRC ttl
SELECT DISTINCT 
 ?shape ?path ?class ?minCount ?maxCount ?severity ?message
{
  ?shape sh:property ?p .
  ?p sh:path ?path .
  
  OPTIONAL {
    ?p sh:class ?class }
  OPTIONAL {
    ?p sh:minCount ?minCount }
  OPTIONAL {
    ?p sh:maxCount ?maxCount }
  OPTIONAL {
    ?p sh:severity ?severity }
  OPTIONAL {
    ?p sh:message ?message }

}
ORDER BY ?shape ?path ?class
#+END_SRC

#+CALL: py_run_sparql(query=sparql_all_imf_pathShapes, data="out/shacl/imf-model-grammar.shacl.ttl")

#+RESULTS:
| ~shape~                    | ~path~                                   | ~class~                   | ~minCount~ | ~maxCount~ | ~severity~   | ~message~                                                   |
|----------------------------+------------------------------------------+---------------------------+------------+------------+--------------+-------------------------------------------------------------|
| ~imf:AspectElementShape~   | ~imf:hasAspect~                          | ~imf:Aspect~              | ~1~        | ~1~        |              |                                                             |
| ~imf:AttributeShape~       | ~imf:hasAttributeQualifier~              |                           | ~1~        |            | ~sh:Warning~ | ~Attribute has no qualifier.~                               |
| ~imf:AttributeShape~       | ~imf:hasAttributeQualifier~              | ~imf:ProvenenceQualifier~ |            | ~1~        |              |                                                             |
| ~imf:AttributeShape~       | ~imf:hasAttributeQualifier~              | ~imf:RangeQualifier~      |            | ~1~        |              |                                                             |
| ~imf:AttributeShape~       | ~imf:hasAttributeQualifier~              | ~imf:RegularityQualifier~ |            | ~1~        |              |                                                             |
| ~imf:AttributeShape~       | ~imf:hasAttributeQualifier~              | ~imf:ScopeQualifier~      |            | ~1~        |              |                                                             |
| ~imf:AttributeShape~       | ~imf:property~                           |                           | ~1~        | ~1~        |              |                                                             |
| ~imf:AttributeShape~       | ~imf:uom~                                |                           |            | ~1~        |              |                                                             |
| ~imf:AttributeShape~       | ~imf:value~                              |                           | ~1~        |            | ~sh:Warning~ | ~Attribute has no value.~                                   |
| ~imf:BlockShape~           | ~imf:hasPart~                            | ~imf:Block~               |            |            |              | ~Blocks can only have Blocks as parts.~                     |
| ~imf:BlockShape~           | ~imf:hasTerminal~                        |                           | ~1~        |            | ~sh:Warning~ | ~The Block has no Terminals.~                               |
| ~imf:BlockShape~           | ~imf:hasTerminal~                        | ~imf:Terminal~            |            |            |              |                                                             |
| ~imf:BlockShape~           | ~imf:partOf~                             | ~imf:Block~               |            |            |              | ~Blocks can only be part of Blocks.~                        |
| ~imf:BreakdownPointShape~  | ~imf:thePart~                            | ~imf:Element~             | ~1~        | ~1~        |              |                                                             |
| ~imf:BreakdownPointShape~  | ~imf:theWhole~                           | ~imf:Element~             | ~1~        | ~1~        |              |                                                             |
| ~imf:ConnectionPointShape~ | ~imf:theConnected~                       | ~imf:Element~             |            | ~2~        |              |                                                             |
| ~imf:ConnectionPointShape~ | ~imf:theInput~                           | ~imf:Element~             |            | ~1~        |              |                                                             |
| ~imf:ConnectionPointShape~ | ~imf:theOutput~                          | ~imf:Element~             |            | ~1~        |              |                                                             |
| ~imf:ElementShape~         | ~_:nd1490807077b4065936195b45b7d583eb25~ |                           | ~1~        |            | ~sh:Warning~ | ~Element is not contained in a Model.~                      |
| ~imf:ElementShape~         | ~imf:classifier~                         |                           | ~1~        |            | ~sh:Warning~ | ~Element has no classifier.~                                |
| ~imf:ElementShape~         | ~imf:partOf~                             |                           |            | ~1~        |              | ~Elements cannot be part of multiple Elements.~             |
| ~imf:ElementShape~         | ~dc:description~                         |                           | ~1~        |            | ~sh:Warning~ | ~Element has no description.~                               |
| ~imf:ElementShape~         | ~pav:createdBy~                          |                           | ~1~        |            | ~sh:Warning~ | ~Element has creator.~                                      |
| ~imf:ElementShape~         | ~pav:createdOn~                          |                           | ~1~        |            | ~sh:Warning~ | ~Element has created timestamp.~                            |
| ~imf:ElementShape~         | ~pav:version~                            |                           | ~1~        |            | ~sh:Warning~ | ~Element has no version number.~                            |
| ~imf:ElementShape~         | ~skos:prefLabel~                         |                           | ~1~        |            | ~sh:Warning~ | ~Element has no prefLabel.~                                 |
| ~imf:ModelShape~           | ~skos:hasElement~                        |                           | ~1~        |            | ~sh:Warning~ | ~Model has contains no Elements.~                           |
| ~imf:TerminalShape~        | ~imf:connectedTo~                        |                           | ~1~        |            | ~sh:Warning~ | ~The Terminal has no connection (to a different Terminal).~ |
| ~imf:TerminalShape~        | ~imf:connectedTo~                        | ~imf:Terminal~            |            | ~1~        |              |                                                             |
| ~imf:TerminalShape~        | ~imf:hasTerminalQualifier~               |                           |            | ~1~        |              |                                                             |
| ~imf:TerminalShape~        | ~imf:medium~                             |                           | ~1~        |            | ~sh:Warning~ | ~The Terminal has no medium.~                               |
| ~imf:TerminalShape~        | ~imf:medium~                             |                           |            | ~1~        |              |                                                             |
| ~imf:TerminalShape~        | ~imf:partOf~                             | ~imf:Terminal~            |            | ~1~        |              |                                                             |
 

* Processing and QA                                                      :QA:
** RDF validate tangled file

#+CALL: sh_jena_validate_rdf(files="out/shacl/imf.shacl.wottr.ttl")

#+RESULTS:
: file:///home/martige/repo/imf-lab/imf-ontology/out/shacl/imf.shacl.wottr.ttl : 0.20 sec : 116 Triples : 574.26 per second

** Expand OTTR instances

#+CALL: lutra-expand(in="out/shacl/imf.shacl.wottr.ttl", out="out/shacl/imf.shacl.ttl")


** RDF validate final file

#+CALL: sh_jena_validate_rdf(files="out/shacl/imf.shacl.ttl")

#+RESULTS:
: file:///home/martige/repo/imf-lab/imf-ontology/out/shacl/imf.shacl.ttl : 0.21 sec : 114 Triples : 553.40 per second

#+CALL: sh_jena_shacl_std_validate(data="out/shacl/imf.shacl.ttl")

#+RESULTS:
#+BEGIN_src ttl
Result of validating RDF data <out/shacl/imf.shacl.ttl> against SHACL shape <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl>:

Conforms
#+END_src

** Diagram

#+CALL: rdfvizler(rules="out/rdfvizler/ontology-overview.rule", data="out/owl/imf-aspects.owl.ttl", output="out/owl/imf-aspects-overview.svg")

#+RESULTS:

[[./out/owl/imf-aspects-overview.svg]]

* TODO Types

Types are represented as patterns heavily inspired by the SHACL
constaint languge for RDF.

A type is represented by instantiating a small set of these
patterns. The pattern instances, i.e., a Type specification, may in
turn be translated to different formats:

 1. a set of SHACL shape constraints with with instance of the Type
    may be validated
 2. a prototypical RDF graph that represents a minimal starting point
    for instantiating the type
 3. an OWL class which classifies the instances of the type

OTTR templates are used to specify the patterns and their translation
to the different formats.

** Overview type patterns

The diagram displays the type patterns. 

Some terms are prefixed with ~sh.~ to indicate that they refer to
terms that are defined in the SHACL standard:
https://www.w3.org/TR/shacl. This also indicates how the type pattern
instances are translated into SHACL.

#+NAME: overview-types
#+BEGIN_SRC plantuml :noweb yes :file out/img/imf-types.png
<<plantuml-style>>

metaclass sh.Shape {
  id: 1 iri
  sh.name: 0..1 string
  sh.description: 0..1 string
}

metaclass sh.NodeShape {
  sh.targetClass: 0..1 iri
}

metaclass sh.PropertyShape {
  sh.path: 1 iri
}

metaclass Type {
  typeClass: 1 iri
}

metaclass SimpleValue {
  sh.hasValue: 1
}

metaclass SimpleValues {
  sh.in: 0..*
  sh.class: 0..1 iri
  sh.minCount: 0..1 integer
  sh.maxCount: 0..1 integer
}

metaclass TypeReference {
  sh.minCount: 0..1 integer
  sh.maxCount: 0..1 integer
}

metaclass ComplexValues {
  sh.datatype: 0..1 iri

  sh.minExclusive: 0..1
  sh.minInclusive: 0..1
  sh.maxExclusive: 0..1
  sh.maxInclusive: 0..1

  sh.minLenght: 0..1 integer
  sh.maxLength: 0..1 integer
  sh.pattern: 0..1 string
  sh.flags: 0..1 string
}

sh.Shape <|-- sh.NodeShape
sh.Shape <|-- sh.PropertyShape

sh.NodeShape <|-- Type

sh.PropertyShape <|-- SimpleValue
sh.PropertyShape <|-- SimpleValues
sh.PropertyShape <|-- TypeReference

SimpleValues <|-- ComplexValues

sh.NodeShape "1" -right-> sh.PropertyShape : sh.property
TypeReference --> "1" sh.NodeShape : node

#+END_SRC

#+RESULTS: overview-types
[[file:out/img/imf-types.png]]

*** Short description of the type patterns

 - Type :: specifies a collection Property shapes, i.e., a Type is a
           specification of relations to other types and
           properties. Used for specifying a BlockType, TerminalType,
            or AttributeType.
 - SimpleValue :: specifies a single value for a path. Used for
                  forcing one specific value.
 - SimpleValues :: specifies a range of simple values by listing
                   permissible values or giving a class, also possible
                   to set cardnality (min--max) number of values. Used
                   for specifying a range of values.
 - TypeReference :: specifies a reference to node shape with
              cardinality. Used for specifying, e.g., that a Block has
              3 Terminals of the same type.
 - ComplexValues :: specifies a value range with a complex set of
                    constraints. Used typically for specifying the
                    value for an Attribute.

** Suggested use of the type patterns

The diagram below displays a suggested use of the type patterns.

#+BEGIN_SRC plantuml :noweb yes :file out/img/imf-overview-type-patterns.png
<<plantuml-style>>

metaclass ElementType << Type >> {
  [metadata]
  aspect: SimpleValue
  notation: SimpleValue
  symbol: SimpleValue/s
}

metaclass BlockType << Type >>  {

}

metaclass TerminalType << Type >>  {
  direction: SimpleValue
  medium: SimpleValue/s
}

metaclass AttributeType << Type >>  {
  property : SimpleValue/s
  value : ComplexValues
  uom : SimpleValue/s
  qualifier : SimpleValues
}

ElementType <|-- BlockType
ElementType <|-- TerminalType

ElementType --> AttributeType : TypeReference
BlockType --> TerminalType : TypeReference
AttributeGroupType --> AttributeType : TypeReference

circle element

element -left-> ElementType : instanceOf

#+END_SRC

#+RESULTS:
[[file:out/img/imf-overview-type-patterns.png]]

** Pattern representation to SHACL with OTTR Templates 

#+BEGIN_SRC ttl :noweb yes :tangle out/ottr/imf-types-shacl.stottr :mkdirp yes
<<prefixes>>

o-imf:ShaclShape[
  ottr:IRI ?id, 
  ? xsd:string ?name, 
  ? xsd:string ?description
] :: {
  ottr:Triple(?id, sh:name, ?name),
  ottr:Triple(?id, sh:description, ?description)
} .


o-imf:ShaclNodeShape[
  ottr:IRI ?id, 
  ? owl:Class ?targetClass,
  #? xsd:string ?targetSPARQLSelect
  ? xsd:string ?name, 
  ? xsd:string ?description
] :: {
  o-imf:ShaclShape(?id, ?name, ?description),
  o-rdf:Type(?id, sh:NodeShape),
  ottr:Triple(?id, sh:targetClass, ?targetClass)

  #ottr:Triple(?id, sh:target, _:SHACLTarget),  
  #o-rdf:Type(_:SHACLTarget, sh:SHACLTarget),
  #ottr:Triple(_:SHACLTarget, sh:select, ?targetSPARQLSelect)
} .

o-imf:ShaclPropertyShape[
    ottr:IRI ?id,
    ottr:IRI ?nodeShape, 
    ottr:IRI ?path,
  ? xsd:string ?name, 
  ? xsd:string ?description
] :: {
  o-imf:ShaclShape(?id, ?name, ?description),
  ottr:Triple(?nodeShape, sh:property, ?id),
  ottr:Triple(?id, sh:path, ?path)
} .

#######

o-imf-t-s:Type[
  ottr:IRI ?id, 
  owl:Class ?typeClass,
  ? owl:Class ?targetClass,
  #? xsd:string ?targetSPARQLSelect
  ? xsd:string ?name, 
  ? xsd:string ?description
] :: {
  o-imf:ShaclNodeShape(?id, ?targetClass, ?name, ?description),
  o-rdf:Type(?id, ?typeClass)
} .

#######

o-imf-t-s:TypeReference[
    ottr:IRI ?id = _:P,
    ottr:IRI ?typeID, 
    ottr:IRI ?path, 
    ottr:IRI ?node,
    xsd:integer ?minCount = 1,
    xsd:integer ?maxCount = 1,
  ? xsd:string ?name, 
  ? xsd:string ?description
] :: {
  o-imf:ShaclPropertyShape(?id, ?typeID, ?path, ?name, ?description),
  ottr:Triple(?id, sh:node, ?node),
  ottr:Triple(?id, sh:minCount, ?minCount),
  ottr:Triple(?id, sh:maxCount, ?maxCount)
} .

o-imf-t-s:SimpleValue[
    ottr:IRI ?id = _:P,
    ottr:IRI ?typeID, 
    ottr:IRI ?path, 
    rdfs:Resource ?value,
  ? xsd:string ?name, 
  ? xsd:string ?description
] :: {
  o-imf:ShaclPropertyShape(?id, ?typeID, ?path, ?name, ?description),
  ottr:Triple(?id, sh:hasValue, ?value)
} .

o-imf-t-s:SimpleValues[
    ottr:IRI ?id = _:P,
    ottr:IRI ?typeID, 
    ottr:IRI ?path, 
  ? List<rdfs:Resource> ?in,
  ? owl:Class ?class,
    xsd:integer ?minCount, 
    xsd:integer ?maxCount,
  ? xsd:string ?name, 
  ? xsd:string ?description
] :: {
  o-imf:ShaclPropertyShape(?id, ?typeID, ?path, ?name, ?description),
  ottr:Triple(?id, sh:in, ?in),
  ottr:Triple(?id, sh:class, ?class),
  ottr:Triple(?id, sh:minCount, ?minCount),
  ottr:Triple(?id, sh:maxCount, ?maxCount)
} .


o-imf-t-s:ComplexValues[
    ottr:IRI ?id = _:P,
    ottr:IRI ?typeID, 
    ottr:IRI ?path, 
  #? xsd:string ?message,   ## add these to all patterns?
  #? ottr:IRI ?severity,
  #? rdfs:Resource ?value,
  ? List<rdfs:Resource> ?in,
  ? owl:Class ?class,
  ? ottr:IRI ?datatype,
    xsd:integer ?minCount = 1,
    xsd:integer ?maxCount = 1, 
  ? rdfs:Resource ?minInclusive,
  ? rdfs:Resource ?minExclusive,
  ? rdfs:Resource ?maxInclusive,
  ? rdfs:Resource ?maxExclusive,
  ? xsd:integer ?minLength,
  ? xsd:integer ?maxLength,
  ? xsd:string ?pattern,
  ? xsd:string ?flags,
  ? xsd:string ?name, 
  ? xsd:string ?description
] :: {
  #o-imf:ShaclPropertyShape(?typeID, ?id, ?path),
  #o-imf-t-s:SimpleValue(?id, ?typeID, ?path, ?value, ?name, ?description),
  o-imf-t-s:SimpleValues(?id, ?typeID, ?path, ?in, ?class, ?minCount, ?maxCount, ?name, ?description),
  #ottr:Triple(?id, sh:message, ?message),
  #ottr:Triple(?id, sh:severity, ?severity),
  ottr:Triple(?id, sh:datatype, ?datatype),
  ottr:Triple(?id, sh:minInclusive, ?minInclusive),
  ottr:Triple(?id, sh:minExclusive, ?minExclusive),
  ottr:Triple(?id, sh:maxInclusive, ?maxInclusive),
  ottr:Triple(?id, sh:maxExclusive, ?maxExclusive),
  ottr:Triple(?id, sh:minLength, ?minLength),
  ottr:Triple(?id, sh:maxLength, ?maxLength),
  ottr:Triple(?id, sh:pattern, ?pattern),
  ottr:Triple(?id, sh:flags, ?flags)
} .
#+END_SRC

** Translation to OWL ontology representation
*** OWL Classes

#+NAME: sparql_shaclClass
#+BEGIN_SRC ttl
SELECT 
  ?class 
  ?imfClass
  ?name
  ?description
  ?severity
  ?message
WHERE {
  OPTIONAL { ?n sh:targetClass ?class }
  OPTIONAL { ?n a ?imfTypeClass . 
             FILTER(STRSTARTS(STR(?imfTypeClass), "http://ns.imfid.org"))
             BIND(IRI(REPLACE(STR(?imfTypeClass), "Type", "")) AS ?imfClass)}
  OPTIONAL { ?n sh:name ?name }
  OPTIONAL { ?n sh:description ?description }
  OPTIONAL { ?n sh:severity ?severity }
  OPTIONAL { ?n sh:message ?message }
}
#+END_SRC

#+BEGIN_SRC ttl
o-imf-t-o:TypeClass[
  owl:Class ?id, 
  ? owl:Class ?imfClass,
  ? xsd:string ?name, 
  ? xsd:string ?description
  ? xsd:string ?severity, 
  ? xsd:string ?message
] :: {
  o-owl-dec:Class(?id, ?name, ?description, none, none),
  o-owl-ax:SubClassOf(?id, ?imfClass)
} .
#+END_SRC

*** OWL Class restrictions

SPARQL query

#+NAME: sparql_shaclClassRestriction 
#+BEGIN_SRC ttl
SELECT 
  ?class 
  ?path 
  ##?name
  ##?description
  ?minCount
  ?maxCount
  ?nodeTargetClass
  ?hasValue
  ?in
  ?datatype
  ?minExclusive
  ?minInclusive
  ?maxExclusive
  ?maxInclusive
  ?minLength
  ?maxLength
  ?pattern
  ?flags
WHERE {
  ?n sh:targetClass ?class .
  ?n sh:property ?p .
  ?p sh:path ?path .
  ##OPTIONAL { ?p sh:name ?name }
  ##OPTIONAL { ?p sh:description ?description }
  OPTIONAL { ?p sh:minCount ?minCount }
  OPTIONAL { ?p sh:maxCount ?maxCount }
  OPTIONAL { ?p sh:node [ sh:targetClass ?nodeTargetClass ] }
  OPTIONAL { ?p sh:class ?class }
  OPTIONAL { ?p sh:hasValue ?hasValue }
  OPTIONAL { ?p sh:in ?in }
  OPTIONAL { ?p sh:datatype ?datatype }
  OPTIONAL { ?p sh:minExclusive ?minExclusive }
  OPTIONAL { ?p sh:minInclusive ?minInclusive }
  OPTIONAL { ?p sh:maxExclusive ?maxExclusive }
  OPTIONAL { ?p sh:maxInclusive ?maxInclusive }
  OPTIONAL { ?p sh:minLength ?minLength }
  OPTIONAL { ?p sh:maxLength ?maxLength }
  OPTIONAL { ?p sh:pattern ?pattern }
  OPTIONAL { ?p sh:flags ?flags }
}
#+END_SRC


#+BEGIN_SRC ttl :noweb strip-export :XXXtangle out/ottr/imf-type-owl.stottr :mkdirp yes
<<prefixes>>

o-imf-t-o:TypeClassRestriction[
  owl:Class ?class, 
  ottr:IRI ?path,
  ? xsd:integer ?minCount,
  ? xsd:integer ?maxCount,
  ? ?hasValue
] :: {
  o-owl-ax:SubMaxCardinality(?class, ?maxCount, ?path),
  o-owl-ax:SubMinCardinality(?class, ?minCount, ?path),
  o-owl-ax:SubAllValuesFrom(?class, ?path, ?nodeTargetClass),
  o-owl-ax:SubHasValue(?class, ?path, ?hasValue)
} .


o-imf-t-o:TypeClassDataRestriction[
  owl:Class ?class, 
  ottr:IRI ?path,
  ? xsd:integer ?minCount,
  ? xsd:integer ?maxCount,
  # ? owl:Class ?nodeTargetClass,
  ? ?hasValue,
  ? List<rdfs:Resource> ?in,
  ? ottr:IRI ?datatype,
  ? ?minExclusive,
  ? ?minInclusive,
  ? ?maxExclusive,
  ? ?maxInclusive,
  ? xsd:integer ?minLength,
  ? xsd:integer ?maxLength,
  ? xsd:string ?pattern,
  ? xsd:string ?flags
] :: {
  o-imf-t-o:TypeClassRestriction(?class, ?path, ?minCount, ?maxCount, ?hasValue),
  #o-owl-ax:SubObjectOneOf(?class, ?path, ?in)
  zipMin | o-imf-t-o:SubDataAllValuesFromDatatypeFacet(?class, ?path, ?datatype, 
    ++(owl:minExclusive, owl:minInclusive, owl:maxExclusive, owl:maxInclusive, owl:minLength, owl:maxLength, owl:pattern),
    ++(?minExclusive, ?minInclusive, ?maxExclusive, ?maxInclusive, ?minLength, ?maxLength, ?pattern)
  )
} .

o-imf-t-o:TypeClassObjectRestriction[
  owl:Class ?class, 
  owl:ObjectProperty ?path,
  ? xsd:integer ?minCount,
  ? xsd:integer ?maxCount,
  ? owl:Class ?nodeTargetClass,
  ? ?hasValue,
  ? List<rdfs:Resource> ?in
] :: {
  o-imf-t-o:TypeClassRestriction(?class, ?path, ?minCount, ?maxCount, ?hasValue),
  o-owl-ax:SubObjectAllValuesFrom(?class, ?path, ?nodeTargetClass),
  o-owl-ax:SubObjectHasValue(?class, ?path, ?hasValue),
  o-owl-ax:SubObjectAllValuesFrom(?class, ?path, _:inClass),
  o-owl-ax:SubObjectOneOf(_:inClass, ?in)
} .


o-imf-t-o:SubDataAllValuesFromDatatypeFacet[
  ottr:Class ?class,
  ottr:DatatypeProperty ?prop,
  rdfs:Datatype ?datatype,
  ottr:IRI ?facet,
  ?value
] :: {
  o-owl-ax:SubDataAllValuesFrom(?class, ?prop, _:restriction),
  o-imf-t-o:DatatypeRestriction(_:restriction, ?datatype, ?facet, ?value)
} .

o-imf-t-o:DatatypeRestriction[
  ottr:IRI ?x,
  ottr:IRI ?datatype,
  ! ottr:IRI ?facet,
  ?value
] :: {
  o-rdf:Type(?x, rdfs:Datatype),
  ottr:Triple(?x, owl:onDatatype, ?datatype),
  ottr:Triple(?x, owl:withRestrictions, (_:facet)),
  ottr:Triple(_:facet, ?facet, ?value)
} .

#+END_SRC

https://stackoverflow.com/questions/36008786/proper-way-to-describe-string-literal-in-owl

* OLD types                                                        :noexport:
** Types

#+NAME: owl-types-type
#+BEGIN_SRC ttl
imf:Type a owl:Class ;
  skos:prefLabel "Type";
  .

imf:ElementType a owl:Class ;
  rdfs:subClassOf imf:Type ;
  skos:prefLabel "Element Type";
  .

imf:BlockType a owl:Class ;
  rdfs:subClassOf imf:ElementType ;
  skos:prefLabel "Block Type";
  .

imf:TerminalType a owl:Class ;
  rdfs:subClassOf imf:ElementType ;
  skos:prefLabel "Terminal Type";
  .

imf:AttributeType a owl:Class ;
  rdfs:subClassOf imf:Type ;
  skos:prefLabel "Attribute Type";
  .

imf:AttributeGroupType a owl:Class ;
  rdfs:subClassOf imf:Type ;
  skos:prefLabel "Attribute Group Type";
  .

imf:hasTerminalType a owl:ObjectProperty ;
  rdfs:domain imf:BlockType ;
  rdfs:range imf:TerminalType ;
  .
#+END_SRC

** Type constraint

#+NAME: owl-types-typeconstraint
#+BEGIN_SRC ttl
imf:TypeConstraint a owl:Class .

[] ottr:of o-owl-ax:SubDataMaxCardinality ;
   ottr:values ( imf:TypeConstraint "1"^^xsd:nonNegativeInteger imf:minCount xsd:integer ) .
[] ottr:of o-owl-ax:SubDataMaxCardinality ;
   ottr:values ( imf:TypeConstraint "1"^^xsd:nonNegativeInteger imf:maxCount xsd:integer ) .

#+END_SRC

** Relation constraints

#+NAME: owl-types-relationconstraints
#+BEGIN_SRC ttl
[] ottr:of o-owl-ax:SubObjectMaxCardinality ;
   ottr:values ( imf:ElementType "1"^^xsd:nonNegativeInteger imf:hasAspect imf:Aspect ) .
[] ottr:of o-owl-ax:SubDataMaxCardinality ;
   ottr:values ( imf:ElementType "1"^^xsd:nonNegativeInteger skos:notation rdfs:Literal ) .
[] ottr:of o-owl-ax:SubDataMaxCardinality ;
   ottr:values ( imf:ElementType "1"^^xsd:nonNegativeInteger imf:symbol rdfs:Literal ) .

[] ottr:of o-owl-ax:SubObjectMaxCardinality ;
   ottr:values ( imf:TerminalType "1"^^xsd:nonNegativeInteger imf:hasDirection imf:Direction ) .
[] ottr:of o-owl-ax:SubObjectMaxCardinality ;
   ottr:values ( imf:TerminalType "1"^^xsd:nonNegativeInteger imf:hasMedium owl:Thing ) .
#+END_SRC

** instanceOf

#+NAME: owl-types-instanceOf
#+BEGIN_SRC ttl

imf:instanceOf a owl:ObjectProperty ;
  skos:prefLabel "instance of" ;
  rdfs:range imf:Type .

[] ottr:of o-owl-ax:SubObjectAllValuesFrom ;
   ottr:values ( imf:Element imf:instanceOf imf:ElementType ) .

[] ottr:of o-owl-ax:SubObjectAllValuesFrom ;
   ottr:values ( imf:Block imf:instanceOf imf:BlockType ) .

[] ottr:of o-owl-ax:SubObjectAllValuesFrom ;
   ottr:values ( imf:Terminal imf:instanceOf imf:TerminalType ) .

[] ottr:of o-owl-ax:SubObjectAllValuesFrom ;
   ottr:values ( imf:Attribute imf:instanceOf imf:AttributeType ) .

[] ottr:of o-owl-ax:SubObjectAllValuesFrom ;
   ottr:values ( imf:AttributeGroup imf:instanceOf imf:AttributeGroupType ) .
#+END_SRC



** Processing and QA                                                     :QA:
*** RDF validate tangled file

#+CALL: sh_jena_validate_rdf(files="out/owl/imf-types.owl.wottr.ttl")

#+RESULTS:
: file:///home/martige/repo/imf-lab/imf-ontology/out/owl/imf-types.owl.wottr.ttl : 0.19 sec : 139 Triples : 747.31 per second

*** Expand OTTR instances

#+CALL: lutra-expand(in="out/owl/imf-types.owl.wottr.ttl", out="out/owl/imf-types.owl.ttl")

*** RDF validate final file

#+CALL: sh_jena_validate_rdf(files="out/owl/imf-types.owl.ttl")

#+RESULTS:
: file:///home/martige/repo/imf-lab/imf-ontology/out/owl/imf-types.owl.ttl : 0.20 sec : 96 Triples : 477.61 per second

#+CALL: sh_jena_shacl_std_validate(data="out/owl/imf-types.owl.ttl")

#+RESULTS:
#+BEGIN_src ttl
@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sh:   <http://www.w3.org/ns/shacl#> .
@prefix xsd:  <http://www.w3.org/2001/XMLSchema#> .

[ rdf:type     sh:ValidationReport ;
  sh:conforms  true
] .
#+END_src

*** Diagram

#+CALL: rdfvizler(rules="out/rdfvizler/ontology-overview.rule", data="out/owl/imf-types.owl.ttl", output="out/owl/imf-types-overview.svg")

#+RESULTS:

[[./out/owl/imf-types-overview.svg]]

** OWL Ontology

#+NAME: owl-types-ontology
#+BEGIN_SRC ttl :noweb strip-export :tangle out/owl/imf-types.owl.wottr.ttl :mkdirp yes
<<prefixes>>

<http://ns.imfid.org/imf-types> a owl:Ontology ;
    owl:versionIRI <http://ns.imfid.org/20230331/imf-types> ;
    ## owl:imports <http://ns.imfid.org/20230331/imf-top> ;
    skos:prefLabel "Information Modelling Framework Ontology: Types " ;
    skos:altLabel "IMF types ontology" ;
    skos:scopeNote """

    """;
    .

<<owl-types-type>>
<<owl-types-instanceOf>>
<<owl-types-typeconstraint>>
<<owl-types-relationconstraints>>

#+END_SRC

#+RESULTS: owl-types-ontology
#+begin_example
@prefix xsd:	<http://www.w3.org/2001/XMLSchema#> .
@prefix rdf:	<http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:	<http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl:    <http://www.w3.org/2002/07/owl#> .
@prefix skos:	<http://www.w3.org/2004/02/skos/core#> .
@prefix pav:	<http://purl.org/pav/> .
@prefix sh: 	<http://www.w3.org/ns/shacl#> . 
@prefix shsh:   <http://www.w3.org/ns/shacl-shacl#> .
@prefix ex:	<http://example.com#> .
@prefix imf:	<http://ns.imfid.org/imf#> .

@prefix p14:    <http://example.com/P14#> .
@prefix ottr:        <http://ns.ottr.xyz/0.4/> .
@prefix o-rdf:       <http://tpl.ottr.xyz/rdf/0.1/> .
@prefix o-rdfs:       <http://tpl.ottr.xyz/rdfs/0.2/> .
@prefix o-owl-ax:    <http://tpl.ottr.xyz/owl/axiom/0.1/> .
@prefix o-owl-ma:    <http://tpl.ottr.xyz/owl/macro/0.1/> .
@prefix o-owl-rstr:  <http://tpl.ottr.xyz/owl/restriction/0.1/> .
@prefix o-imf:	     <http://ns.imfid.org/templates/> .

<http://ns.imfid.org/imf-types> a owl:Ontology ;
    owl:versionIRI <http://ns.imfid.org/20230331/imf-types> ;
    ## owl:imports <http://ns.imfid.org/20230331/imf-top> ;
    skos:prefLabel "Information Modelling Framework Ontology: Types " ;
    skos:altLabel "IMF types ontology" ;
    skos:scopeNote """

    """;
    .

imf:Type a owl:Class ;
  skos:prefLabel "Type";
  .

imf:ElementType a owl:Class ;
  rdfs:subClassOf imf:Type ;
  skos:prefLabel "Element Type";
  .

imf:BlockType a owl:Class ;
  rdfs:subClassOf imf:ElementType ;
  skos:prefLabel "Block Type";
  .

imf:TerminalType a owl:Class ;
  rdfs:subClassOf imf:ElementType ;
  skos:prefLabel "Terminal Type";
  .

imf:AttributeType a owl:Class ;
  rdfs:subClassOf imf:Type ;
  skos:prefLabel "Attribute Type";
  .

imf:AttributeGroupType a owl:Class ;
  rdfs:subClassOf imf:Type ;
  skos:prefLabel "Attribute Group Type";
  .

imf:hasTerminalType a owl:ObjectProperty ;
  rdfs:domain imf:BlockType ;
  rdfs:range imf:TerminalType ;
  .

imf:instanceOf a owl:ObjectProperty ;
  skos:prefLabel "instance of" ;
  rdfs:range imf:Type .

[] ottr:of o-owl-ax:SubObjectAllValuesFrom ;
   ottr:values ( imf:Element imf:instanceOf imf:ElementType ) .

[] ottr:of o-owl-ax:SubObjectAllValuesFrom ;
   ottr:values ( imf:Block imf:instanceOf imf:BlockType ) .

[] ottr:of o-owl-ax:SubObjectAllValuesFrom ;
   ottr:values ( imf:Terminal imf:instanceOf imf:TerminalType ) .

[] ottr:of o-owl-ax:SubObjectAllValuesFrom ;
   ottr:values ( imf:Attribute imf:instanceOf imf:AttributeType ) .

[] ottr:of o-owl-ax:SubObjectAllValuesFrom ;
   ottr:values ( imf:AttributeGroup imf:instanceOf imf:AttributeGroupType ) .
imf:TypeConstraint a owl:Class .

[] ottr:of o-owl-ax:SubDataMaxCardinality ;
   ottr:values ( imf:TypeConstraint "1"^^xsd:nonNegativeInteger imf:minCount xsd:integer ) .
[] ottr:of o-owl-ax:SubDataMaxCardinality ;
   ottr:values ( imf:TypeConstraint "1"^^xsd:nonNegativeInteger imf:maxCount xsd:integer ) .

[] ottr:of o-owl-ax:SubObjectMaxCardinality ;
   ottr:values ( imf:ElementType "1"^^xsd:nonNegativeInteger imf:hasAspect imf:Aspect ) .
[] ottr:of o-owl-ax:SubDataMaxCardinality ;
   ottr:values ( imf:ElementType "1"^^xsd:nonNegativeInteger skos:notation rdfs:Literal ) .
[] ottr:of o-owl-ax:SubDataMaxCardinality ;
   ottr:values ( imf:ElementType "1"^^xsd:nonNegativeInteger imf:symbol rdfs:Literal ) .

[] ottr:of o-owl-ax:SubObjectMaxCardinality ;
   ottr:values ( imf:TerminalType "1"^^xsd:nonNegativeInteger imf:hasDirection imf:Direction ) .
[] ottr:of o-owl-ax:SubObjectMaxCardinality ;
   ottr:values ( imf:TerminalType "1"^^xsd:nonNegativeInteger imf:hasMedium owl:Thing ) .
#+end_example

* Example

[[./example/pumpingFunctionType.png]]

** Type

The types in the example is represented in the following Excel spreadsheet [[./example/pumpingFunctionType.xlsx]]

*** Type expansion: SHACL

#+BEGIN_SRC sh :exports none :results raw
java -jar bin/lutra.jar -f -L stottr -l out/ottr/shacl.stottr -I tabottr example/pumpingFunctionType.xlsx | rapper - -i turtle -o turtle -I 'http://example.com#' > example/pumpingFunctionType.xlsx.ttl
#+END_SRC

#+RESULTS:
rapper: Parsing file <stdin> with parser turtle and base URI http://example.com#
rapper: Serializing with serializer turtle and base URI http://example.com#
rapper: Parsing returned 167 triples

#+INCLUDE: "example/pumpingFunctionType.xlsx.ttl" src ttl

*** Type translation: OWL

#+CALL: py_run_sparql(query=sparql_shaclClass, data="example/pumpingFunctionType.xlsx.ttl")

#+RESULTS:
| ~class~         | ~imfClass~           | ~name~                             | ~description~ | ~severity~ | ~message~ |
|-----------------+----------------------+------------------------------------+---------------+------------+-----------|
| ~ex:sB-001~     | ~imf:Block~          | ~Pumping, liquid velocity~         |               |            |           |
| ~ex:sBAg-001~   | ~imf:AttributeGroup~ | ~Pumping purpose attributes~       |               |            |           |
| ~ex:sBAg-002~   | ~imf:AttributeGroup~ | ~Pumping supplementary attributes~ |               |            |           |
| ~ex:sBAttr-001~ | ~imf:Attribute~      | ~Fluid~                            |               |            |           |
| ~ex:sBAttr-002~ | ~imf:Attribute~      | ~Flowrate~                         |               |            |           |
| ~ex:sBAttr-003~ | ~imf:Attribute~      | ~Pressure delta~                   |               |            |           |
| ~ex:sBAttr-004~ | ~imf:Attribute~      | ~Suction pressure~                 |               |            |           |
| ~ex:sBAttr-005~ | ~imf:Attribute~      | ~Pressure delta~                   |               |            |           |
| ~ex:sBAttr-006~ | ~imf:Attribute~      | ~Pumping power~                    |               |            |           |
| ~ex:sBAttr-007~ | ~imf:Attribute~      | ~App standard~                     |               |            |           |
| ~ex:sBAttr-008~ | ~imf:Attribute~      | ~Client reqs~                      |               |            |           |
| ~ex:sBAttr-009~ | ~imf:Attribute~      | ~Noise regs~                       |               |            |           |
| ~ex:sT-001~     | ~imf:Terminal~       |                                    |               |            |           |
| ~ex:sT-002~     | ~imf:Terminal~       |                                    |               |            |           |
| ~ex:sT-003~     | ~imf:Terminal~       |                                    |               |            |           |

#+CALL: py_run_sparql(query=sparql_shaclClassRestriction, data="example/pumpingFunctionType.xlsx.ttl")

#+RESULTS:
| ~class~         | ~path~                  | ~minCount~ | ~maxCount~ | ~nodeTargetClass~ | ~hasValue~                 | ~in~ | ~datatype~    | ~minExclusive~ | ~minInclusive~ | ~maxExclusive~ | ~maxInclusive~ | ~minLength~ | ~maxLength~ | ~pattern~ | ~flags~ |
|-----------------+-------------------------+------------+------------+-------------------+----------------------------+------+---------------+----------------+----------------+----------------+----------------+-------------+-------------+-----------+---------|
| ~ex:sB-001~     | ~imf:hasTerminal~       | ~1~        | ~1~        | ~ex:sT-001~       |                            |      |               |                |                |                |                |             |             |           |         |
| ~ex:sB-001~     | ~imf:hasTerminal~       | ~1~        | ~1~        | ~ex:sT-002~       |                            |      |               |                |                |                |                |             |             |           |         |
| ~ex:sB-001~     | ~imf:hasAttributeGroup~ | ~1~        | ~1~        | ~ex:sBAg-002~     |                            |      |               |                |                |                |                |             |             |           |         |
| ~ex:sB-001~     | ~imf:aspect~            |            |            |                   | ~imf:functionAspect~       |      |               |                |                |                |                |             |             |           |         |
| ~ex:sB-001~     | ~imf:symbol~            |            |            |                   | ~SP402~                    |      |               |                |                |                |                |             |             |           |         |
| ~ex:sB-001~     | ~imf:classifier~        |            |            |                   | ~ns1:Pumping~              |      |               |                |                |                |                |             |             |           |         |
| ~ex:sB-001~     | ~imf:hasTerminal~       | ~1~        | ~3~        | ~ex:sT-003~       |                            |      |               |                |                |                |                |             |             |           |         |
| ~ex:sB-001~     | ~imf:hasAttributeGroup~ | ~1~        | ~1~        | ~ex:sBAg-001~     |                            |      |               |                |                |                |                |             |             |           |         |
| ~ex:sBAg-001~   | ~imf:hasAttribute~      | ~1~        | ~1~        | ~ex:sBAttr-001~   |                            |      |               |                |                |                |                |             |             |           |         |
| ~ex:sBAg-001~   | ~imf:hasAttribute~      | ~1~        | ~1~        | ~ex:sBAttr-002~   |                            |      |               |                |                |                |                |             |             |           |         |
| ~ex:sBAg-001~   | ~imf:hasAttribute~      | ~1~        | ~1~        | ~ex:sBAttr-003~   |                            |      |               |                |                |                |                |             |             |           |         |
| ~ex:sBAg-001~   | ~imf:hasAttribute~      | ~1~        | ~1~        | ~ex:sBAttr-004~   |                            |      |               |                |                |                |                |             |             |           |         |
| ~ex:sBAg-001~   | ~imf:hasAttribute~      | ~1~        | ~1~        | ~ex:sBAttr-005~   |                            |      |               |                |                |                |                |             |             |           |         |
| ~ex:sBAg-001~   | ~imf:hasAttribute~      | ~1~        | ~1~        | ~ex:sBAttr-006~   |                            |      |               |                |                |                |                |             |             |           |         |
| ~ex:sBAg-002~   | ~imf:hasAttribute~      | ~1~        | ~1~        | ~ex:sBAttr-007~   |                            |      |               |                |                |                |                |             |             |           |         |
| ~ex:sBAg-002~   | ~imf:hasAttribute~      | ~1~        | ~1~        | ~ex:sBAttr-008~   |                            |      |               |                |                |                |                |             |             |           |         |
| ~ex:sBAg-002~   | ~imf:hasAttribute~      | ~1~        | ~1~        | ~ex:sBAttr-009~   |                            |      |               |                |                |                |                |             |             |           |         |
| ~ex:sBAttr-001~ | ~imf:value~             | ~1~        | ~1~        |                   |                            |      | ~xsd:integer~ |                | ~0~            |                | ~10000~        |             |             |           |         |
| ~ex:sT-001~     | ~imf:classifier~        |            |            |                   | ~ns1:RDS4233125~           |      |               |                |                |                |                |             |             |           |         |
| ~ex:sT-001~     | ~imf:direction~         |            |            |                   | ~imf:input~                |      |               |                |                |                |                |             |             |           |         |
| ~ex:sT-001~     | ~imf:media~             |            |            |                   | ~ns1:WaterMedium~          |      |               |                |                |                |                |             |             |           |         |
| ~ex:sT-001~     | ~imf:classifier~        |            |            |                   | ~ns1:RDS4233127~           |      |               |                |                |                |                |             |             |           |         |
| ~ex:sT-001~     | ~imf:direction~         |            |            |                   | ~imf:output~               |      |               |                |                |                |                |             |             |           |         |
| ~ex:sT-001~     | ~imf:media~             |            |            |                   | ~ns1:WaterMedium~          |      |               |                |                |                |                |             |             |           |         |
| ~ex:sT-002~     | ~imf:direction~         |            |            |                   | ~imf:input~                |      |               |                |                |                |                |             |             |           |         |
| ~ex:sT-002~     | ~imf:media~             |            |            |                   | ~ns1:MechanicalRotatation~ |      |               |                |                |                |                |             |             |           |         |

* Appendix
** Prefixes

This section contains the prefixes used throughout this document.

*** Standard vocabulary prefixes

#+NAME: prefixes-std
#+BEGIN_SRC ttl :tangle out/.std-prefixes.ttl
@prefix xsd:	<http://www.w3.org/2001/XMLSchema#> .
@prefix rdf:	<http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:	<http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl:    <http://www.w3.org/2002/07/owl#> .
@prefix sh: 	<http://www.w3.org/ns/shacl#> . 
@prefix shsh:   <http://www.w3.org/ns/shacl-shacl#> .

@prefix skos:	<http://www.w3.org/2004/02/skos/core#> .
@prefix pav:	<http://purl.org/pav/> .
@prefix dc:	<http://purl.org/dc/terms/> .
@prefix vs:     <http://www.w3.org/2003/06/sw-vocab-status/ns#> .
@prefix vann:   <http://purl.org/vocab/vann/> .
@prefix foaf:   <http://xmlns.com/foaf/0.1/> .

@prefix imf:	<http://ns.imfid.org/imf#> .
@prefix ex:	<http://example.com#> .
#+END_SRC

#+RESULTS: prefixes-std
#+begin_example
@prefix xsd:	<http://www.w3.org/2001/XMLSchema#> .
@prefix rdf:	<http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:	<http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl:    <http://www.w3.org/2002/07/owl#> .
@prefix sh: 	<http://www.w3.org/ns/shacl#> . 
@prefix shsh:   <http://www.w3.org/ns/shacl-shacl#> .

@prefix skos:	<http://www.w3.org/2004/02/skos/core#> .
@prefix pav:	<http://purl.org/pav/> .
@prefix vs:     <http://www.w3.org/2003/06/sw-vocab-status/ns#> .
@prefix vann:   <http://purl.org/vocab/vann/> .
@prefix foaf:   <http://xmlns.com/foaf/0.1/> .

@prefix imf:	<http://ns.imfid.org/imf#> .
@prefix ex:	<http://example.com#> .
#+end_example

*** IMF prefixes

#+NAME: prefixes-imf
#+BEGIN_SRC ttl

@prefix p14:    <http://example.com/P14#> .
#+END_SRC

*** OTTR template prefixes

#+NAME: prefixes-ottr
#+BEGIN_SRC ttl
@prefix ottr:        <http://ns.ottr.xyz/0.4/> .
@prefix o-rdf:       <http://tpl.ottr.xyz/rdf/0.1/> .
@prefix o-rdfs:       <http://tpl.ottr.xyz/rdfs/0.2/> .
@prefix o-owl-ax:    <http://tpl.ottr.xyz/owl/axiom/0.1/> .
@prefix o-owl-ma:    <http://tpl.ottr.xyz/owl/macro/0.1/> .
@prefix o-owl-rstr:  <http://tpl.ottr.xyz/owl/restriction/0.1/> .

@prefix o-imf:	     <http://ns.imfid.org/templates/> .
@prefix o-imf-t-s:   <http://ns.imfid.org/templates/type/shacl/> .
@prefix o-imf-t-o:   <http://ns.imfid.org/templates/type/owl/> .

#+END_SRC

*** All prefixes combined                                          :noexport:

#+NAME: prefixes
#+BEGIN_SRC ttl :noweb yes
<<prefixes-std>>
<<prefixes-imf>>
<<prefixes-ottr>>
#+END_SRC

#+RESULTS: prefixes
#+begin_example
@prefix xsd:	<http://www.w3.org/2001/XMLSchema#> .
@prefix rdf:	<http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:	<http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl:    <http://www.w3.org/2002/07/owl#> .
@prefix skos:	<http://www.w3.org/2004/02/skos/core#> .
@prefix pav:	<http://purl.org/pav/> .
@prefix sh: 	<http://www.w3.org/ns/shacl#> . 
@prefix shsh:   <http://www.w3.org/ns/shacl-shacl#> .
@prefix ex:	<http://example.com#> .
@prefix imf:	<http://ns.imfid.org/imf#> .

@prefix p14:    <http://example.com/P14#> .
@prefix ottr:        <http://ns.ottr.xyz/0.4/> .
@prefix o-rdf:       <http://tpl.ottr.xyz/rdf/0.1/> .
@prefix o-rdfs:       <http://tpl.ottr.xyz/rdfs/0.2/> .
@prefix o-owl-ax:    <http://tpl.ottr.xyz/owl/axiom/0.1/> .
@prefix o-owl-ma:    <http://tpl.ottr.xyz/owl/macro/0.1/> .
@prefix o-owl-rstr:  <http://tpl.ottr.xyz/owl/restriction/0.1/> .

@prefix o-imf:	     <http://ns.imfid.org/templates/> .
@prefix o-imf-t-s:   <http://ns.imfid.org/templates/type/shacl/> .
#+end_example

#+NAME: py_prefixes_sparql
#+BEGIN_SRC python :var prefixes=prefixes 
output = ""

for p in prefixes.split("\n"):
  output += p.replace("@","").strip().strip(".") + "\n"

return output
#+END_SRC

#+RESULTS: py_prefixes_sparql
#+begin_example
prefix xsd:	<http://www.w3.org/2001/XMLSchema#> 
prefix rdf:	<http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
prefix rdfs:	<http://www.w3.org/2000/01/rdf-schema#> 
prefix owl:    <http://www.w3.org/2002/07/owl#> 
prefix skos:	<http://www.w3.org/2004/02/skos/core#> 
prefix pav:	<http://purl.org/pav/> 
prefix sh: 	<http://www.w3.org/ns/shacl#> 
prefix shsh:   <http://www.w3.org/ns/shacl-shacl#> 
prefix ex:	<http://example.com#> 
prefix imf:	<http://ns.imfid.org/imf#> 

prefix p14:    <http://example.com/P14#> 
prefix ottr:        <http://ns.ottr.xyz/0.4/> 
prefix o-rdf:       <http://tpl.ottr.xyz/rdf/0.1/> 
prefix o-rdfs:       <http://tpl.ottr.xyz/rdfs/0.2/> 
prefix o-owl-ax:    <http://tpl.ottr.xyz/owl/axiom/0.1/> 
prefix o-owl-ma:    <http://tpl.ottr.xyz/owl/macro/0.1/> 
prefix o-owl-rstr:  <http://tpl.ottr.xyz/owl/restriction/0.1/> 

prefix o-imf:	     <http://ns.imfid.org/templates/> 
prefix o-imf-t-s:   <http://ns.imfid.org/templates/type/shacl/>
#+end_example




** Media                                                           :noexport:

  Media, taken from ~MaterialsBreakdownRev3.xlsx~.
  
  | 1           | 2          | 3            |
  |-------------+------------+--------------|
  | Material    |            |              |
  |             | Fluid      |              |
  |             |            | Process (HC) |
  |             |            | Water        |
  |             |            | Chemicals    |
  |             |            | Utilities    |
  |             | Solids     |              |
  |             |            | Granulate    |
  |             |            | Brick        |
  |-------------+------------+--------------|
  | Energy      |            |              |
  |             | Mechanical |              |
  |             |            | Rotating     |
  |             |            | Reciprocing  |
  |             | Electrical |              |
  |             |            | EHV          |
  |             |            | HV           |
  |             |            | LV           |
  |             |            | <50V         |
  |             | Thermal    |              |
  |             |            | Liquid       |
  |             |            | Steam        |
  |             |            | Burner       |
  |             |            | Air          |
  |             |            | Electric     |
  |-------------+------------+--------------|
  | Force       |            |              |
  |             | Mechanical |              |
  |             |            | Support      |
  |             |            | Connect      |
  |             |            | Restrain     |
  |-------------+------------+--------------|
  | Information |            |              |
  |             | Electrical |              |
  |             |            | Wired        |
  |             |            | Bus          |
  |             | Optical    |              |
  |             |            | Digital      |
  |             | Wireless   |              |
  |             |            | Digital      |


                           



* System setup                                                     :noexport:
** Apache Jena

https://jena.apache.org/:

"A free and open source Java framework for building Semantic Web and
Linked Data applications", including reading and writing RDF, SHACL
validation and SPARQL query processing.

This section contains the script calls used for processing the RDF
code snippets in this document.

*** Download

#+BEGIN_SRC sh :results raw
cd bin
wget -O apache-jena.zip -nc -x https://dlcdn.apache.org/jena/binaries/apache-jena-4.4.0.zip
unzip apache-jena.zip
mv apache-jena-4.4.0 apache-jena
#+END_SRC


*** RIOT

Reading, writing and validating RDF.

#+BEGIN_SRC sh :results output verbatim
bin/apache-jena/bin/riot --help
#+END_SRC

#+RESULTS:
#+begin_example
riot [--help] [--time] [--base=IRI] [-syntax=FORMAT] [--out=FORMAT] [--count] file ...
  Parser control
      --sink                 Parse but throw away output
      --syntax=NAME          Set syntax (otherwise syntax guessed from file extension)
      --base=URI             Set the base URI (does not apply to N-triples and N-Quads)
      --check                Additional checking of RDF terms
      --strict               Run with in strict mode
      --validate             Same as --sink --check --strict
      --count                Count triples/quads parsed, not output them
      --rdfs=file            Apply some RDFS inference using the vocabulary in the file
      --nocheck              Turn off checking of RDF terms
  Output control
      --output=FMT           Output in the given format, streaming if possible.
      --formatted=FMT        Output, using pretty printing (consumes memory)
      --stream=FMT           Output, using a streaming format
      --compress             Compress the output with gzip
  Time
      --time                 Time the operation
  Symbol definition
      --set                  Set a configuration symbol to a value
  General
      -v   --verbose         Verbose
      -q   --quiet           Run with minimal output
      --debug                Output information for debugging
      --help
      --version              Version information
#+end_example

#+NAME: sh_jena_validate_rdf
#+BEGIN_SRC sh :results output verbatim :var syntax="TTL" :var files="out/owl/imf-ontology.owl.ttl"
bin/apache-jena/bin/riot --verbose --syntax=$syntax --validate --time $files 
#+END_SRC

#+RESULTS: sh_jena_validate_rdf
: file:///home/martige/repo/imf-lab/imf-ontology/out/owl/imf-ontology.owl.ttl : 0.22 sec : 494 Triples : 2,235.29 per second

#+NAME: sh_jena_merge
#+BEGIN_SRC sh :results output verbatim :var syntax="TTL" :var files="out/owl/imf-elements.owl.ttl out/owl/imf-attributes.owl.ttl" :var out="out/owl/imf-ontology.owl.ttl"
bin/apache-jena/bin/riot --verbose --syntax=$syntax --check --time $files > $out
#+END_SRC

#+RESULTS: sh_jena_merge
: 08:47:29 INFO  riot            :: File: out/owl/imf-elements.owl.ttl
: file:///home/martige/repo/imf-lab/imf-ontology/out/owl/imf-elements.owl.ttl : 0.19 sec : 146 Triples : 768.42 per second
: 08:47:29 INFO  riot            :: File: out/owl/imf-attributes.owl.ttl
: file:///home/martige/repo/imf-lab/imf-ontology/out/owl/imf-attributes.owl.ttl : 0.02 sec : 140 Triples : 7,000.00 per second
: Total           : 0.21 sec : 286 Triples : 1,361.90 per second

*** SHACL

Validate RDF wrt. SHACL shapes.

#+BEGIN_SRC sh :results output verbatim
bin/apache-jena/bin/shacl v --help
#+END_SRC

#+RESULTS:
#+begin_example
shacl_validate [--target URI] --shapes shapesFile --data dataFile
  General
      -v   --verbose         Verbose
      -q   --quiet           Run with minimal output
      --debug                Output information for debugging
      --help
      --version              Version information
      --shapes               Shapes file
      --data                 Data file
      --target               Validate specific node [may use prefixes from the data]
      --text                 Output in concise text format
#+end_example

#+NAME: sh_jena_shacl_validate
#+BEGIN_SRC sh :results output raw :var shapes="shapefile" :var data="rdf-examples/coffee-machine.ttl" :wrap src ttl
echo "Result of validating RDF data <$data> against SHACL shape <$shapes>:"
date +'%Y-%m-%d'
bin/apache-jena/bin/shacl v --text --shapes $shapes --data $data
#+END_SRC

#+RESULTS: sh_jena_shacl_validate
#+BEGIN_src ttl
Result of validating RDF data <rdf-examples/coffee-machine.ttl> against SHACL shape <shapefile>:
2023-06-15
Loading shapes file
org.apache.jena.riot.RiotNotFoundException: Not found: shapefile
	at org.apache.jena.riot.RDFParser.openTypedInputStream(RDFParser.java:409)
	at org.apache.jena.riot.RDFParser.parseURI(RDFParser.java:316)
	at org.apache.jena.riot.RDFParser.parse(RDFParser.java:310)
	at org.apache.jena.riot.RDFParserBuilder.parse(RDFParserBuilder.java:552)
	at org.apache.jena.riot.RDFDataMgr.parseFromURI(RDFDataMgr.java:737)
	at org.apache.jena.riot.RDFDataMgr.read(RDFDataMgr.java:193)
	at org.apache.jena.riot.RDFDataMgr.read(RDFDataMgr.java:135)
	at org.apache.jena.riot.RDFDataMgr.loadGraph(RDFDataMgr.java:352)
	at shacl.shacl_validate.load(shacl_validate.java:134)
	at shacl.shacl_validate.exec(shacl_validate.java:106)
	at org.apache.jena.cmd.CmdMain.mainMethod(CmdMain.java:92)
	at org.apache.jena.cmd.CmdMain.mainRun(CmdMain.java:58)
	at org.apache.jena.cmd.CmdMain.mainRun(CmdMain.java:45)
	at shacl.shacl_validate.main(shacl_validate.java:60)
	at shacl.shacl.main(shacl.java:81)
#+END_src


#+NAME: sh_jena_shacl_imf_validate
#+BEGIN_SRC sh :results output raw :var data="rdf-examples/coffee-machine.ttl" :wrap src ttl
bin/apache-jena/bin/shacl v --text --shapes shacl/imf-all.shacl.ttl --data $data
#+END_SRC

#+RESULTS: sh_jena_shacl_imf_validate
#+BEGIN_src ttl
Loading shapes file
org.apache.jena.riot.RiotNotFoundException: Not found: shacl/imf-all.shacl.ttl
	at org.apache.jena.riot.RDFParser.openTypedInputStream(RDFParser.java:409)
	at org.apache.jena.riot.RDFParser.parseURI(RDFParser.java:316)
	at org.apache.jena.riot.RDFParser.parse(RDFParser.java:310)
	at org.apache.jena.riot.RDFParserBuilder.parse(RDFParserBuilder.java:552)
	at org.apache.jena.riot.RDFDataMgr.parseFromURI(RDFDataMgr.java:737)
	at org.apache.jena.riot.RDFDataMgr.read(RDFDataMgr.java:193)
	at org.apache.jena.riot.RDFDataMgr.read(RDFDataMgr.java:135)
	at org.apache.jena.riot.RDFDataMgr.loadGraph(RDFDataMgr.java:352)
	at shacl.shacl_validate.load(shacl_validate.java:134)
	at shacl.shacl_validate.exec(shacl_validate.java:106)
	at org.apache.jena.cmd.CmdMain.mainMethod(CmdMain.java:92)
	at org.apache.jena.cmd.CmdMain.mainRun(CmdMain.java:58)
	at org.apache.jena.cmd.CmdMain.mainRun(CmdMain.java:45)
	at shacl.shacl_validate.main(shacl_validate.java:60)
	at shacl.shacl.main(shacl.java:81)
#+END_src


#+NAME: sh_jena_shacl_std_validate
#+BEGIN_SRC sh :results output raw :var data="out/owl/imf-ontology.owl.ttl" :wrap src ttl
echo "Result of validating RDF data <$data> against SHACL shape <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl>:\n"
bin/apache-jena/bin/shacl v --text --shapes http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl --data $data
#+END_SRC

#+RESULTS: sh_jena_shacl_std_validate
#+BEGIN_src ttl
Result of validating data <out/owl/imf-ontology.owl.ttl> against shape <http://shipshape.dyreriket.xyz/std-vocabulary-elements.ttl>:

Conforms
#+END_src

*** SPARQL

Query RDF.

#+BEGIN_SRC sh :results output verbatim
bin/apache-jena/bin/sparql --help
#+END_SRC

#+RESULTS:
#+begin_example
sparql --data=<file> --query=<query>
  Control
      --explain              Explain and log query execution
      --repeat=N or N,M      Do N times or N warmup and then M times (use for timing to overcome start up costs of Java)
      --optimize=            Turn the query optimizer on or off (default: on)
  Time
      --time                 Time the operation
  Query Engine
      --engine=EngineName    Register another engine factory[ref]
      --unengine=EngineName   Unregister an engine factory
  Dataset
      --data=FILE            Data for the dataset - triple or quad formats
      --graph=FILE           Graph for default graph of the datset
      --namedGraph=FILE      Add a graph into the dataset as a named graph
  Results
      --results=             Results format (Result set: text, XML, JSON, CSV, TSV; Graph: RDF serialization)
      --desc=                Assembler description file
  Query
      --query, --file        File containing a query
      --syntax, --in         Syntax of the query
      --base                 Base URI for the query
  Symbol definition
      --set                  Set a configuration symbol to a value
  General
      -v   --verbose         Verbose
      -q   --quiet           Run with minimal output
      --debug                Output information for debugging
      --help
      --version              Version information
      --strict               Operate in strict SPARQL mode (no extensions of any kind)
#+end_example


#+NAME: sh_jena_sparql
#+BEGIN_SRC sh :results output :var query="PREFIX imf: <http://ns.imfid.org/imf#> SELECT * {?s ?p ?o} LIMIT 1" :var files="out/owl/imf-ontology.owl.ttl" :hlines yes :exports both
echo "$query" > out/temp/.temp-sh_jena_sparql
bin/apache-jena/bin/sparql --results=text --data=$files --query out/temp/.temp-sh_jena_sparql
#+END_SRC

#+RESULTS: sh_jena_sparql
: ---------------------------------------------------------------------------------------------------------------
: | s    | p                                                 | o                                                |
: ===============================================================================================================
: | _:b0 | <http://www.w3.org/1999/02/22-rdf-syntax-ns#rest> | <http://www.w3.org/1999/02/22-rdf-syntax-ns#nil> |
: ---------------------------------------------------------------------------------------------------------------



** Lutra

Lutra is the reference implementation for working with OTTR templates
and instances.

This section contains the scripts that are used to expand the OTTR
instances found in this document.

#+BEGIN_SRC sh 
cd bin
wget -O lutra.jar -nc -x http://ottr.xyz/downloads/lutra/lutra-master.jar
#+END_SRC

#+RESULTS:

#+NAME: lutra-help
#+BEGIN_SRC sh :results output verbatim
java -jar bin/lutra.jar --help
#+END_SRC

#+RESULTS: lutra-help
#+begin_example
Usage: lutra [-fhV] [--debugFullTrace] [--debugStackTrace] [--quiet] [--stdout]
             [-F=<fetchFormat>] [--haltOn=<haltOn>] [-I=<inputFormat>]
             [-L=<libraryFormat>] [-m=<mode>] [-o=<out>] [-O=<outputFormat>]
             [-p=<prefixes>] [-e=<extensions>[,<extensions>...]]...
             [-E=<ignoreExtensions>[,<ignoreExtensions>...]]...
             [-l=<library>]... [<inputs>...]

DESCRIPTION:
Reference implementation for OTTR Templates. Use for expanding template
instances and template definitions, translating between different formats and
for checking the integrity of template libraries.

PARAMETERS:
      [<inputs>...]         Files of instances to which operations are to be
                              applied.

OPTIONS:
      --debugFullTrace      This enables tracing such that printed messages get
                              a stack trace giving more information on the
                              location of the concerned objects. NB! Enabling
                              this flag will deteriorate performance.
                            default: false)
      --debugStackTrace     This enables printing a regular java stack trace
                              for error messages.Enabling this flag will not
                              deteriorate performance.
                            default: false)
  -e, --extension=<extensions>[,<extensions>...]
                            File extension of files to use as input to template
                              library.
                            (default: [])
  -E, --ignoreExtension=<ignoreExtensions>[,<ignoreExtensions>...]
                            File extensions of files to ignore as input to
                              template library.
                            (default: [])
  -f, --fetchMissing        Fetch missing template dependencies. It is here
                              assumed that templates' definitions are
                              accessible via their IRI, that is, the IRI is
                              either a path to a file, a URL, or similar.
                            (default: false)
  -F, --fetchFormat=<fetchFormat>
                            The input format of the templates fetched via the
                              -f flag.
  -h, --help                Show this help message and exit.
      --haltOn=<haltOn>     Halt execution upon receiving messages with a
                              severity equal to or greater than this value.
                            (legal values: INFO, WARNING, ERROR, FATAL;
                              default: ERROR)
  -I, --inputFormat=<inputFormat>
                            Input format of instances.
                            (legal values: wottr, stottr, tabottr, bottr
                              default: wottr)
  -l, --library=<library>   Folder containing templates to use as library. Can
                              be used multiple times for multiple libraries.
  -L, --libraryFormat=<libraryFormat>
                            The input format of the libraries. If omitted, all
                              available formats are attempted.
                            (legal values: wottr, stottr)
  -m, --mode=<mode>         The mode of operation to be applied to input.
                            (legal values: expand, expandLibrary, format,
                              formatLibrary, lint, checkSyntax, docttrLibrary;
                              default: expand)
  -o, --output=<out>        Path for writing output.
  -O, --outputFormat=<outputFormat>
                            Output format of output of operation defined by the
                              mode.
                            (legal values: wottr, stottr; default: wottr)
  -p, --prefixes=<prefixes> Path to RDF file containing prefix declarations to
                              be used when rendering output.    Any other data
                              in the file is read, but ignored.
      --quiet               Suppress all messages, including errors and
                              warnings.
                            (default: false)
      --stdout              Print system of operations to standard out.
                            (default: false)
  -V, --version             Print version information and exit.

LINKS:
Website:  https://ottr.xyz
Primers:  https://primer.ottr.xyz
Git repo: https://gitlab.com/ottr/lutra/lutra
#+end_example

#+NAME: lutra-expand
#+BEGIN_SRC sh :results output verbatim :var in="out/owl/imf-aspects.owl.wottr.ttl" :var inFormat="wottr" :var out="out/owl/imf-aspects.owl.ttl"
java -jar bin/lutra.jar -l out/ottr -L stottr -f -p out/.std-prefixes.ttl -I $inFormat -o $in.temp $in 
rapper -i turtle -o turtle $in.temp > $out
cat $out
#+END_SRC

#+RESULTS: lutra-expand
** RDFVizler with rules

https://rdfvizler.dyreriket.xyz/:

#+BEGIN_QUOTE
RDFVizler is a simple RDF visualisation software built with the Apache
Jena Java API and Graphviz visualisation software. It requires Java 8
and Graphviz to be installed on the system.

RDFVizler visualises RDF graphs by parsing a designated RDFVizler OWL
vocabulary into Graphviz's DOT language and then straight-forwardly to
images using the Graphviz software. The RDFVizler vocabulary acts as a
mere "RDF wrapper language" for the DOT language, all graph, edge and
node attributes are taken directly from DOT."
#+END_QUOTE

*** TODO Script calls

TODO: setup download

#+BEGIN_SRC sh :results output verbatim
java -jar bin/rdfvizler.jar --help
#+END_SRC

#+RESULTS:
#+begin_example

RDFVizler: RDF visualisation

Usage:
java -jar rdfvizler-[version].jar [--help] [--mergeInput] [--skipRules]
                                  [--version]
                                  [--inputFormatRDF=<inputFormatRDF>]
                                  [--outputFormatRDF=<outputFormatRDF>]
                                  [-i=<outputFormatImage>] [-r=<rules>]
                                  [-x=<mode>] RDF_FILES...

Description:
RDFVizler visualises RDF by parsing a designated RDF RDFVizler vocabulary into
Graphviz syntax and processing this to a graph using Graphviz' dot software.
For more details, see http://rdfvizler.dyreriket.xyz.

Parameters:
      RDF_FILES...      Input RDF: URIs or file paths

Options:
  -x, --executionMode=<mode>
                        What output to produce. (legal values: rdf, dot, image;
                          default: image)
  -r, --rules=<rules>   Input rules: URI or file path (default: http://rdfvizler.
                          dyreriket.xyz/rules/rdf.jrule)
      --skipRules       Skip rule application to input? (default: false)
      --inputFormatRDF=<inputFormatRDF>
                        Format of RDF input (legal values: rdf, ttl, nt, guess;
                          default: guess -- by file extension as per jena.util.
                          FileUtils, then Turtle)
      --mergeInput      Merge input files to a single model to visualise?
      --outputFormatRDF=<outputFormatRDF>
                        Format of RDF output (legal values: rdf, ttl, nt, guess;
                          default: rdf)
  -i, --outputFormatImage=<outputFormatImage>
                        Format of image output (legal values: PNG, SVG,
                          SVG_STANDALONE, DOT, XDOT, PLAIN, PLAIN_EXT, PS, PS2,
                          JSON, JSON0, IMAP, CMAPX; default: SVG_STANDALONE)
      --version         Display version info
      --help            Display this help message
#+end_example


#+NAME: rdfvizler
#+BEGIN_SRC sh :results output verbatim :var rules="out/rdfvizler/import-hierarchy.rule" :var data="out/owl/imf-ontology.owl.ttl" :var output="out/.output-rdfvizler.svg"
java -jar bin/rdfvizler.jar --rules=$rules $data > $output
#+END_SRC

#+RESULTS: rdfvizler
#+begin_example
Exception in thread "main" picocli.CommandLine$ExecutionException: Error while running command (xyz.dyreriket.rdfvizler.cli.RDFVizlerCLI@66498326): org.apache.jena.shared.RulesetNotFoundException: out/rdfvizler/import-hierarchy.rule
	at picocli.CommandLine.execute(CommandLine.java:1056)
	at picocli.CommandLine.access$900(CommandLine.java:142)
	at picocli.CommandLine$RunLast.handle(CommandLine.java:1255)
	at picocli.CommandLine$RunLast.handle(CommandLine.java:1223)
	at picocli.CommandLine$AbstractParseResultHandler.handleParseResult(CommandLine.java:1131)
	at picocli.CommandLine.parseWithHandlers(CommandLine.java:1414)
	at picocli.CommandLine.run(CommandLine.java:1878)
	at picocli.CommandLine.run(CommandLine.java:1808)
	at xyz.dyreriket.rdfvizler.cli.RDFVizlerCLI.main(RDFVizlerCLI.java:133)
Caused by: org.apache.jena.shared.RulesetNotFoundException: out/rdfvizler/import-hierarchy.rule
	at org.apache.jena.reasoner.rulesys.Rule.rulesFromURL(Rule.java:511)
	at org.apache.jena.reasoner.rulesys.Rule.rulesFromURL(Rule.java:524)
	at xyz.dyreriket.rdfvizler.RDFVizler.getRules(RDFVizler.java:39)
	at xyz.dyreriket.rdfvizler.RDFVizler.getRDFDotModel(RDFVizler.java:72)
	at xyz.dyreriket.rdfvizler.RDFVizler.writeDotGraph(RDFVizler.java:105)
	at xyz.dyreriket.rdfvizler.RDFVizler.writeDotGraph(RDFVizler.java:111)
	at xyz.dyreriket.rdfvizler.RDFVizler.write(RDFVizler.java:99)
	at xyz.dyreriket.rdfvizler.cli.RDFVizlerCLI.processFile(RDFVizlerCLI.java:156)
	at xyz.dyreriket.rdfvizler.cli.RDFVizlerCLI.run(RDFVizlerCLI.java:166)
	at picocli.CommandLine.execute(CommandLine.java:1048)
	... 8 more
#+end_example

*** Prefixes                                                       :noexport:

#+NAME: prefixes-rdfvizler
#+BEGIN_SRC ttl :noweb yes :tangle out/rdfvizler/imf-data.rule :mkdirp yes
<<prefixes>>
@prefix rvz:  <http://rdfvizler.dyreriket.xyz/vocabulary/core#> .
@prefix rvz-a: <http://rdfvizler.dyreriket.xyz/vocabulary/attribute#> .
@prefix rvz-n: <http://rdfvizler.dyreriket.xyz/vocabulary/attribute-default-node#> .
@prefix rvz-e: <http://rdfvizler.dyreriket.xyz/vocabulary/attribute-default-edge#> .
@prefix :      <urn:temp#>
#+END_SRC

*** IMF data, old                                                  :noexport:

#+BEGIN_SRC ttl :noweb yes :mkdirp yes
<<prefixes-rdfvizler>>

### GRAPH default settings
    [init:
        ->
        (:graph rdf:type rvz:RootGraph)
        (:graph rdf:type rvz:DiGraph)
        (:graph rvz-a:rankdir "LR")
        (:graph rvz-a:nodesep "1")
        (:graph rvz-a:ranksep "1")
        (:graph rvz-a:center "true")
        (:graph rvz-a:overlap "true")
        (:graph rvz-a:splines "ortho")
        // node defaults
        (:graph rvz-n:fontname "Arial")
        (:graph rvz-n:fontsize "8px")
        (:graph rvz-n:height ".3")
        (:graph rvz-n:width ".3")
        (:graph rvz-n:fixedsize "true")
        // edge defaults
        (:graph rvz-e:fontname "Arial")
        (:graph rvz-e:fontsize "8px")
        ]

### SELECTION: This rule selects the triples to be drawn. Selection is
### done on the basis of predicates. ONLY the nodes and edges selected
### here appear in the diagram.

    [triples:
        (?s ?p ?o)
        equalssome(?p, imf:hasPart, imf:hasTerminal, imf:connectedTo, imf:hasLocation, imf:fulfilledBy, imf:installedAs) 
        makeSkolem(?edge, ?s, ?p, ?o)
        ->
        (:graph rvz:hasEdge ?edge)
        (?edge :predicate ?p)
        (:graph rvz:hasNode ?s)
        (:graph rvz:hasNode ?o)
        (?edge rvz:hasSource ?s)
        (?edge rvz:hasTarget ?o)
        ]

### EDGE FORMATTING

# constraint=false, see https://graphviz.org/docs/attrs/constraint/
    [imf:no-constraint:
        (?edge :predicate ?p)
        equalssome(?p, imf:connectedTo, imf:hasLocation, imf:fulfilledBy, imf:installedAs)
        ->
        (?edge rvz-a:constraint "false")
        ]

    [imf:hasPart:
        (?edge :predicate imf:hasPart)
        ->
        (?edge rvz-a:arrowtail "empty")
        (?edge rvz-a:dir "back")
        ]
        
    [imf:connectedTo:
        (?edge :predicate imf:connectedTo)
        ->
        (?edge rvz-a:arrowhead "none")
        (?edge rvz-a:color "gray50")
        (?edge rvz-a:style "dashed")
        ]
    [imf:hasTerminal:
        (?edge :predicate imf:hasTerminal)
        ->
        (?edge rvz-a:arrowhead "none")
        ]


    [imf:hasLocation:
        (?edge :predicate imf:hasLocation)
        ->
        (?edge rvz-a:color "magenta")
        (?edge rvz-a:arrowhead "none")
        (?edge rvz-a:style "dashed")
        ]

    [imf:fullfilledBy:
        (?edge :predicate imf:fulfilledBy)
        ->
        (?edge rvz-a:color "cyan")
        (?edge rvz-a:arrowhead "none")
        (?edge rvz-a:style "dashed")
        ]

    [imf:installedAs:
        (?edge :predicate imf:installedAs)
        ->
        (?edge rvz-a:color "skyblue2")
        (?edge rvz-a:arrowhead "none")
        (?edge rvz-a:style "dashed")
        ]

### NODE FORMATTING
### labels and URIs

    [Nodes:
        (:graph rvz:hasNode ?node)
        shortvalue(?node, ?name)
        ->
        //(?node rvz-a:label "")
        (?node rvz-a:label ?name)
        (?node rvz-a:style "filled")
        (?node rvz-a:URL ?node)
        ]

### Shapes: move these to ontology

    [Transport-shape:
        (:graph rvz:hasNode ?node)(?node rdf:type imf:Transport)
        ->
        (?node rvz-a:shape "hexagon")
        ]

    [Interface-shape:
        (:graph rvz:hasNode ?node)(?node rdf:type imf:Interface)
        ->
        (?node rvz-a:shape "triangle")
        (?node rvz-a:orientation "90")
        ]

    [Terminal-block-shape:
        (:graph rvz:hasNode ?node)(?node rdf:type imf:Terminal)
        -> (?node rvz-a:shape "doublecircle")
        ]

    [System-block-shape:
        (:graph rvz:hasNode ?node)(?node rdf:type imf:FunctionalBlock)
        -> (?node rvz-a:shape "square")
        ]


### Colours

    [Aspect-colour:
        (:graph rvz:hasNode ?node)
        (?node imf:hasAspect ?aspect)(?aspect imf:color ?color)
        ->
        (?node rvz-a:fillcolor ?color)
        ]

#+END_SRC

*** Ontology import hierarchy

This rule set visualises the owl:imports hierarchy.

#+BEGIN_SRC ttl :noweb yes :tangle out/rdfvizler/ontology-import-hierarchy.rule :mkdirp yes
<<prefixes-rdfvizler>>

### GRAPH default settings
    [init:
        ->
        (:graph rdf:type rvz:RootGraph)
        (:graph rdf:type rvz:DiGraph)
        (:graph rvz-a:rankdir "LR")
        (:graph rvz-a:center "true")
        (:graph rvz-a:overlap "true")       
        // node defaults
        (:graph rvz-n:fontname "Arial")
        (:graph rvz-n:fontsize "8px")
        // edge defaults
        (:graph rvz-e:fontname "Arial")
        (:graph rvz-e:fontsize "8px")
        ]

    [imports:
        (?ont owl:versionIRI ?iri)
        (?ont owl:imports ?import)
        makeSkolem(?_edge, ?iri, ?import)
        ->
        (:graph rvz:hasEdge ?_edge)
        (:graph rvz:hasNode ?iri)
        (:graph rvz:hasNode ?import)
        (?_edge rvz:hasSource ?iri)
        (?_edge rvz:hasTarget ?import)
        ]
#+END_SRC

#+CALL: rdfvizler(rules="out/rdfvizler/ontology-import-hierarchy.rule", output="out/temp/.ontology-import-hierarchy.svg")

#+RESULTS:

*** Ontology overview

This rule set creates a overview visualisation of an ontology taking
only the "easy to visualise" structures like classes, subclass
relations, properties with their domain and range, and instances.

#+BEGIN_SRC ttl :noweb yes :tangle out/rdfvizler/ontology-overview.rule :mkdirp yes
<<prefixes-rdfvizler>>

    [init-graph:
        ->
        (:graph rdf:type rvz:RootGraph)
        (:graph rdf:type rvz:DiGraph)
        (:graph rvz-a:rankdir "BT")
        (:graph rvz-a:center "true")
        // node defaults
	(:graph rvz-n:shape "box")
        (:graph rvz-n:fontname "Arial")
        (:graph rvz-n:fontsize "8px")
        // edge defaults
        (:graph rvz-e:fontname "Arial")
        (:graph rvz-e:fontsize "8px")
        ]

    [class:
        (?s rdf:type owl:Class)
	notBNode(?s)
        ->
        (:graph rvz:hasNode ?s)
        ]

    [individual:
        (:graph rvz:hasNode ?s)
        (?i rdf:type ?s)
        makeSkolem(?edge, ?i, rdf:type, ?s)
        ->
        (:graph rvz:hasNode ?i)
        (:graph rvz:hasEdge ?edge)
        (?edge :predicate rdf:type)
        (?edge rvz-a:style "dotted")
        (?edge rvz:hasSource ?i)
        (?edge rvz:hasTarget ?s)
        ]

    [label-node:
        (:graph rvz:hasNode ?node)
        shortvalue(?node ?label)
        ->
	(?node rvz-a:label ?label)
        ]

    [subclass:
        (?s rdfs:subClassOf ?o)
        makeSkolem(?edge, ?s, rdfs:subClassOf, ?o)
        ->
        (:graph rvz:hasEdge ?edge)
        (?edge :predicate ?p)
        (?edge rvz-a:arrowhead "empty")
        (?edge rvz-a:dir "forward")
        (:graph rvz:hasNode ?s)
        (:graph rvz:hasNode ?o)
        (?edge rvz:hasSource ?s)
        (?edge rvz:hasTarget ?o)
        ]

    [property:
        (?p rdfs:domain ?domain)
        (?p rdfs:range ?range)
        shortvalue(?p ?label)
        makeSkolem(?edge, ?domain, ?p, ?range)
        ->
        (:graph rvz:hasEdge ?edge)
        (:graph rvz:hasNode ?domain)
        (:graph rvz:hasNode ?range)
        (?edge :predicate ?p)
	(?edge rvz-a:label ?label)
        (?edge rvz:hasSource ?domain)
        (?edge rvz:hasTarget ?range)
        ]

    [SubObjectExactCardinality:
        (?i ottr:of o-owl-ax:SubObjectExactCardinality)
        (?i ottr:values ?arg1)
	(?arg1 rdf:first ?domain)
	(?arg1 rdf:rest ?arg2)
	(?arg2 rdf:first ?card)
	(?arg2 rdf:rest ?arg3)
	(?arg3 rdf:first ?property)
	(?arg3 rdf:rest ?arg4)
	(?arg4 rdf:first ?range)
	shortvalue(?property ?plabel)
	strConcat(?plabel, " ", ?card, ?label)
        makeSkolem(?edge, ?domain, ?card, ?property, ?range)
	->
        (:graph rvz:hasEdge ?edge)
        (:graph rvz:hasNode ?domain)
        (:graph rvz:hasNode ?range)
        (?edge :predicate ?property)
	(?edge rvz-a:label ?label)
        (?edge rvz-a:constraint "false")
        (?edge rvz-a:dir "forward")
        (?edge rvz-a:arrowhead "teetee")
        (?edge rvz:hasSource ?domain)
        (?edge rvz:hasTarget ?range)
        ]

    [Blanks:
	(:graph rvz:hasNode ?node)
	isBNode(?node)
	typedvalue(?node, ?label)
	->
	(?node rvz-a:label ?label)
	(?node rvz-a:shape "box")
	(?node rvz-a:style "filled,dashed")
	(?node rvz-a:fillcolor "gray90")
	(?node rvz-a:height ".3")
	(?node rvz-a:width ".3")
	]
#+END_SRC

#+CALL: rdfvizler(rules="out/rdfvizler/ontology-overview.rule", output="out/temp/.ontology-overview.svg")

#+RESULTS:

*** TODO IMF data

Work in process. Rule set for visualising IMF data.

#+BEGIN_SRC ttl :noweb yes :tangle out/rdfvizler/imf-data.rule :mkdirp yes
<<prefixes-rdfvizler>>

### GRAPH default settings
    [init:
        ->
        (:graph rdf:type rvz:RootGraph)
        (:graph rdf:type rvz:DiGraph)
        (:graph rvz-a:rankdir "LR")
        (:graph rvz-a:nodesep "1")
        (:graph rvz-a:ranksep "1")
        (:graph rvz-a:center "true")
        (:graph rvz-a:overlap "true")
        (:graph rvz-a:splines "ortho")
        // node defaults
        (:graph rvz-n:fontname "Arial")
        (:graph rvz-n:fontsize "8px")
        (:graph rvz-n:height ".3")
        (:graph rvz-n:width ".3")
        (:graph rvz-n:fixedsize "true")
        // edge defaults
        (:graph rvz-e:fontname "Arial")
        (:graph rvz-e:fontsize "8px")
        ]

### SELECTION: This rule selects the triples to be drawn. Selection is
### done on the basis of predicates. ONLY the nodes and edges selected
### here appear in the diagram.

    [triples:
        (?s ?p ?o)
        equalssome(?p, imf:hasPart, imf:hasTerminal, imf:connectedTo, imf:hasLocation, imf:fulfilledBy, imf:installedAs) 
        makeSkolem(?edge, ?s, ?p, ?o)
        ->
        (:graph rvz:hasEdge ?edge)
        (?edge :predicate ?p)
        (:graph rvz:hasNode ?s)
        (:graph rvz:hasNode ?o)
        (?edge rvz:hasSource ?s)
        (?edge rvz:hasTarget ?o)
        ]

### EDGE FORMATTING

# constraint=false, see https://graphviz.org/docs/attrs/constraint/
    [imf:no-constraint:
        (?edge :predicate ?p)
        equalssome(?p, imf:connectedTo, imf:hasLocation, imf:fulfilledBy, imf:installedAs)
        ->
        (?edge rvz-a:constraint "false")
        ]

    [edge-attribute
        (:graph rvz:hasEdge ?edge)
        (?edge :predicate ?p)
        (?p ?rvza ?value)
        namespace(?rvza, "http://rdfvizler.dyreriket.xyz/vocabulary/attribute#")
        ->
        (?edge ?rvza ?value)
        ]

    [node-attribute
        (:graph rvz:hasNode ?node)
        (?node rdf:type ?class)
        (?class ?rvza ?value)
        namespace(?rvza, "http://rdfvizler.dyreriket.xyz/vocabulary/attribute#")
        ->
        (?node ?rvza ?value)
        ]
#+END_SRC

** Python code snippets
*** py Common functions

#+NAME: py_common_functions
#+BEGIN_SRC python
import rdflib

def getAllIRIs(data):
  graph = rdflib.Graph()
  iri = []

  graph.parse(data, format="ttl")

  for s, p, o in graph:
    if(isinstance(s, rdflib.term.URIRef)):
      iri.append(s)
    if(isinstance(p, rdflib.term.URIRef)):
      iri.append(p)
    if(isinstance(o, rdflib.term.URIRef)):
      iri.append(o)
    
  return set(iri)


#+END_SRC

*** py_ottr_instances

Convert tables to OTTR instances.

#+NAME: py_ottr_instances
#+BEGIN_SRC python :results raw :wrap src ttl :var template="ex:template" :var table=tbl-aspects :exports none
output = ""

instance = "[] ottr:of {} ;\n   ottr:values ( {} ) . \n"

## aspects
for row in table[0:]:
  args = map(lambda x: 'ottr:none' if not str(x).strip() else x, row)
  output += instance.format(template, " ".join(f'{w}' for w in args))

return output
#+END_SRC

#+RESULTS: py_ottr_instances
#+BEGIN_src ttl
[] ottr:of ex:template ;
   ottr:values( imf:FunctionAspect '=' '#FFFF00' ) . 
[] ottr:of ex:template ;
   ottr:values( imf:LocationAspect '+' '#FF00FF' ) . 
[] ottr:of ex:template ;
   ottr:values( imf:ProductAspect '-' '#00FFFF' ) . 
[] ottr:of ex:template ;
   ottr:values( imf:ActivityAspect '>' '#000000' ) . 
#+END_src

*** py_run_sparql

Run SPARQL queries on RDF data files. Output a table.

#+NAME: py_run_sparql
#+BEGIN_SRC python :var query="SELECT ?s ?p ?o {?s ?p ?o} LIMIT 10" :var prefixes=py_prefixes_sparql() :var data="out/owl/imf-ontology.owl.ttl" :results raw

# input: 'query': SPARQL query string
# input: 'prefixes': a string of prefixes for conveniently appending to the query
# input: 'data': the RDF dataset to query

import rdflib
import csv

graph = rdflib.Graph()

# read RDF turtle file:
graph.parse(data, format="ttl")

# query graph:
qResult = graph.query(prefixes + " " + query)

output = ""

# handle the results according to the query type

if qResult.type == "SELECT":

  # serialise results to string
  sResult = qResult.serialize(format="csv").decode('utf-8')

  lines = sResult.splitlines() # split on each new line
  reader = csv.reader(lines, delimiter=',')

  ## here I format the results into a table in format I use for my
  ## slides.  Format according to your own needs.
  line = 1;
  for row in reader: # split on each new line
    output += "|"
    for value in row:
      if value.startswith("http://"):
        value = ", ".join(map(graph.namespace_manager.qname, value.split(", ")))
        #value = graph.namespace_manager.qname(value) # convert urls to qnames
      if len(value) > 0:
        output += "~" + ' '.join(value.split()) + "~" # monospace formatting
      output += "|"
    output += "\n"
    if line == 1:
      output += "|-\n" # hline
    line += 1

elif qResult.type == "ASK":
  output = str(bool(qResult))

elif qResult.type == "CONSTRUCT":
  gResult = rdflib.Graph()
  gResult.namespace_manager = graph.namespace_manager # copy prefixes from data source
  for row in qResult:
    gResult.add(row);
  output = gResult.serialize(format='turtle').decode('utf-8')

return output
#+END_SRC


*** py_imf_ontology_latex_export

#+NAME: py_make_latex_ontology_report
#+BEGIN_SRC python :var prefixes=py_prefixes_sparql() :results file

import rdflib
from rdflib import Graph, URIRef, BNode
from rdflib.namespace import NamespaceManager, OWL, SH, RDFS, RDF, DC, DCTERMS, SKOS, VANN

ontology = rdflib.Graph()
ontology.parse("out/owl/imf-ontology.owl.ttl", format="ttl")
nm = NamespaceManager(ontology)

shacl = rdflib.Graph()
shacl.parse("out/shacl/imf-model-grammar.shacl.ttl", format="ttl")


def qname(x):
  if type(x) == URIRef:
    return nm.normalizeUri(x)
  elif type(x) == BNode:
    return "blank"
  else:
    return x

def texEnv(env,s):
  if s != '':
    return "\n\\begin{" + env + "}\n" + s.strip() + "\n\end{" + env + "}\n\n"
  else:
    return s

def texItem(term, predicate, name, joiner="\n\n", dir="X", graph=ontology):
  if dir == "subjects":
    values = graph.subjects(predicate, term)
  else:
    values = graph.objects(term, predicate)
  values = sorted(map(qname, list(filter(lambda x: type(x) != BNode, list(values)))))
  if bool(values) == False:
    return ''
  else:
    return "\item[" + name + "] " + texEnv('markdown', joiner.join(values))


output = ""

# Get ontology metadata

txtOntology = ""
iriOntology = URIRef("http://ns.imfid.org/imf#IMFOntology")

txtOntology += ontology.value(iriOntology, DCTERMS.description)
txtOntology += ontology.value(iriOntology, SKOS.scopeNote)
output += texEnv('markdown', txtOntology)

## Ontology summary

txtEntities  = texItem(OWL.Class, RDF.type, "Classes", joiner=", ", dir="subjects")
txtEntities += texItem(OWL.ObjectProperty, RDF.type, "Object properties", joiner=", ", dir="subjects")
txtEntities += texItem(OWL.DatatypeProperty, RDF.type, "Data properties", joiner=", ", dir="subjects")
txtEntities += texItem(OWL.AnnotationProperty, RDF.type, "Annotation properties", joiner=", ", dir="subjects")
txtEntities += texItem(OWL.NamedIndividual, RDF.type, "Individuals", joiner=", ", dir="subjects")
output += texEnv('description', txtEntities)

## Term definitions

for group in sorted(ontology.objects(None, VANN.termGroup, True), reverse=True):
  output += "\section{" + group.capitalize() + "}\n\n"
  output += "\\begin{figure}\centering\n"
  output += "\includegraphics[width=.8\\textwidth]{img/ontology/imf-ontology-" + group + ".png}\n\caption{Ontology group: " + group + "}\n\label{fig:ontology-group-" + group + "}\n\end{figure}\n\n"
    
  for term in sorted(ontology.subjects(VANN.termGroup, group)):
    # metadata
    output += "\subsection{" + ontology.value(term, SKOS.prefLabel, None) + "}\n"
    txtItems  = texItem(term, SKOS.definition, "Definition")
    txtItems += texItem(term, SKOS.scopeNote, "Usage note")
    txtItems += texItem(term, SKOS.example, "Example")
    txtItems += texItem(term, SKOS.note, "Note")
    txtItems += texItem(term, SKOS.editorialNote, "Editoral note")
    output += texEnv('description', txtItems)

    ## OWL
    output += "\subsubsection*{OWL Definition}\n"
    txtItems = "\item[IRI]" + texEnv('markdown', qname(term))
    txtItems += texItem(term, RDF.type, "Type", joiner=", ")
    txtItems += texItem(term, RDFS.subClassOf, "Superclass", joiner=", ")
    txtItems += texItem(term, RDFS.subClassOf, "Subclass", joiner=", ", dir="subjects")
    txtItems += texItem(term, RDFS.subPropertyOf, "Superproperty", joiner=", ")
    txtItems += texItem(term, RDFS.subPropertyOf, "Subproperties", joiner=", ", dir="subjects")
    txtItems += texItem(term, RDFS.domain, "Domain", joiner=", ")
    txtItems += texItem(term, RDFS.range, "Range", joiner=", ")
    txtItems += texItem(term, RDF.type, "Instances", joiner=", ", dir="subjects")
    output += texEnv('description', txtItems)

    # SHACL
    txtShacl = ""
    boolShacl = False
    termShape = URIRef(str(term) + "Shape")
    shprops = ['path', 'class', 'minCount', 'maxCount', 'severity', 'message']
    shpropsN = ['path', 'class', 'min', 'max', 'severity', 'message']

    tblEnd = " \\\\ \n"
    txtShacl += "{|" + 'l|' * len(shprops) + "}\n"
    txtShacl += "\\hline\n" + " & ".join(shpropsN) + tblEnd + "\\hline\n"
    for property in sorted(shacl.objects(termShape, SH.property)):
      boolShacl = True
      txtShacl += " & ".join([qname(shacl.value(property, SH[shp], None, default="")) for shp in shprops ]) + tblEnd
    txtShacl += "\\hline\n"
    
    if boolShacl:
      output += "\subsubsection*{SHACL Definition}\n" + texEnv('tabular', txtShacl)


f = open("out/imf-ontology.tex", "w")
f.write(output)
f.close()
#+END_SRC

#+RESULTS: py_make_latex_ontology_report
[[file:None]]

*** py_list_iris

#+NAME: py_list_iris
#+BEGIN_SRC python :noweb yes :var datafile="out/owl/imf-ontology.owl.ttl" :results raw
<<py_common_functions>>

iris = list(filter(lambda x: x.startswith("http://ns.imfid.org/imf#"), getAllIRIs(datafile)))
iris = ['<' + str(i) + '>' for i in iris]
iris.sort()

return ', '.join(iris)
#+END_SRC

*** py_iri_rdf_diff

Simple diff of 2 RDF files, output list of changed IRIs.

#+NAME: py_iri_rdf_diff
#+BEGIN_SRC python :noweb yes :var v2="out/owl/imf-ontology.owl.ttl" :var v1="https://ns.imfid.org/20221118/imf-vocabulary.owl.ttl" :results raw

<<py_common_functions>>

pGraph = rdflib.Graph()
pGraph.parse(v2, format="ttl")

def prepare(input):
  rL = list(input)
  rL2 = list(filter(lambda x: x.startswith("http://ns.imfid.org"), rL))
  rL2.sort()
  return list(map(pGraph.namespace_manager.qname, rL2))

iri1 = getAllIRIs(v1)
iri2 = getAllIRIs(v2)

inboth = iri1 & iri2
added = iri2 - iri1
deleted = iri1 - iri2

output = ""

output += " - IRIs present in both versions :: " + ", ".join(prepare(inboth)) + "\n\n"
output += " - IRIs present only in this version :: " + ", ".join(prepare(added)) + "\n\n"
output += " - IRIs present only in previous version :: " + ", ".join(prepare(deleted))

return output
#+END_SRC

#+RESULTS: py_iri_rdf_diff
 - IRIs present in both versions :: ns1:imf, imf:Aspect, imf:AspectElement, imf:Block, imf:FunctionBlock, imf:FunctionTerminal, imf:InputTerminal, imf:InstalledBlock, imf:InstalledTerminal, imf:LocationBlock, imf:LocationTerminal, imf:OutputTerminal, imf:ProductBlock, imf:ProductTerminal, imf:Terminal, imf:associativeRelation, imf:color, imf:hasAspect, imf:hasInputTerminal, imf:hasOutputTerminal, imf:hasPart, imf:hasTerminal, imf:hierarchicalRelation, imf:interAspectRelation, imf:intraAspectRelation, imf:prefix, imf:theInput, imf:theOutput

 - IRIs present only in this version :: ns2:imf, imf:, imf:Attribute, imf:AttributeQualifier, imf:BreakdownPoint, imf:ConnectionPoint, imf:Element, imf:FunctionElement, imf:InstalledElement, imf:LocationElement, imf:ProductElement, imf:ProvenanceQualifier, imf:RangeQualifier, imf:RegularityQualifier, imf:ScopeQualifier, imf:TerminalQualifier, imf:absoluteQualifier, imf:asFunction, imf:asInstalled, imf:asLocation, imf:asProduct, imf:averageQualifier, imf:calculatedQualifier, imf:classifier, imf:connectedTo, imf:continuousQualifier, imf:designQualifier, imf:externalReference, imf:functionAspect, imf:hasAttribute, imf:hasAttributeQualifier, imf:hasTerminalQualifier, imf:hierachicalRelation, imf:inputFlow, imf:installedAspect, imf:locationAspect, imf:maximumQualifier, imf:measuredQualifier, imf:medium, imf:minimumQualifier, imf:nominalQualifier, imf:normalQualifier, imf:operatingQualifier, imf:outputFlow, imf:partOf, imf:productAspect, imf:property, imf:specifiedQualifier, imf:symbol, imf:theConnected, imf:thePart, imf:theWhole, imf:uom, imf:value

 - IRIs present only in previous version :: ns3:imf-vocabulary, imf:FunctionAspect, imf:FunctionAspectElement, imf:FunctionInterfacePoint, imf:InstalledAspect, imf:InstalledAspectElement, imf:InstalledInterfacePoint, imf:InterAspectRelation, imf:InterfacePoint, imf:LocationAspect, imf:LocationAspectElement, imf:LocationInterfacePoint, imf:ProductAspect, imf:ProductAspectElement, imf:ProductInterfacePoint, imf:System, imf:SystemElement, imf:fulfilledBy, imf:fulfills, imf:isConnectedTo, imf:isPartOf, imf:memberOf

*** py_parse-ttl-file: Parse source block

Parses an ttl file and outputs a turtle source block.

#+NAME: py_parse-ttl-file
#+BEGIN_SRC python :var file="out/owl/imf-top.owl.ttl"
from rdflib import Graph

g = Graph()
g.parse(file, format="text/turtle")

return g.serialize(format='turtle').decode('utf-8')
#+END_SRC

#+RESULTS: py_parse-ttl-file

*** py_parse-ttl-block: Parse source block

Parses and outputs a turtle source block. Prefixes are given as input.

#+NAME: py_parse-ttl-block
#+BEGIN_SRC python :var prefixes=prefixes :var block=owl-top-ontology
from rdflib import Graph

g = Graph()
rdf = prefixes + "\n" + block
g.parse(data=rdf, format="text/turtle")

return g.serialize(format='turtle').decode('utf-8')
#+END_SRC

*** py Output RDF

#+NAME: py_output
#+BEGIN_SRC python :var file="out/owl/imf-top.owl.ttl" :var s="None" :var p="RDF.type"
from rdflib import Graph, RDF

g = Graph()
g.parse(file, format="text/turtle")

output = ""

for s, p, o in g.triples((s,  p, None)):
    output += f"{o}"

return output
#+END_SRC

#+RESULTS: py_output


*** Lists                                                          :noexport:

#+NAME: prefixlist
 - xsd :: http://www.w3.org/2001/XMLSchema#
 - rdf :: http://www.w3.org/1999/02/22-rdf-syntax-ns#
 - rdfs :: http://www.w3.org/2000/01/rdf-schema#
 - owl :: http://www.w3.org/2002/07/owl#
 - skos :: http://www.w3.org/2004/02/skos/core#
 - imf :: http://ns.imfid.org/imf#

#+NAME: py_functions
#+BEGIN_SRC python

## converts a org-mode definition list into a python dict
def deflist2dict(list):
  newlist={}
  for row in list:
    newrow = row[0].split(' :: ')
    newlist[newrow[0]] = newrow[1]

  return newlist

from rdflib import Graph, Namespace, URIRef

def getURIRef(prefixdict, qname):
  prefix, localname = qname.split(':')
  return URIRef(prefixdict[prefix] + localname)

def getGraph(prefixdict):
  graph = Graph()
  for key, value in prefixdict.items():
    ns = Namespace(value)
    graph.bind(key, ns)
  return graph
#+END_SRC

#+RESULTS: py_functions
: None

#+NAME: py_prefixlist2ttl
#+BEGIN_SRC python :noweb yes :var list=prefixlist 
<<py_functions>>

output = ""
for key, value in deflist2dict(list).items():
  output += '@prefix ' + key + ':\t<' + value + '> .\n'
return output
#+END_SRC

#+RESULTS: py_prefixlist2ttl
: @prefix xsd:	<http://www.w3.org/2001/XMLSchema#> .
: @prefix rdf:	<http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
: @prefix rdfs:	<http://www.w3.org/2000/01/rdf-schema#> .
: @prefix skos:	<http://www.w3.org/2004/02/skos/core#> .
: @prefix imf:	<http://ns.imfid.org/imf#> .

#+CALL: py_prefixlist2ttl[:wrap src ttl](list=prefixlist)
** org-mode setup
*** stderr

Include stderr in source block output:

#+PROPERTY: header-args:sh :prologue "exec 2>&1" :epilogue ":"

*** Folders

#+BEGIN_SRC ttl :tangle out/temp/.folder :mkdirp yes
#+END_SRC

#+BEGIN_SRC ttl :tangle bin/.folder :mkdirp yes
#+END_SRC

#+BEGIN_SRC ttl :tangle out/img/.folder :mkdirp yes

#+END_SRC

*** Global tangle includes
**** Graphviz 
#+NAME: graphviz-style
#+BEGIN_SRC dot :file out/img/.dummy-graphiz
 node [shape=box, fontname="Arial", style="filled"];
 edge [fontname="Arial"];
#+END_SRC


**** PlantUML

#+NAME: plantuml-style
#+BEGIN_SRC plantuml :file out/img/.dummy-plantuml
hide empty members

skinparam class {
 BackgroundColor HoneyDew
 BackgroundColor<< RDL >> SeaShell
 BackgroundColor<< Type >> LightCyan
}


#+END_SRC

* TODOs [23/57]

 - [ ] use markdown
   - [ ] / / -> **
   - [ ] links, []()
   - [ ] links < >
   - [ ] code snippets
   - [ ] IRIs as code
 - [ ] add imnages of r block and termianl to the ontologiy as oaf
   defipiction.
 - [ ] put OWL definition in a table?
 - [ ] explanation of OWL and SHACL definition.
 - [ ] Should we make a condenced version of chapter 4?
 - [ ] add more intro text, both to main heading and sub headings
 - [ ] make all comments more "readable".
 - [ ] make examples, also using code, `ex:myBlockA imf:hasPart ex:myBlockB` expresses that ...
 - [ ] Write messages for all SHACL shapes
 - [ ] Fix inverse SHACL path
 - [ ] sort SHACL paths. user SPARQL? https://rdflib.readthedocs.io/en/stable/intro_to_sparql.html
 - [ ] fix width of SHACL table
 - [ ] link to sections and their figures in the start.

 Questions:
 - [X] Are BreakdownPoints and ConnectionPoints also Elements? Perhaps
   not: If Elements may be broken down, ie. related by partOf, then we
   can breakdown a breakdown point, which does not seem correct.
 - [ ] Block and ConnectionPoints should be broken down to
   Graphs. Terminals might not be Elements (if elements are things
   that can be broken down to graphs). -> IMF v3
 - [ ] Can an Element be member of many Models?
 - What is the name of the relation between an Element and a Model.
 - [X] Can an attribute have many values? -> let's leave that open --
   and for the type to decide.
 - [ ] Represent ownership of models and elements?
 - [X] Compatibility: Should next version be backwards compatible --
   what does that mean?
 - [X] Check domain and range
   - Should hierarchial/assosicative relation have aspectelement as doman and range?
 - [X] Should connectedTo be symmetric? -> moved to editorialNote

 - [X] problem with direction-less connectedTo and the names theInput
   and theOutput.
 - [X] replace subproperty of inter/intra-aspectrelation to class
   axioms on AspectElement.
   - [X] also FunctionElement and so on, do this in Template
 - [ ] An InputTerminal cannot be connected to an InputTerminal
   (resp. OutputTerminal)
 - [ ] Visualisation vocabulary
   - point (xyz), node, path
   - connectionpoints
 - [X] Suggested list of metadata *for ontology*:
   - pav:version
 - [X] Create unstable ontology file, containing
   - [X] model
   - [X] breakdown points and connection points

 SHACL:
 - [X] generate IMF-vocabulary check from ontology, see python code in
   https://github.com/dyreriket/shipshape

 RDF:
 - [ ] ?? Define JSON/JSON-LD format (using JSON-LD context object)
   - https://json-schema.or/g
   - https://www.npmjs.com/package/shacl-jsonschema-converter
   - https://github.com/mulesoft-labs/json-ld-schema
   - https://github.com/philbarker/lr_schema/tree/book
 - [ ] ?? JSON framing?

 Documentation:
 - [X] Make changelog
 - [X] Mark all vocabulary elements with a term_status (s1, s2, s3,
   s4) and since (or something better)
 - [X] Make examples
 - [ ] +Define instanceOf?+ -> use rdf:type

 Process:
 - [X] Diagrams
 - [X] Definitions
 - [X] OWL ontology for RDF data model
 - [X] SHACL shapes for RDF data model
 - [ ] OTTR templates to instantiate datamodel
 - [ ] OTTR templates to create types
 - [ ] bOTTR (SHACL + OTTR) over types to
   - [ ] Prototypes
   - [ ] OWL class
 - [#] Vocabulary for visualisation -> v3
 - [ ] Visualisation
   - [ ] Instance data
   - [ ] Type data
 - [ ] Update generated diagrams from ontology
 - [ ] Generated diagrams of SHACL shapes, for validation?
 - [X] Create SHACL shape for the ontology
   - all classes, properties, individuals
     - MUST term_status 'unstable','testing', 'stable' and 'archaic'
     - MUST ++since++ (X.Y.Z), replace since with something from pav
     - MUST changeNote (format X.Y.Z\s::\sAdded|Changed|Deprecated .*)
     - MUST prefLabel
     - MUST definition
     - WARN example
   - ontology
     - ...

 Tools:
 - [ ] Align with Mimir:
   https://github.com/mimir-org/mimir/blob/main/src/service/ModelBuilder.Rdf/Properties/Resources.resx

 Publishing:
 - [ ] https://dgarijo.github.io/Widoco/
 - [#] Generate changelog: https://github.com/BiodivPortal/bubastis.
   - Getting null pointer, why?

 Diagrams:
 - [X] Cardinalities
 - [X] relation names
 - [X] Use stereotypes for
   - identified element
   - reified relation
 - [X] only datatype properties are represented using fields in the UML classes
 - [X] color UML classes differently
   - Instance
   - Type
   - External RDL

 Styling:
 - [ ] size of images

 Challenges:
 - [ ] Optimise generation of prototypes from SHACL
 - [ ] Structuring, maintenence of types
 - [ ] Merging IMF models, identifying conflicts
 - [ ] Align IMF models with Records

* Backup                                                           :noexport:

#+NAME: overview-types-old
#+BEGIN_SRC plantuml :noweb yes :file out/img/imf-overview-types-old.png
<<plantuml-style>>

stereotype Type << Identified >>

abstract class ElementType << Type >> {
  notation : 0..1 
  symbol : 0..1
}

class BlockType << Type >> {
}

class TerminalType << Type >>

class AttributeGroupType << Identified >> << Type >>

class AttributeType << Type >> {
.. constraints ..
 'legal values
 legal value range
 datatype
 regex
}

'Type <|-- ElementType
'Type <|-- AttributeType
ElementType <|-- BlockType
ElementType <|-- TerminalType

Type "*" --> "*" RDLItem : classifier

ElementType "*" --> "0..1" Aspect : hasAspect

TerminalType "*" --> "1" Medium : hasMedium
TerminalType "*" --> "0..1" Direction : hasDirection

BlockType o--> "*" TerminalType : hasTerminalType
(BlockType, TerminalType) .. _Constraint

class _Constraint {
 min : 0..1
 max : 0..1
 name : 0..1
 description : 0..1
}

ElementType "*" --> "*" AttributeGroupType : hasAttributeGroupType
(ElementType, AttributeGroupType) .. _Constraint

ElementType *--> "*" AttributeType : hasAttributeType
(ElementType, AttributeType) .. _Constraint

AttributeGroupType *--> "1..*" AttributeType : hasAttributeType

BlockType "0..1" <-- "*" Block : instanceOf
TerminalType "0..1" <-- "*" Terminal : instanceOf
AttributeType "0..1" <-- "*" Attribute : instanceOf
AttributeGroupType "0..1" <-- "*" AttributeGroup : instanceOf

enum ValueEnumeration << RDL >>
AttributeType --> ValueEnumeration : 0 .. 1
#+END_SRC
